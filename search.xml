<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>堆</title>
      <link href="/2020/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
      <url>/2020/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>堆(Heap)</strong>是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵<a href="https://baike.baidu.com/item/完全二叉树/7773232" target="_blank" rel="noopener">完全二叉树</a>的数组对象。</p><h2 id="1、二叉堆"><a href="#1、二叉堆" class="headerlink" title="1、二叉堆"></a>1、二叉堆</h2><p>二叉堆是完全二元树或者是近似完全二元树，按照数据的排列方式可以分为两种：最大堆和最小堆。</p><p>二叉堆一般都通过”数组”来实现</p><h2 id="2、左倾堆"><a href="#2、左倾堆" class="headerlink" title="2、左倾堆"></a>2、左倾堆</h2><p>左倾堆(leftist tree 或 leftist heap)，又被成为左偏树、左偏堆，最左堆等。</p><p>它和二叉堆一样，都是优先队列实现方式。可以高效解决”对两个优先队列进行合并”的问题。</p><p><img src="https://imine141.github.io/images/1559037013198.png" alt="img"></p><p>上图是一颗左倾树，它的节点除了和二叉树的节点一样具有左右子树指针外，还有两个属性：键值和零距离。</p><ul><li>键值：作用是来比较节点的大小，从而对节点进行排序。</li><li>零距离：是从一个节点到一个”最近的不满节点”的路径长度。不满节点是指该该节点的左右孩子至少有有一个为NULL。叶节点的NPL为0，NULL节点的NPL为-1。</li></ul><p>左倾堆有以下几个基本性质：</p><ul><li>节点的键值小于或等于它的左右子节点的键值。</li><li>节点的左孩子的NPL &gt;= 右孩子的NPL。</li><li>节点的NPL = 它的右孩子的NPL + 1。</li></ul><p>合并两个左倾堆的基本思想如下：</p><ol><li>如果一个空左倾堆与一个非空左倾堆合并，返回非空左倾堆。</li><li>如果两个左倾堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。</li><li>如果新堆的右孩子的NPL &gt; 左孩子的NPL，则交换左右孩子。</li><li>设置新堆的根节点的NPL = 右子堆NPL + 1</li></ol><h2 id="3、斜堆"><a href="#3、斜堆" class="headerlink" title="3、斜堆"></a>3、斜堆</h2><p>斜堆也叫自适应堆，它是左倾堆的一个变种。和左倾堆一样，它通常也用于实现优先队列；作为一种自适应的左倾堆，它的合并操作的时间复杂度也是O(log n)。</p><p>它与左倾堆的差别是：</p><ol><li>斜堆的节点没有”零距离”这个属性，而左倾堆则有。</li><li>斜堆的合并操作和左倾堆的合并操作算法不同。</li></ol><p>斜堆的合并操作</p><ol><li>如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。</li><li>如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。</li><li>合并后，交换新堆根节点的左孩子和右孩子。</li></ol><p>第 3 步是斜堆和左倾堆的合并操作差别的关键所在，如果是左倾堆，则合并后要比较左右孩子的零距离大小，若右孩子的零距离 &gt; 左孩子的零距离，则交换左右孩子；最后，在设置根的零距离。</p><h2 id="4、二项堆"><a href="#4、二项堆" class="headerlink" title="4、二项堆"></a>4、二项堆</h2><p>二项堆是二项树的集合。在了解二项堆之前，先对二项树进行介绍。</p><h3 id="1）二项树"><a href="#1）二项树" class="headerlink" title="1）二项树"></a>1）二项树</h3><p>二项树是一种递归定义的有序树。它的递归定义如下：</p><ol><li>二项树B0只有一个结点；</li><li>二项树Bk由两棵二项树B(k-1)组成的，其中一棵树是另一棵树根的最左孩子。</li></ol><p><img src="https://wujun234.github.io/images/1559037015017.jpg" alt="img"></p><h3 id="2）二项堆"><a href="#2）二项堆" class="headerlink" title="2）二项堆"></a>2）二项堆</h3><p>二项堆和之前所讲的堆(二叉堆、左倾堆、斜堆)一样，也是用于实现优先队列的。二项堆是指满足以下性质的二项树的集合：</p><ol><li>每棵二项树都满足最小堆性质。即，父节点的关键字 &lt;= 它的孩子的关键字。</li><li>不能有两棵或以上的二项树具有相同的度数(包括度数为0)。换句话说，具有度数k的二项树有0个或1个。</li></ol><p><img src="https://wujun234.github.io/images/1559037015069.jpg" alt="img"></p><h2 id="5、斐波那契堆"><a href="#5、斐波那契堆" class="headerlink" title="5、斐波那契堆"></a>5、斐波那契堆</h2><p>斐波那契堆(Fibonacci heap)是一种可合并堆，可用于实现合并优先队列。它比二项堆具有更好的平摊分析性能，它的合并操作的时间复杂度是O(1)。</p><p>与二项堆一样，它也是由一组堆最小有序树组成，并且是一种可合并堆。</p><p>与二项堆不同的是，斐波那契堆中的树不一定是二项树；而且二项堆中的树是有序排列的，但是斐波那契堆中的树都是有根而无序的。</p><p><img src="https://wujun234.github.io/images/1559037015086.jpg" alt="img"></p><h2 id="6、索引堆"><a href="#6、索引堆" class="headerlink" title="6、索引堆"></a>6、索引堆</h2><p>索引堆是对堆进行了优化。</p><p>索引堆使用了一个新的int类型的数组，用于存放索引信息。</p><p>索引堆的交换操作交换的是元素的索引，而不是直接交换元素。</p><h2 id="7、Treap-树堆"><a href="#7、Treap-树堆" class="headerlink" title="7、Treap 树堆"></a>7、Treap 树堆</h2><p>一棵treap是一棵修改了结点顺序的二叉查找树，如图，显示一个例子，通常树内的每个结点x都有一个关键字值key[x]，另外，还要为结点分配priority[x]，它是一个独立选取的随机数。</p><p><img src="https://wujun234.github.io/images/1559037015141.png" alt="img"></p><p>假设所有的优先级是不同的，所有的关键字也是不同的。treap的结点排列成让关键字遵循二叉查找树性质，并且优先级遵循最小堆顺序性质：</p><ol><li>如果v是u的左孩子，则key[v] &lt; key[u].</li><li>如果v是u的右孩子，则key[v] &gt; key[u].</li><li>如果v是u的孩子，则priority[u] &gt; priority[u].</li></ol><p>这两个性质的结合就是为什么这种树被称为“treap”的原因，因为它同时具有二叉查找树和堆的特征。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2020/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
      <url>/2020/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、图的基本概念"><a href="#一、图的基本概念" class="headerlink" title="一、图的基本概念"></a>一、图的基本概念</h2><p>图：由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G(V,E)，其中，G 表示一个图，V 是图 G 中顶点的集合。E 是图 G 中边的集合。</p><h3 id="1、各种图定义"><a href="#1、各种图定义" class="headerlink" title="1、各种图定义"></a>1、各种图定义</h3><ul><li><strong>无向边</strong>：若顶点 <code>V_i</code> 到 <code>V_j</code>，之间的边没有方向，则称这条边为无向边(Edge)。<ul><li>用无序偶对 (<code>V_i</code>，<code>V_j</code>) 来表示。</li></ul></li><li><strong>有向边</strong>：若从顶点 <code>V_i</code> 到 <code>V_j</code>的边有方向，则称这条边为有向边，也称为弧（Arc）。<ul><li>用有序偶&lt;<code>V_i</code>，<code>V_j</code>&gt;来表示 . <code>V_i</code>称为弧尾，<code>V_j</code>称为弧头。</li></ul></li><li><strong>无向图</strong>：如果图中任意两个顶点之间的边都是无向边，则称该图为无向图(Undirected graphs)。</li><li><strong>有向图</strong>：如果图中任意两个顶点之间的边都是有向边，则称该图为有向图(Directed graphs)。</li><li><strong>无向完全图</strong>：在无向图中，如果任意两个顶点之间都存在边，则称该因为无向完全图。<ul><li>含有 n 个顶点的无向完全图有  n(n-1)/2  条边。</li></ul></li><li><strong>有向完全图</strong>：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。<ul><li>含有 n 个顶点的有向完全图有 <code>n*(n-1)</code> 条边</li></ul></li><li><strong>权</strong>：与图的边或弧相关的数叫做权(Weight)</li><li><strong>网</strong>：带权的图通常称为网 (Network) 。</li><li><strong>简单图</strong>：在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。</li><li>有很少条边或弧的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong>。稀疏、稠密是相对的。</li><li><strong>子图</strong>：假设有两个图 G= (V,{E}) 和 G’= (V’,{E’}) ，如果 <code>V&#39;为 V的子图</code> 且 <code>E&#39;为 E的子图</code>，则称 G’ 为 G 的子图。</li></ul><h3 id="2、图的顶点与边间关系"><a href="#2、图的顶点与边间关系" class="headerlink" title="2、图的顶点与边间关系"></a>2、图的顶点与边间关系</h3><ul><li><strong>邻接点</strong>：无向图中，顶点之间如有边相连，则互为邻接点</li><li><strong>顶点的度</strong>：记为TD(v)<ul><li>无向图中，和顶点相关联的边的数目，就是顶点的度</li><li>有向图中，TD(v) = ID(v) + OD(v)<ul><li><strong>入度</strong>：有向图中，以顶点为头的弧的数目，记为ID(v)</li><li><strong>出度</strong>：有向图中，以顶点为尾的弧的数目，记为OD(v)</li></ul></li></ul></li><li><strong>路径</strong>：<ul><li>无向图中，顶点到顶点的路径是一个顶点序列</li><li>有向图中，路径也是有向的</li><li><strong>路径的长度</strong>：是路径上的边或弧的数目。</li></ul></li><li><strong>回路或环</strong>：第一个顶点到最后一个顶点相同的路径称为回路或环</li><li><strong>简单路径</strong>：序列中顶点不重复出现的路径称为简单路径</li><li><strong>简单回路</strong>：除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。</li></ul><h3 id="3、连通图相关术语"><a href="#3、连通图相关术语" class="headerlink" title="3、连通图相关术语"></a>3、连通图相关术语</h3><ul><li><strong>连通</strong>：无向图中，如果顶点间有路径，则称为连通的</li><li><strong>连通图</strong>：无向图中，如果图中任意两个顶点都是连通的，则为连通图</li><li><strong>强连通图</strong>：有向图中，每一对顶点之间都<em>相互</em>存在路径，则为强连通图</li><li><strong>连通分量</strong>：无向图中的<em>极大</em>连通子图称为连通分量</li><li><strong>强连通分量</strong>：有向图中的<em>极大</em>强连通子图称做有向图的强连通分量。</li><li><strong>生成树</strong>：无向图中连通且有 n 个顶点 n-l 条边。</li><li><strong>有向树</strong>：有向图恰有一个顶点的入度为 0 ，其余顶点的入度均为 1。</li><li><strong>生成森林</strong>：一个有向图的生成森林由若干棵有向树组成 ， 含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</li></ul><h2 id="二、图的存储及基本操作"><a href="#二、图的存储及基本操作" class="headerlink" title="二、图的存储及基本操作"></a>二、图的存储及基本操作</h2><h3 id="1、邻接矩阵：适合稠密图"><a href="#1、邻接矩阵：适合稠密图" class="headerlink" title="1、邻接矩阵：适合稠密图"></a>1、邻接矩阵：适合稠密图</h3><p>邻接矩阵 (Adjacency Matrix)用两个数组来表示图：</p><ul><li><p>一维数组：存储图中顶点信息</p></li><li><p>二维数组：存储图中的边或弧的信息。</p></li></ul><h4 id="1）无向图"><a href="#1）无向图" class="headerlink" title="1）无向图"></a>1）无向图</h4><p><img src="https://imine141.github.io/images/%E5%9B%BE1" alt="img"></p><ul><li>无向图的边数组是一个对称矩阵</li><li>有无边：arc[i][j] 是否为 1</li><li>顶点的度：顶点<code>v_i</code>在邻接矩阵中第 i 行(或第 i列)的元素之和</li><li>邻接点：邻接矩阵中第 i 行元素值为 1 就是顶点<code>v_i</code>的邻接点。</li></ul><h4 id="2）有向图"><a href="#2）有向图" class="headerlink" title="2）有向图"></a>2）有向图</h4><p><img src="https://imine141.github.io/images/%E5%9B%BE2" alt="img"></p><ul><li>有向图的矩阵不对称。</li><li>有无弧：arc[i][j] 是否为 1</li><li>入度：第 i 行元素之和</li><li>出度：第 i 列元素之和</li><li>邻接点：第 i 行元素值为 1 的</li></ul><h4 id="3）网"><a href="#3）网" class="headerlink" title="3）网"></a>3）网</h4><p>网的对应边或弧存权值</p><p><img src="https://imine141.github.io/images/%E5%9B%BE3.jpg" alt="img"></p><h3 id="2、邻接表：适合稀疏图"><a href="#2、邻接表：适合稀疏图" class="headerlink" title="2、邻接表：适合稀疏图"></a>2、邻接表：适合稀疏图</h3><p>邻接表(Adjacency List) 使用数组与链表相结合存储图</p><ul><li>一维数组：存顶点，和指向第一个邻接点的指针</li><li>单链表：存每个顶点的所有邻接点。邻接点在顶点表中的下标，</li></ul><h4 id="1）无向图-1"><a href="#1）无向图-1" class="headerlink" title="1）无向图"></a>1）无向图</h4><p><img src="https://imine141.github.io/images/%E5%9B%BE4.jpg" alt="img"></p><ul><li>度：顶点的边表中结点的个数</li><li>是否存在边：测试定点边表中是否存在结点下标</li><li>邻接点：顶点的边表</li></ul><h4 id="2）有向图-1"><a href="#2）有向图-1" class="headerlink" title="2）有向图"></a>2）有向图</h4><p>以顶点为弧尾来存储边表</p><p>有向图的逆邻接表：以顶点为弧头的边表</p><p><img src="https://imine141.github.io/images/%E5%9B%BE5.jpg" alt="img"></p><h4 id="3）网-1"><a href="#3）网-1" class="headerlink" title="3）网"></a>3）网</h4><p>在边表结点定义中再增加一个 weight 的数据域，存储权值信息</p><p><img src="https://imine141.github.io/images/%E5%9B%BE6.jpg" alt="img"></p><h3 id="3、十字链表：适合有向图"><a href="#3、十字链表：适合有向图" class="headerlink" title="3、十字链表：适合有向图"></a>3、十字链表：适合有向图</h3><p>对于有向图来说，邻接表是有缺陷的。出度入度只能关心一个。</p><p>十字链表把邻接表与逆邻接表结合起来。</p><ul><li>一维数组：顶点表结点<ul><li>data</li><li>firstin：入边表头指针</li><li>firstout：出边表头指针</li></ul></li><li>边表结点：<ul><li>tailvex：弧起点在顶点表的下标</li><li>headvex：弧终点在顶点表中的下标</li><li>headlink：入边表指针域</li><li>taillink ：边表指针域</li><li>weight：如果是网，存储权值</li></ul></li></ul><p>实线箭头指针的图示与邻接表相同。虚线箭头是逆邻接表的表示。</p><p><img src="https://imine141.github.io/images/%E5%9B%BE7.jpg" alt="img"></p><h3 id="4、邻接多重表：适合处理无向图的边"><a href="#4、邻接多重表：适合处理无向图的边" class="headerlink" title="4、邻接多重表：适合处理无向图的边"></a>4、邻接多重表：适合处理无向图的边</h3><p>ivex 和 jvex 是与某条边依附的两个顶点在顶点表中下标。ilink 指向依附顶点 ivex 的下一条边， jlink 指向依附顶点 jvex 的下一条边。这就是邻接多重表结构。</p><p>邻接多重表与邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。</p><p><img src="https://imine141.github.io/images/%E5%9B%BE8.jpg" alt="img"></p><h3 id="5、边集数组：适合对边依次处理"><a href="#5、边集数组：适合对边依次处理" class="headerlink" title="5、边集数组：适合对边依次处理"></a>5、边集数组：适合对边依次处理</h3><p>边集数组是由两个一维数组构成。一个是存储顶点的信息;另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标 (begin) 、终点下标 (end) 和权(weigbt) 组成</p><p><img src="https://imine141.github.io/images/%E5%9B%BE9" alt="img"></p><h2 id="三、图的遍历"><a href="#三、图的遍历" class="headerlink" title="三、图的遍历"></a>三、图的遍历</h2><p>图的遍历(Traversing Grapb)：从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次</p><h3 id="1、深度优先搜索"><a href="#1、深度优先搜索" class="headerlink" title="1、深度优先搜索"></a>1、深度优先搜索</h3><p>深度优先遍历(Depth_First_Search)，也有称为深度优先搜索，简称为 DFS。</p><p>类似于树的前序遍历，用数组记录访问：</p><ol><li>访问初始结点v，并标记结点v为已访问。</li><li>查找结点v的第一个邻接结点w。</li><li>若w存在，则继续执行4，否则算法结束。</li><li>若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。</li><li>查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</li></ol><h3 id="2、广度优先搜索"><a href="#2、广度优先搜索" class="headerlink" title="2、广度优先搜索"></a>2、广度优先搜索</h3><p>广度优先遍历 (Breadth.First.Search) ，又称为广度优先搜索，简称 BFS。</p><p>类似于树的分层遍历，用队列保持访问过的结点的顺序：</p><ol><li>访问初始结点v并标记结点v为已访问。</li><li>结点v入队列</li><li>当队列非空时，继续执行，否则算法结束。</li><li>出队列，取得队头结点u。</li><li>查找结点u的第一个邻接结点w。</li><li>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：<ol><li>若结点w尚未被访问，则访问结点w并标记为已访问。</li><li>结点w入队列</li><li>查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</li></ol></li></ol><h2 id="四、图的基本应用"><a href="#四、图的基本应用" class="headerlink" title="四、图的基本应用"></a>四、图的基本应用</h2><h3 id="1、最小（代价）生成树"><a href="#1、最小（代价）生成树" class="headerlink" title="1、最小（代价）生成树"></a>1、最小（代价）生成树</h3><p>最小生成树： 一个具有n个顶点的加权的无向连通图，用n-1条边连接这n个顶点，并且使得连接之后的所有边的权值之和最小的树。</p><h4 id="1）普里姆-Prim-算法"><a href="#1）普里姆-Prim-算法" class="headerlink" title="1）普里姆 ( Prim )算法"></a>1）普里姆 ( Prim )算法</h4><ol><li>将点分为两拨，已经加入最小生成树的，未加入的</li><li>找到未加入中距离集合最近的点，添加该点，修改其它点到集合的距离</li><li>直到所有结点都加入到最小生成树</li></ol><h4 id="2）克鲁斯卡尔-Kruskal-算法"><a href="#2）克鲁斯卡尔-Kruskal-算法" class="headerlink" title="2）克鲁斯卡尔( Kruskal )算法"></a>2）克鲁斯卡尔( Kruskal )算法</h4><ol><li>现将所有边进行权值的从小到大排序</li><li>定义一个一维数组代表连接过的边，数组的下标为边的起点，值为边的终点</li><li>按照排好序的集合用边对顶点进行依次连接，连接的边则存放到一维数组中</li><li>用一维数组判断是否对已经连接的边能构成回路，有回路则无效，没回路则是一条有效边</li><li>重复3，4直至遍历完所有的边为止，即找到最小生成树</li></ol><h3 id="2、最短路径"><a href="#2、最短路径" class="headerlink" title="2、最短路径"></a>2、最短路径</h3><p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</p><h4 id="1）迪杰斯特拉-Dijkstra-算法"><a href="#1）迪杰斯特拉-Dijkstra-算法" class="headerlink" title="1）迪杰斯特拉( Dijkstra ) 算法"></a>1）迪杰斯特拉( Dijkstra ) 算法</h4><p>适用于求一个节点到其他节点的最短路径，通过广度搜索来遍历其他所有需要求距离的点。</p><ol><li>选取初始节点作为一个集合，D(v)表示初始节点到V节点的最短路径</li><li>所有能直接到达V的节点路径记为 D(v)=距离，不能直接到达的节点路径记为 D(v)=无穷</li><li>选取 D(v) 最小的节点加入初始节点集合，最短路径记为<code>D(w)=min(D(w),D(v)+j(v,w))</code>（j(v,w)为节点V到W的距离）</li><li>重复步骤3，直到所有节点都加入初始节点集合</li></ol><h4 id="2）弗洛伊德-Floyd-算法"><a href="#2）弗洛伊德-Floyd-算法" class="headerlink" title="2）弗洛伊德( Floyd )算法"></a>2）弗洛伊德( Floyd )算法</h4><p>适用于求所有顶点至所有顶点的最短路径问题。</p><p><img src="https://imine141.github.io/images/%E5%9B%BE10.jpg" alt="img"></p><ol><li>确定一个中间点</li><li>定义两个二维数组 D[][] 和 P[][]<ul><li>D 代表顶点到顶点的最短路径权值和的矩阵，即点的邻接矩阵</li><li>P 代表对应顶点的最小路径的前驱矩阵</li></ul></li><li>对于每一对顶点 v 和 w，看看是否存在一个顶点 u 使得从 v 到 u 再到 w 比己知的路径更短。</li></ol><h3 id="3、拓扑排序"><a href="#3、拓扑排序" class="headerlink" title="3、拓扑排序"></a>3、拓扑排序</h3><ul><li>AOV：有向无环图</li><li>拓扑序列：是一个有向无环图的所有顶点的线性序列。<ul><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ul></li><li>拓扑排序：对一个有向图构造拓扑序列的过程<ul><li>从 AOV 中选择一个入度为0的顶点并输出。</li><li>从图中删除该顶点，井删除以此顶点为尾的弧</li><li>重复此步骤，直到输出全部顶点，或不存在入度为0的顶点为止。</li></ul></li></ul><p>建立一个邻接表，在顶点表结点结构中，增加一个人度域 in</p><h3 id="4、关键路径"><a href="#4、关键路径" class="headerlink" title="4、关键路径"></a>4、关键路径</h3><ul><li>AOE：有向无环网</li><li>路径长度：路径上各个活动所持续的时间之和</li><li>关键路径：从源点到汇点具有最大长度的路径</li><li>关键活动：在关键路径上的活动</li></ul><h5 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h5><ol><li>事件最早开始时间（etv）：顶点<code>v_k</code>最早发生的时间。</li><li>事件最晚开始时间（ltv）：顶点<code>v_k</code>最晚发生的时间，超出则会延误整个工期。</li><li>活动的最早开始时间（ete）：弧<code>a_k</code>最早发生时间。</li><li>活动的最晚开始时间（lte）：弧<code>a_k</code>最晚发生时间。不推迟工期的最晚开工时间。</li></ol><p>由 1 和 2 可以求得 3 和 4 ，然后再根据 ete[k] 是否与 lte[k] 相等来判断<code>a_k</code>是 否是关键活动。</p><p>建立一个邻接表，弧链表增加了 weight 域，用来存储弧的权值。</p><ul><li>先要调用一次拓扑序列算法的代码来计算etv和拓扑序列表。</li><li>数组etv存储事件最早发生时间</li><li>数组ltv存储事件最迟发生时间</li><li>全局栈用来保存拓扑序列</li></ul><p>如果是多条关键路径，则单是提高一条关键路径上的关键活动速度并不是能导致整个工程缩短工期、而必须提高同时在几条关键路径上的活动的速度。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2020/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
      <url>/2020/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="一、树的基本概念"><a href="#一、树的基本概念" class="headerlink" title="一、树的基本概念"></a>一、树的基本概念</h2><p>树：是 n ( n&gt;=0 ) 个结点的有限集。</p><ul><li>n = 0 时称为空树。</li><li>在任意一棵非空树中:<ul><li>有且仅有一个根结点</li><li>当 n &gt; 1 时，其余结点可分为一个或多个互不相交的有限集。 其中每一个集合本身又是一棵树，并且称为根的子树。</li></ul></li></ul><h3 id="1、结点分类"><a href="#1、结点分类" class="headerlink" title="1、结点分类"></a>1、结点分类</h3><ul><li>结点的度：结点拥有的子树数</li><li>叶结点：度为 0 的结点</li><li>分支结点：度不为 0 的结点</li><li>树的度：树内各结点的度的最大值</li></ul><h3 id="2、结点间关系"><a href="#2、结点间关系" class="headerlink" title="2、结点间关系"></a>2、结点间关系</h3><ul><li>孩子：结点的子树的根称</li><li>双亲：上一结点</li><li>兄弟：同一个双亲的孩子</li><li>祖先：从根到该结点所经分支上的所有结点</li></ul><h3 id="3、树的其他相关概念"><a href="#3、树的其他相关概念" class="headerlink" title="3、树的其他相关概念"></a>3、树的其他相关概念</h3><ul><li>层次：根开始定义起，根为第一层 ，根的孩子为第二层</li><li>堂兄弟：双亲在同一层的结点</li><li>树的深度：树中结点的最大层次</li><li>有序树：树中结点的各子树从左至右有次序，不能互换</li><li>无序树：非有序树</li><li>森林：m (m&gt;=0) 互不相交的树的集合</li></ul><h2 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h2><h3 id="1、二叉树的定义"><a href="#1、二叉树的定义" class="headerlink" title="1、二叉树的定义"></a>1、二叉树的定义</h3><p>二叉树：是 n(n &gt;= 0) 个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p><h4 id="1）主要特征"><a href="#1）主要特征" class="headerlink" title="1）主要特征"></a>1）主要特征</h4><ul><li>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。</li><li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树.</li></ul><h4 id="2）特殊二叉树"><a href="#2）特殊二叉树" class="headerlink" title="2）特殊二叉树"></a>2）特殊二叉树</h4><ul><li>斜树：都只有一边子结点<ul><li>左斜树：所有的结点都只有左子树的二叉树</li><li>右斜树：所有结点都是只有右子树的二叉树</li><li>线性表结构可以理解为是树的一种极其特殊的表现形式</li></ul></li><li>满二叉树：每层结点都排满了</li><li>完全二叉树：按层排序，到结尾中间没有漏掉的结点</li></ul><h4 id="3）二叉树性质"><a href="#3）二叉树性质" class="headerlink" title="3）二叉树性质"></a>3）二叉树性质</h4><ul><li><p>在二叉树的第 i 层上至多有 <code>2^{i-1}</code> 个结点 (i &gt;= 1 ) 。</p></li><li><p>深度为 k 的二叉树至多有<code>2^k-1</code>个结点 (k &gt;= l) 。</p></li><li><p>对任何一棵二叉树 T，如果其终端结点数为 <code>n_0</code>，度为 2 的结点数为 <code>n_2</code>，则 <code>n_0 = n_2 +1</code>。</p></li><li><p>具有 n 个结点的完全二叉树的深度为 <code>[log_2n]+1</code> ([x] 表示不大于 x 的最大整数)。</p></li><li><p>如果对一棵有 n 个结点的完全二叉树(其深度为 <code>[log_2n]+1</code> ) 的结点按层序编号(从第 1 层到第<code>[log_2n]+1</code>层，每层从左到右) ，对任一结点 i (1&lt;= i&lt;= n)有:</p><ul><li>如果 i = 1 ，则结点 i 是二叉树的根，无双亲；如果 i &gt; 1 ，则其双亲是结点 [i/2]。</li></ul></li><li><p>如果 2i &gt; n ，则结点 i 无左孩子(结点 i 为叶子结点)；否则其左孩子是结点 2i。</p><ul><li>如果 2i+1 &gt; n ，则结点 i 无右孩子；否则其右孩子是结点 2i+1 。</li></ul></li></ul><h3 id="2、二叉树的存储结构"><a href="#2、二叉树的存储结构" class="headerlink" title="2、二叉树的存储结构"></a>2、二叉树的存储结构</h3><h4 id="1）顺序存储结构"><a href="#1）顺序存储结构" class="headerlink" title="1）顺序存储结构"></a>1）顺序存储结构</h4><p>顺序存储结构一般只用于完全二叉树。</p><p>用一维数组存储二叉树中的结点，数组的下标和结点序号一致。没有结点的存空。</p><h4 id="2）链式存储结构"><a href="#2）链式存储结构" class="headerlink" title="2）链式存储结构"></a>2）链式存储结构</h4><p>二叉链表：一个数据域和两个指针域的链表。</p><p>指针域分别存左孩子和右孩子的指针。</p><h3 id="3、二叉树的遍历"><a href="#3、二叉树的遍历" class="headerlink" title="3、二叉树的遍历"></a>3、二叉树的遍历</h3><h4 id="1）遍历方法"><a href="#1）遍历方法" class="headerlink" title="1）遍历方法"></a>1）遍历方法</h4><ul><li>前序遍历：根节点-&gt;左子树-&gt;右子树</li><li>中序遍历：左子树-&gt;根节点-&gt;右子树</li><li>后序遍历：左子树-&gt;右子树-&gt;根节点</li><li>层序（宽度优先、广度优先）遍历：每一层从左向右输出</li></ul><p>前序、中序、后序遍历用迭代很简单。</p><p>层序遍历，元素储存有先进先出的特性，选用队列。</p><h4 id="2）遍历推导"><a href="#2）遍历推导" class="headerlink" title="2）遍历推导"></a>2）遍历推导</h4><ul><li>己知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li><li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树 。</li><li>已知前序和后序遍历，是不能确定一棵二叉树的</li></ul><h4 id="3）二叉树的建立"><a href="#3）二叉树的建立" class="headerlink" title="3）二叉树的建立"></a>3）二叉树的建立</h4><p>扩展二叉树：将每个结点的空指针引出一个虚结点，值为特定值（如“#”）</p><p>扩展二叉树可以用递归采用前序、中序、后序遍历的一个遍历序列就确定一颗二叉树。</p><h3 id="4、线索二叉树"><a href="#4、线索二叉树" class="headerlink" title="4、线索二叉树"></a>4、线索二叉树</h3><h4 id="1）基本概念"><a href="#1）基本概念" class="headerlink" title="1）基本概念"></a>1）基本概念</h4><ul><li>线索：指向前驱和后继的指针称为线索</li><li>线索链表：加上线索的二叉链表称为线索链表</li><li>线索化：将二叉链表中的空指针改为指向前驱或后继的线索</li></ul><p>线索二叉树，等于是把一棵二叉树转属变成了一个双向链表，对插入删除结点、查找某个结点都带来了方便</p><h4 id="2）构造"><a href="#2）构造" class="headerlink" title="2）构造"></a>2）构造</h4><p>每个结点增设两个标志域 ltag 和 rtag，区分指针是指向孩子还是指向前驱、后继。</p><p>在遍历的过程中修改空指针。</p><p>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p><h2 id="三、树、森林"><a href="#三、树、森林" class="headerlink" title="三、树、森林"></a>三、树、森林</h2><h3 id="1、树的存储结构"><a href="#1、树的存储结构" class="headerlink" title="1、树的存储结构"></a>1、树的存储结构</h3><h4 id="1-）双亲表示法"><a href="#1-）双亲表示法" class="headerlink" title="1 ）双亲表示法"></a>1 ）双亲表示法</h4><p>除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。</p><p><img src="https://imine141.github.io/images/%E6%A0%911" alt=""></p><p>存储结构的设计是一个非常灵活的过程。</p><ul><li>双亲域：增加一个结点指示其双亲结点的域</li><li>长子域：增加一个结点最左边孩子的域</li><li>右兄弟域：增加一个右兄弟域体现兄弟关系</li></ul><p>当算法中需要在树结构中频繁地查找某结点的父结点时，使用双亲表示法最合适。当频繁地访问结点的孩子结点时，双亲表示法就很麻烦，采用孩子表示法就很简单。</p><h4 id="2）孩子表示法"><a href="#2）孩子表示法" class="headerlink" title="2）孩子表示法"></a>2）孩子表示法</h4><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。</p><ul><li>方案一：指针域的个数就等于树的度<ul><li>树中各结点的度相差很大时，浪费空间</li></ul></li><li>方案二：每个结点指针域的个数等于该结点的度<ul><li>各个结点的链表是不相同的结构，还要维护结点的度的数值，浪费运算时间</li></ul></li></ul><h5 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h5><p>把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</p><p><img src="https://imine141.github.io/images/%E6%A0%912" alt=""></p><h5 id="双亲孩子表示法"><a href="#双亲孩子表示法" class="headerlink" title="双亲孩子表示法"></a>双亲孩子表示法</h5><p>使用孩子表示法存储的树结构，正好和双亲表示法相反，适用于查找某结点的孩子结点，不适用于查找其父结点。可以将两种表示方法合二为一</p><p><img src="https://imine141.github.io/images/%E6%A0%913" alt=""></p><h5 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h5><p>把一棵复杂的树变成一棵二叉树</p><p>链表中每个结点由 3 部分组成：</p><ul><li>孩子指针域：表示指向当前结点的第一个孩子结点</li><li>数据域</li><li>兄弟指针域：表示指向当前结点的下一个兄弟结点</li></ul><p><img src="https://imine141.github.io/images/%E6%A0%914" alt=""></p><h3 id="2、树、森林与二叉树的转换"><a href="#2、树、森林与二叉树的转换" class="headerlink" title="2、树、森林与二叉树的转换"></a>2、树、森林与二叉树的转换</h3><h4 id="1）树转换为二叉树"><a href="#1）树转换为二叉树" class="headerlink" title="1）树转换为二叉树"></a>1）树转换为二叉树</h4><ol><li>加线。在所有兄弟结点之间加一条连线。</li><li>去钱。对树中每个结点，只保留它与第一个孩子结点的连线，删除色与其他孩子结点之间的连线。</li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。（注意第一个孩子是结点的左孩子，兄弟转换过来的孩子是结点的右孩子）</li></ol><p><img src="https://imine141.github.io/images/%E6%A0%915" alt=""></p><h4 id="2）森林转换为二叉树"><a href="#2）森林转换为二叉树" class="headerlink" title="2）森林转换为二叉树"></a>2）森林转换为二叉树</h4><ol><li>把每棵树转换为二叉树。</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。</li></ol><p><img src="https://imine141.github.io/images/%E6%A0%916" alt=""></p><h4 id="3）二叉树转换为树"><a href="#3）二叉树转换为树" class="headerlink" title="3）二叉树转换为树"></a>3）二叉树转换为树</h4><ol><li>加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。</li><li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li><li>层次调整。</li></ol><p><img src="https://imine141.github.io/images/%E6%A0%917" alt=""></p><h4 id="4）二叉树转换为森林"><a href="#4）二叉树转换为森林" class="headerlink" title="4）二叉树转换为森林"></a>4）二叉树转换为森林</h4><p>假如一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则将转换为一棵树。</p><ol><li>从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除…。直到所有这些根节点与右孩子的连线都删除为止。</li><li>将每棵分离后的二叉树转换为树。</li></ol><p><img src="https://imine141.github.io/images/%E6%A0%918" alt=""></p><h3 id="3、树和森林的遍历"><a href="#3、树和森林的遍历" class="headerlink" title="3、树和森林的遍历"></a>3、树和森林的遍历</h3><h4 id="1）树的遍历"><a href="#1）树的遍历" class="headerlink" title="1）树的遍历"></a>1）树的遍历</h4><p>分为两种方式</p><ul><li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历棍的每棵子树。</li><li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点</li></ul><h4 id="2）森林的遍历"><a href="#2）森林的遍历" class="headerlink" title="2）森林的遍历"></a>2）森林的遍历</h4><p>也分为两种方式:</p><ul><li>前序遍历: 先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依放用同样方式遍历除去第一棵树的剩余树构成的森林。</li><li>后序遍历: 是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。</li></ul><p>森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。</p><p>当以二叉链表作树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现。</p><h2 id="四、二叉树的应用"><a href="#四、二叉树的应用" class="headerlink" title="四、二叉树的应用"></a>四、二叉树的应用</h2><h3 id="1、BST（二叉排序树-二叉查找树-二叉搜索树）"><a href="#1、BST（二叉排序树-二叉查找树-二叉搜索树）" class="headerlink" title="1、BST（二叉排序树/二叉查找树/二叉搜索树）"></a>1、BST（二叉排序树/二叉查找树/二叉搜索树）</h3><h4 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h4><p>二叉排序树：又称为二叉查找树、二叉搜索树。它或者是一棵空树，或者是具有下列性质的二叉树。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值;</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值;</li><li>它的左、右子树也分别为二叉排序树。</li></ul><p>二叉排序树利于插入和删除的实现。</p><h4 id="2-操作"><a href="#2-操作" class="headerlink" title="2)操作"></a>2)操作</h4><ul><li>查找：查找成功返回ture，指向成功结点；查找失败返回false，指向上一结点。</li><li>插入：查找不成功，则插入到上一节点的子节点</li><li>构建：反复插入</li><li>删除：<ul><li>叶子节点直接删；</li><li>只有左或右子树的，“子继父业”；</li><li>左右子树都有的，找到需要删除的结点 p 的直接前驱(或直接后继) s，用 s 来替换结点 p，然后再删除此结点 s，s 的子结点移到 s 原来的位置</li></ul></li></ul><h3 id="2、平衡二叉树"><a href="#2、平衡二叉树" class="headerlink" title="2、平衡二叉树"></a>2、平衡二叉树</h3><h4 id="1）定义-1"><a href="#1）定义-1" class="headerlink" title="1）定义"></a>1）定义</h4><ul><li>平衡二叉树：是一种二叉排序树，其中每一个节点的左子树和右子树的高度之差的绝对值不超过 1。</li><li>平衡因子：二叉树上结点的左子树深度减去右子树深度的值（只可能是-1 、0 和 1）</li><li>最小失衡子树：在新插入的结点向上查找，以第一个平衡因子的绝对值超过1的结点为根的子树称为最小不平衡子树。</li></ul><h4 id="2）失衡调整"><a href="#2）失衡调整" class="headerlink" title="2）失衡调整"></a>2）失衡调整</h4><p><img src="https://imine141.github.io/images/%E6%A0%919" alt=""></p><ul><li>LL失衡：右旋（Zig）。当传入一个二叉排序树 P，将它的左孩子结点定义为 L ，将 L 的右子树变成 P 的左子树，再将 P 改成 L 的右子树，最后将 L 替换 P 成为根结点。</li><li>RR失衡：左旋（Zag）。与右旋对称。</li><li>LR失衡：先左旋后右旋（Zig-zag）</li><li>RL失衡：先右旋后左旋（Zag-zig）</li></ul><h3 id="3、堆"><a href="#3、堆" class="headerlink" title="3、堆"></a>3、堆</h3><p>最大堆、最小堆</p><h3 id="4、红黑树"><a href="#4、红黑树" class="headerlink" title="4、红黑树"></a>4、红黑树</h3><p>把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍。</p><h3 id="5、哈夫曼-Huffman-树和哈夫曼编码"><a href="#5、哈夫曼-Huffman-树和哈夫曼编码" class="headerlink" title="5、哈夫曼(Huffman)树和哈夫曼编码"></a>5、哈夫曼(Huffman)树和哈夫曼编码</h3><h4 id="1）赫夫曼树定义"><a href="#1）赫夫曼树定义" class="headerlink" title="1）赫夫曼树定义"></a>1）赫夫曼树定义</h4><ul><li>路径长度：从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。</li><li>树的路径长度：就是从树根到每一结点的路径长度之和。</li><li>带权路径长度：结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。</li><li>树的带权路径长度：为树中所有叶子结点的带权路径长度之和 。</li></ul><p>赫夫曼树：带权路径长度 WPL 最小的二叉树称做赫夫曼树。</p><h4 id="2-赫夫曼树构造"><a href="#2-赫夫曼树构造" class="headerlink" title="2)赫夫曼树构造"></a>2)赫夫曼树构造</h4><ol><li>根据给定的 n 个权值 {<code>w_1,w_2,...,w_n</code>} 构成 n 棵二叉树的集合 F={ <code>T_1,T_2,...,T_n</code>}，其中每棵二叉树 <code>T_i</code> 中只有一个带权为 <code>w_i</code> 根结点，其左右子树均为空。</li><li>在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li><li>在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中 。</li><li>重复 2 和 3 步骤，直到 F 只含一棵树为止。这棵树便是赫夫曼树。</li></ol><h4 id="3-赫夫曼编码"><a href="#3-赫夫曼编码" class="headerlink" title="3)赫夫曼编码"></a>3)赫夫曼编码</h4><p>赫夫曼编码：对需要编码的字符集，统计各个字符出现的次数或频率，作为权值，构造赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，从根节点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码。</p><ul><li>定长编码：像 ASCII 编码</li><li>变长编码：单个编码的长度不一致，可以根据整体出现频率来调节</li><li>前缀码：所谓的前缀码，就是没有任何码字是其他码字的前缀</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="/2020/08/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2020/08/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h3><ul><li>栈：是限定仅在表尾进行插入和删除操作的线性表。后进先出LIFO<ul><li>栈顶(top)：允许插入和删除的一端</li><li>核底(bottom)：另一端</li></ul></li><li>栈的引入简化了程序设计，使关注范围缩小，聚焦于要解决的问题核心。</li></ul><h3 id="2-栈的顺序存储结构-顺序栈"><a href="#2-栈的顺序存储结构-顺序栈" class="headerlink" title="2 栈的顺序存储结构 - 顺序栈"></a>2 栈的顺序存储结构 - 顺序栈</h3><h5 id="1）存储结构"><a href="#1）存储结构" class="headerlink" title="1）存储结构"></a>1）存储结构</h5><p>栈是线性表的特例，栈的顺序存储是线性表顺序存储的简化。</p><ul><li>栈底：数组0端</li><li>top 变量：指示栈顶元素在数组中的位置，空栈-1</li></ul><h5 id="2）基本操作"><a href="#2）基本操作" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>进栈push：栈顶指针加一，新插元素赋值栈顶空间</li><li>出栈pop：栈顶指针减一，返回原栈顶</li></ul><h5 id="3）两栈共享空间"><a href="#3）两栈共享空间" class="headerlink" title="3）两栈共享空间"></a>3）两栈共享空间</h5><p>一个数组来存储两个具有相同数据类型的栈，数组两端为栈底，向中间靠拢。</p><p>通常都是当两个栈的空间需求有相反关系时，才使用这样的数据结构。</p><h3 id="3-栈的链式存储结构-链栈"><a href="#3-栈的链式存储结构-链栈" class="headerlink" title="3 栈的链式存储结构 - 链栈"></a>3 栈的链式存储结构 - 链栈</h3><h5 id="1）存储结构-1"><a href="#1）存储结构-1" class="headerlink" title="1）存储结构"></a>1）存储结构</h5><ul><li>栈顶：单链表的头部，替代头结点</li></ul><h5 id="2）基本操作-1"><a href="#2）基本操作-1" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>进栈push：当前栈顶元素赋值给新结点后继，新结点赋值给栈顶指针</li><li>出栈pop：栈顶指针下移，释放原栈顶结点</li></ul><h5 id="3）顺序栈与链栈对比"><a href="#3）顺序栈与链栈对比" class="headerlink" title="3）顺序栈与链栈对比"></a>3）顺序栈与链栈对比</h5><ul><li>如元素变化不可预料，最好是用链栈；</li><li>如元素变化在可控范围内，使用顺序栈。</li></ul><h3 id="4-栈的应用"><a href="#4-栈的应用" class="headerlink" title="4 栈的应用"></a>4 栈的应用</h3><h5 id="1）递归"><a href="#1）递归" class="headerlink" title="1）递归"></a>1）递归</h5><p>编译器使用栈实现递归</p><h5 id="2）四则运算表达式求值"><a href="#2）四则运算表达式求值" class="headerlink" title="2）四则运算表达式求值"></a>2）四则运算表达式求值</h5><ul><li>中缀表达式：标准四则运算表达式，所有的运算符号都在两数字的中间<ul><li><code>9 + (3 - 1) * 3 + 10/2</code></li></ul></li><li>逆波兰表示：一种不需要括号的后缀表达法，所有的符号都是在要运算数字的后面出现<ul><li><code>9 3 1-3 * + 10 2 / +</code></li></ul></li></ul><h6 id="1-将中缀表达式转化为后缀表达式-栈用来进出运算的符号-。"><a href="#1-将中缀表达式转化为后缀表达式-栈用来进出运算的符号-。" class="headerlink" title="1. 将中缀表达式转化为后缀表达式(栈用来进出运算的符号)。"></a>1. 将中缀表达式转化为后缀表达式(栈用来进出运算的符号)。</h6><ul><li>从左到右遍历中缀表达式的每一数字和符号，若是数字就输出，即成为后缀表达式的一部分</li><li>若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈</li><li>一直到最终输出后缀表达式为止。</li></ul><h6 id="2-将后缀表达式进行运算得出结果-栈用来进出运算的数字-。"><a href="#2-将后缀表达式进行运算得出结果-栈用来进出运算的数字-。" class="headerlink" title="2. 将后缀表达式进行运算得出结果(栈用来进出运算的数字)。"></a>2. 将后缀表达式进行运算得出结果(栈用来进出运算的数字)。</h6><ul><li>从左到右遍历表达式的每个数字和符号，遇到是数字就进栈；</li><li>遇到是符号，就将处于栈顶两个数字出拢，进行运算，运算结果进栈</li><li>一直到最终获得结果。</li></ul><h2 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1 基本概念"></a>1 基本概念</h3><ul><li>队列：是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。先进先出FIFO<ul><li>队尾：允许插入的一端</li><li>队头：允许删除的一端称</li></ul></li></ul><h3 id="2-队列的顺序存储结构-循环队列"><a href="#2-队列的顺序存储结构-循环队列" class="headerlink" title="2 队列的顺序存储结构 - 循环队列"></a>2 队列的顺序存储结构 - 循环队列</h3><h5 id="1）存储结构-2"><a href="#1）存储结构-2" class="headerlink" title="1）存储结构"></a>1）存储结构</h5><ul><li>循环队列：队列的头尾相接的顺序存储结构</li><li>front 指针：头指针</li><li>rear 指针：尾指针。若队列不空，指向队尾的下一个位置</li><li>标志变量 flag：标记队列是否满了</li></ul><h5 id="2）基本操作-2"><a href="#2）基本操作-2" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>入队EnQueue：判满，新元素给尾指针位置，尾指针后移</li><li>出队DeQueue：判空，返回对头元素，头指针后移</li></ul><h3 id="3-队列的链式存储结构-链队列"><a href="#3-队列的链式存储结构-链队列" class="headerlink" title="3 队列的链式存储结构 - 链队列"></a>3 队列的链式存储结构 - 链队列</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。</p><ul><li>front 指针：头指针。指向头结点。</li><li>rear 指针：尾指针。指向终端结点。</li></ul><h5 id="2）基本操作-3"><a href="#2）基本操作-3" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>入队EnQueue：新结点赋值给原对尾结点后继，新结点设为队尾结点，尾指针指向新结点</li><li>出队DeQueue：头结点的后继结点出队，头结点的后继改为其后面的结点。若链表除头结点外只剩一个元素时， 则需将尾指针指向头结点</li></ul><h5 id="3）循环队列与链队列对比"><a href="#3）循环队列与链队列对比" class="headerlink" title="3）循环队列与链队列对比"></a>3）循环队列与链队列对比</h5><ul><li>在可以确定队列长度最大值的情况下，建议用循环队列</li><li>如果无法预估队列的长度时，则用链队列</li></ul><h3 id="4-队列的应用"><a href="#4-队列的应用" class="headerlink" title="4 队列的应用"></a>4 队列的应用</h3><p>键盘输入显示器输出</p><p>排队</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表List</title>
      <link href="/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、线性表的定义和基本操作"><a href="#一、线性表的定义和基本操作" class="headerlink" title="一、线性表的定义和基本操作"></a>一、线性表的定义和基本操作</h2><h5 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h5><p>线性表：零个或多个数据元素的有序排列。</p><blockquote><p>除第一个元素外，每个元素有且只有一个直接前驱元素；除最后一个元素外，每个元素有且只有一个直接后继元素。</p></blockquote><h5 id="2）基本操作"><a href="#2）基本操作" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>InitList：初始化</li><li>ListEmpty：判空</li><li>ClearList：清空</li><li>GetElem：取值</li><li>LocateElem：定位</li><li>Listlnsert：插入</li><li>ListDelete：删除</li><li>ListLength：长度</li></ul><h2 id="二、线性表的实现"><a href="#二、线性表的实现" class="headerlink" title="二、线性表的实现"></a>二、线性表的实现</h2><h3 id="1-顺序存储"><a href="#1-顺序存储" class="headerlink" title="1 顺序存储"></a>1 顺序存储</h3><h5 id="1）定义-1"><a href="#1）定义-1" class="headerlink" title="1）定义"></a>1）定义</h5><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p><h5 id="2）存储结构"><a href="#2）存储结构" class="headerlink" title="2）存储结构"></a>2）存储结构</h5><p>一维数组，存取时间性能为O(1)，随机存取结构</p><ul><li>存储空间的起始位置：数组 data 的存储位置</li><li>线性表的最大容量：数组长度 MaxSize</li><li>线性表的当前长度 : length</li></ul><h5 id="3）主要操作"><a href="#3）主要操作" class="headerlink" title="3）主要操作"></a>3）主要操作</h5><ul><li>取值O(1)：返回数组中指定下标的值。下标超限抛异常</li><li>插入O(n)：从最后一个元素到插入位置元素依次后移，插入，表长+1。位置或长度有问题抛异常或扩容。</li><li>删除O(n)：从删除位置到最后元素依次前移，表长-1。删除位置不合理抛异常。</li></ul><h5 id="4）优缺点"><a href="#4）优缺点" class="headerlink" title="4）优缺点"></a>4）优缺点</h5><p>优点</p><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li><li>可以快速地存取表中任一位置的元素</li></ul><p>缺点</p><ul><li>插入和删除操作需要移动大量元素</li><li>当线性表长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的”碎片”</li></ul><h3 id="2-链式存储"><a href="#2-链式存储" class="headerlink" title="2 链式存储"></a>2 链式存储</h3><h4 id="2-1-单链表"><a href="#2-1-单链表" class="headerlink" title="2.1 单链表"></a>2.1 单链表</h4><h5 id="1）定义-2"><a href="#1）定义-2" class="headerlink" title="1）定义"></a>1）定义</h5><p>不考虑相邻，哪有空就存哪，让每个元素知道它下一个元素的位置</p><h5 id="2）存储结构-1"><a href="#2）存储结构-1" class="headerlink" title="2）存储结构"></a>2）存储结构</h5><p>链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。</p><ul><li>单链表：每个结点中只包含一个指针域，n 个结点链结成一个链表</li><li>结点：数据元素的存储映像，由数据域和指针域组成<ul><li>数据域：存储数据元素信息的域</li><li>指针域：存储直接后继位置的域</li></ul></li><li>头指针：（必要元素）指向链表中第一个结点的存储位置</li><li>头结点：（可选元素）为方便操作，可在第一个结点前附设一个头结点。<ul><li>头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息。</li><li>有了头节点，对第一结点前插入和删除第一结点，与其他结点的操作就统一了</li></ul></li><li>线性链表的最后一个结点指针为“空”</li></ul><h5 id="3）主要操作-1"><a href="#3）主要操作-1" class="headerlink" title="3）主要操作"></a>3）主要操作</h5><ul><li>读取O(n)：从第一个节点遍历</li><li>插入、删除：遍历查找第i个元素O(n)，改变指针，插入和删除O(1)<ul><li>若不知道位置，与顺序存储结构没有优势。知道位置后，优势很大</li><li>对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显</li></ul></li><li>整表创建：动态生成链表。从空表起，依次建立元素结点，插入链表。<ul><li>头插法：新结点插入到头结点与前一新元素之间。</li><li>尾插法：记录尾结点，新结点插在终端结点后面</li></ul></li><li>整表删除：便利每个节点，在内存中将它释放</li></ul><h5 id="4）单链表与顺序存储优缺点"><a href="#4）单链表与顺序存储优缺点" class="headerlink" title="4）单链表与顺序存储优缺点"></a>4）单链表与顺序存储优缺点</h5><ul><li>时间性能<ul><li>查找<ul><li>顺序：o(1)</li><li>单链表：O(n)</li></ul></li><li>插入和删除<ul><li>顺序：平均移动一半元素，O(n)</li><li>单链表：找出位置后，O(1)</li></ul></li></ul></li><li>空间性能<ul><li>顺序：需预分配，大了浪费，小了溢出</li><li>单链表：无需分配不受限</li></ul></li><li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。</li><li>若需要频繁插入和删除时，宜采用单链表结构。</li><li>元素个数变化较大或未知时，最好用单链表。</li><li>如长度确定，顺序存储结构效率会高很多。</li></ul><h4 id="2-2-静态链表"><a href="#2-2-静态链表" class="headerlink" title="2.2 静态链表"></a>2.2 静态链表</h4><h5 id="1）定义-3"><a href="#1）定义-3" class="headerlink" title="1）定义"></a>1）定义</h5><p>针对没有指针的语言，用数组来代替指针描述链表，被称为静态链表。</p><h5 id="2）存储结构-2"><a href="#2）存储结构-2" class="headerlink" title="2）存储结构"></a>2）存储结构</h5><p>游标实现法：数组的元素都是由两个数据域组成， data 和 cur</p><ul><li>数据域data ：用来存放数据元素</li><li>游标 cur ：相当于单链表中的 next 指针，存放该元素的后继在数组中的下标</li><li>第一个元素：存放备用链表的第一个结点的下标</li><li>最后一个元素：存放第一个有数值的元素的下标</li></ul><h5 id="3）主要操作-2"><a href="#3）主要操作-2" class="headerlink" title="3）主要操作"></a>3）主要操作</h5><p>将可用空间链成备用链表</p><ul><li>插入<ul><li>模拟空间分配：从备用链表上取第一个结点作为待插入的新结点</li></ul></li><li>删除<ul><li>模拟空间释放：将删除位置加入备用链表第一位</li></ul></li></ul><h5 id="4）静态链表优缺点"><a href="#4）静态链表优缺点" class="headerlink" title="4）静态链表优缺点"></a>4）静态链表优缺点</h5><ul><li>插入和删除操作时 ，只需要修改游标。</li><li>没有解决连镇存储分配带来的表长难以确定的问题</li><li>失去了顺序存储结构随机存取的特性</li></ul><h4 id="2-3-循环链表"><a href="#2-3-循环链表" class="headerlink" title="2.3 循环链表"></a>2.3 循环链表</h4><h5 id="1）定义-4"><a href="#1）定义-4" class="headerlink" title="1）定义"></a>1）定义</h5><p>循环链表：将单链表中终端结点的指针端由空指针改为指向头结点，这种头尾相接的单链表称为单循环链表，简称循环链表。</p><h5 id="2）差异"><a href="#2）差异" class="headerlink" title="2）差异"></a>2）差异</h5><p>循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断 p-&gt;next 是否为空，现在则是 p -&gt; next 不等于头结点，则循环未结束。</p><h5 id="3）尾指针"><a href="#3）尾指针" class="headerlink" title="3）尾指针"></a>3）尾指针</h5><p>如用尾指针替代头指针，则查找开始结点和终端结点都很方便。</p><h4 id="2-4-双向链表"><a href="#2-4-双向链表" class="headerlink" title="2.4 双向链表"></a>2.4 双向链表</h4><h5 id="1）定义-5"><a href="#1）定义-5" class="headerlink" title="1）定义"></a>1）定义</h5><p>双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</p><h5 id="2）主要操作"><a href="#2）主要操作" class="headerlink" title="2）主要操作"></a>2）主要操作</h5><p>在插入和删除时，需要更改两个指针变量。顺序很重要，千万不能写反了。</p><ul><li>插入<ul><li>先搞定插入结点的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。</li></ul></li><li>删除<ul><li>将前结点的后继指向后结点，将后结点的前驱指向前结点</li></ul></li></ul><h3 id="3-线性表的应用"><a href="#3-线性表的应用" class="headerlink" title="3 线性表的应用"></a>3 线性表的应用</h3><p>队列和堆栈</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组与广义表</title>
      <link href="/2020/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
      <url>/2020/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数组的概念、多维数组的实现"><a href="#1-数组的概念、多维数组的实现" class="headerlink" title="1 数组的概念、多维数组的实现"></a>1 数组的概念、多维数组的实现</h3><h4 id="1）数组的概念"><a href="#1）数组的概念" class="headerlink" title="1）数组的概念"></a>1）数组的概念</h4><ul><li>数组的特点：元素数目固定；下标有界。</li><li>数组的操作：按照下标进行读写。</li></ul><h4 id="2）多维数组的实现"><a href="#2）多维数组的实现" class="headerlink" title="2）多维数组的实现"></a>2）多维数组的实现</h4><h5 id="行优先顺序"><a href="#行优先顺序" class="headerlink" title="行优先顺序"></a>行优先顺序</h5><p>存储时先按行从小到大的顺序存储，在每一行中按列号从小到大存储。</p><h5 id="列优先顺序"><a href="#列优先顺序" class="headerlink" title="列优先顺序"></a>列优先顺序</h5><p>存储时先按列从小到大的顺序存储，在每一列中按行号从小到大存储。</p><h3 id="2-矩阵的压缩存储"><a href="#2-矩阵的压缩存储" class="headerlink" title="2 矩阵的压缩存储"></a>2 矩阵的压缩存储</h3><p>矩阵的压缩存储就是存储数组时，尽量减少存储空间，但数组中每个元素必须存储。</p><p>在矩阵中，如果有规律可寻，只要存储其中一部分，而另外一部分的存储地址可以通过相应的算法将它计算出来，从而占有较少的存储空间达到存储整个矩阵的目的。</p><p>矩阵的压缩存储仅能针对特殊矩阵使用，对于没有规律可循的二维数组则不能使用。</p><h4 id="1）对称矩阵"><a href="#1）对称矩阵" class="headerlink" title="1）对称矩阵"></a>1）对称矩阵</h4><p>只需对对称矩阵中n(n+1)/2个元素进行储存表示</p><p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E5%B9%BF%E4%B9%89%E8%A1%A81" alt=""></p><h4 id="2）三角矩阵"><a href="#2）三角矩阵" class="headerlink" title="2）三角矩阵"></a>2）三角矩阵</h4><p>以主对角线划分，三角矩阵有上三角和下三角两种。上三角矩阵它的下三角中的元素均为常数。下三角矩阵正好相反，它的主对角线上方均为常数。</p><p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A82" alt=""></p><h4 id="3）稀疏矩阵"><a href="#3）稀疏矩阵" class="headerlink" title="3）稀疏矩阵"></a>3）稀疏矩阵</h4><p>if 一个 m * n 的矩阵含有 t 个非零元素，且 t 远远小于 m * n，则称这个矩阵为稀疏矩阵</p><p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A83" alt=""></p><p>除了记录非零元素的值之外，还必须同时几下它所在的行和列的位置。稀疏矩阵的存储方法一般有三种：三元组法、行逻辑连接顺序表和十字链表法。</p><h5 id="三元组法"><a href="#三元组法" class="headerlink" title="三元组法"></a>三元组法</h5><p>用三项内容表示稀疏矩阵中的每个非零元素，形式为：（i,j,value）。<br>其中，i 表示行序号，j 表示列序号，value 表示非零元素的值</p><h3 id="3-广义表的基本概念"><a href="#3-广义表的基本概念" class="headerlink" title="3 广义表的基本概念"></a>3 广义表的基本概念</h3><h4 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h4><ul><li>广义表：是线性表的扩展，具体定义为n（n≥0）个元素的有限集合。<br>n的值是广义表的长度，如果n=0称广义表为空表。</li><li>长度：广义表中含有元素的个数称</li><li>深度：广义表中含有的括号对数</li></ul><h5 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h5><p>广义表的数据元素有两种类型：一个是不可再分的元素（原子元素）；一个是可以再分的元素（子表）。</p><ul><li>如果所有的元素都是原子元素，则称为线性表。</li><li>如果数据元素中含有子表元素，则称为广义表。</li></ul><h5 id="记法"><a href="#记法" class="headerlink" title="记法"></a>记法</h5><p>广义表一般记作：LS=(a1,a2,……,an)</p><p>常见的广义表为：A=()、B=(())、C=(a,b)、D=(A,B,C)、E=(a,E)</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>广义表有三个重要的特点：</p><ul><li>第一：广义表的元素可以是子表，而子表的元素还可以是子表，广义表是一个多层次的结构。</li><li>第二：广义表可以为其他广义表所共享。</li><li>第三：广义表可以是一个递归表，即表也可以是其本身的一个子表。</li></ul><h4 id="2）存储方式"><a href="#2）存储方式" class="headerlink" title="2）存储方式"></a>2）存储方式</h4><p>广义表的存储方法有很多种，一般采用链表存储。</p><p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A84" alt=""></p><p>flag表示标志位。当flag为0时，表示该结点为原子元素，info表示原子元素的值；当flag为1时表示该结点为子表，info表示指针，指向该子表的第一个结点。 link表示指针，指向广义表的下一个元素。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符</title>
      <link href="/2020/08/18/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/08/18/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数学函数与常量"><a href="#1-数学函数与常量" class="headerlink" title="1 数学函数与常量"></a>1 数学函数与常量</h3><ul><li>Math.sqrt(x)：平方根</li><li>Math.pow(x, y)：幂运算，x 的 y 次幂</li><li>Math.floorMod(x, y)：求余</li></ul><h3 id="2-自增与自减运算符"><a href="#2-自增与自减运算符" class="headerlink" title="2 自增与自减运算符"></a>2 自增与自减运算符</h3><p>建议不要在表达式中使用 ++，容易带来疑惑和 bug</p><h3 id="3-关系和-boolean-运算符"><a href="#3-关系和-boolean-运算符" class="headerlink" title="3 关系和 boolean 运算符"></a>3 关系和 boolean 运算符</h3><ul><li><code>==</code></li><li><code>!=</code></li><li><code>&lt;</code></li><li><code>&gt;</code></li><li><code>&lt;=</code></li><li><code>&gt;=</code></li><li><code>&amp;&amp;</code>（短路）</li><li><code>||</code>（短路）</li><li><code>?:</code></li></ul><h3 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4 位运算符"></a>4 位运算符</h3><ul><li><p>逻辑</p><ul><li>整型<ul><li><code>|</code> (或)</li><li><code>&amp;</code> (且)</li><li><code>~</code> (非)</li><li><code>^</code> (抑或)</li></ul></li><li>布尔值<ul><li>可用 <code>&amp;</code> 和 <code>|</code>，只是不短路</li></ul></li></ul></li><li><p>位移</p><ul><li><pre><code>&lt;&lt;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  （左移）</span><br><span class="line"></span><br><span class="line">  - &#96;&lt;&lt;&#96; 时 int 模 32，long 模 64，如 1 &lt;&lt; 35 等于 1 &lt;&lt; 3</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>&gt;&gt;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  （带符号右移）</span><br><span class="line"></span><br><span class="line">  - “符号扩展”：若值为正，则在高位插入 0；若值为负，则在高位插入 1。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>&gt;&gt;&gt;</code></pre><p>（无符号右移）</p><ul><li>“零扩展”：无论正负，都在高位插入0。</li></ul></li><li><p>不存在 <code>&lt;&lt;&lt;</code></p></li></ul></li></ul><h3 id="5-括号与运算符级别"><a href="#5-括号与运算符级别" class="headerlink" title="5 括号与运算符级别"></a>5 括号与运算符级别</h3><h3 id="6-枚举类型"><a href="#6-枚举类型" class="headerlink" title="6 枚举类型"></a>6 枚举类型</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 基础设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2020/08/17/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E6%95%B0%E7%BB%84/"/>
      <url>/2020/08/17/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1. 一维数组"></a>1. 一维数组</h3><h4 id="1-1-声明"><a href="#1-1-声明" class="headerlink" title="1.1 声明"></a>1.1 声明</h4><p>一旦创建了数组就不能改变它的大小。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br></pre></td></tr></table></figure><h4 id="1-2-初始化"><a href="#1-2-初始化" class="headerlink" title="1.2 初始化"></a>1.2 初始化</h4><p>数字数组初始化为 0。boolean 数组初始化 false。对象数组初始化 null。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; ;</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-多维数组"><a href="#2-多维数组" class="headerlink" title="2. 多维数组"></a>2. 多维数组</h3><p>java 实际上没有多维数组，只有一维数组，多维数组被解释成“数组的数组”</p><h4 id="2-1-声明"><a href="#2-1-声明" class="headerlink" title="2.1 声明"></a>2.1 声明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[n][]</span><br></pre></td></tr></table></figure><h4 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] A &#x3D; &#123;</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Arrays-类"><a href="#3-Arrays-类" class="headerlink" title="3. Arrays 类"></a>3. Arrays 类</h3><h4 id="3-1-填充-fill"><a href="#3-1-填充-fill" class="headerlink" title="3.1 填充 fill()"></a>3.1 填充 <code>fill()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.fill(type[] a,type v);</span><br></pre></td></tr></table></figure><h4 id="3-2-排序-sort"><a href="#3-2-排序-sort" class="headerlink" title="3.2 排序 sort()"></a>3.2 排序 <code>sort()</code></h4><p>优化的快排</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序排序 </span></span><br><span class="line">Arrays.sort(type[] a);</span><br><span class="line"><span class="comment">//给开始位到结束位排序</span></span><br><span class="line">Arrays.sort(type[] a,<span class="keyword">int</span> start,<span class="keyword">int</span> end);</span><br></pre></td></tr></table></figure><h4 id="3-3-比较-equals"><a href="#3-3-比较-equals" class="headerlink" title="3.3 比较 equals()"></a>3.3 比较 <code>equals()</code></h4><p>比较元素是否相等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.equals(type[] a,type[] b);</span><br></pre></td></tr></table></figure><h4 id="3-4-查找-binarySearch"><a href="#3-4-查找-binarySearch" class="headerlink" title="3.4 查找 binarySearch()"></a>3.4 查找 <code>binarySearch()</code></h4><p>二分查找，数组一定要是先排好序，返回最后一个找到的位置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.binarySearch(type[] a,type v);</span><br><span class="line"><span class="comment">//范围查找</span></span><br><span class="line">Arrays.binarySearch(type[] a,type v,<span class="keyword">int</span> start,<span class="keyword">int</span> end);</span><br></pre></td></tr></table></figure><h4 id="3-5-拷贝-copyOf"><a href="#3-5-拷贝-copyOf" class="headerlink" title="3.5 拷贝 copyOf()"></a>3.5 拷贝 <code>copyOf()</code></h4><p>使用 Arrays 类的 copyOf 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度拷贝</span></span><br><span class="line"><span class="keyword">int</span>[] a = Arrays.copyOf(b,b.length);</span><br><span class="line"><span class="comment">//扩展</span></span><br><span class="line"><span class="keyword">int</span>[] a = Arrays.copyOf(b,b.length*<span class="number">2</span>);</span><br><span class="line"><span class="comment">//部分拷贝</span></span><br><span class="line">Arrays.copyOfRange(a,<span class="number">0</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="3-6-转字符串-toString"><a href="#3-6-转字符串-toString" class="headerlink" title="3.6 转字符串 toString()"></a>3.6 转字符串 <code>toString()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.toString(a)</span><br><span class="line"><span class="comment">//打印多维数组</span></span><br><span class="line">Arrays.deepToString()</span><br></pre></td></tr></table></figure><h4 id="3-7-转列表-asList"><a href="#3-7-转列表-asList" class="headerlink" title="3.7 转列表 asList()"></a>3.7 转列表 <code>asList()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Moe"</span>, <span class="string">"Curly"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 基础设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2020/08/16/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/08/16/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-String-底层实现"><a href="#1-String-底层实现" class="headerlink" title="1 String 底层实现"></a>1 String 底层实现</h3><p>String 被声明为 final，因此它不可被继承。</p><p>底层是 char 或 byte 类型的 value 数组，value 数组也被声明为 final，这意味着数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><p>编辑器可让字符串共享在常量池。</p><h4 id="1-1-Java-8-char-数组"><a href="#1-1-Java-8-char-数组" class="headerlink" title="1.1 Java 8 - char 数组"></a>1.1 Java 8 - char 数组</h4><p>在 Java 8 中，String 内部使用 char 数组存储数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-Java-9-byte-数组"><a href="#1-2-Java-9-byte-数组" class="headerlink" title="1.2 Java 9 - byte 数组"></a>1.2 Java 9 - byte 数组</h4><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-不可变的好处"><a href="#1-3-不可变的好处" class="headerlink" title="1.3 不可变的好处"></a>1.3 不可变的好处</h4><ul><li>可以缓存 hash 值<ul><li>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li></ul></li><li>String Pool 的需要<ul><li>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li></ul></li><li>安全性<ul><li>String 经常作为参数，String 不可变性可以保证参数不可变。</li><li>例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li></ul></li><li>线程安全<ul><li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li></ul></li></ul><h3 id="2-StringBuilder-和-StringBuffer"><a href="#2-StringBuilder-和-StringBuffer" class="headerlink" title="2 StringBuilder 和 StringBuffer"></a>2 StringBuilder 和 StringBuffer</h3><h4 id="2-1-可变性与线程安全"><a href="#2-1-可变性与线程安全" class="headerlink" title="2.1 可变性与线程安全"></a>2.1 可变性与线程安全</h4><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 可变，不是线程安全的，效率比 StringBuffer 高</li><li>StringBuffer 可变，是线程安全的，内部使用 synchronized 进行同步</li></ul><h4 id="2-2-底层实现"><a href="#2-2-底层实现" class="headerlink" title="2.2 底层实现"></a>2.2 底层实现</h4><p>StringBuilder 和 StringBuffer 继承了 AbstractStringBuilder，AbstractStringBuilder 的 char 数组没有 final 关键字修饰，字符数组长度可变，所有 StringBuilder 和 StringBuffer 也是可变的</p><p>AbstractStringBuilder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// StringBuilder 类继承 AbstractStringBuilder 抽象类</span></span><br><span class="line">    <span class="comment">// 创建长度 16 的字符数组</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-String-Pool-与引用"><a href="#3-String-Pool-与引用" class="headerlink" title="3 String Pool 与引用"></a>3 String Pool 与引用</h3><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。</p><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><ul><li>new String()：会在堆新建对象</li><li>intern() 方法： String 对象的 intern 方法会得到字符串对象在常量池中对应的版本的引用，如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；</li><li>“”字面量：使用字面量的形式创建字符串，会自动地将字符串放入 String Pool 中</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"Programming"</span>;<span class="comment">//先去常量池取，没有就新建对象放在常量池</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"Programming"</span>);<span class="comment">//两个字符串对象，一个是常量池的"Programming"，一个是用 new 创建在堆上的对象</span></span><br><span class="line">String s3 = <span class="string">"Program"</span>;<span class="comment">//常量池</span></span><br><span class="line">String s4 = <span class="string">"ming"</span>;<span class="comment">//常量池</span></span><br><span class="line">String s5 = <span class="string">"Program"</span> + <span class="string">"ming"</span>;<span class="comment">//常量池</span></span><br><span class="line">String s6 = s3 + s4;<span class="comment">//堆</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s5);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s6.intern());<span class="comment">//true</span></span><br><span class="line">System.out.println(s2 == s2.intern());<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="4-String-常用方法"><a href="#4-String-常用方法" class="headerlink" title="4 String 常用方法"></a>4 String 常用方法</h3><h4 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h4><h5 id="1）使用字符串常量直接初始化"><a href="#1）使用字符串常量直接初始化" class="headerlink" title="1）使用字符串常量直接初始化"></a>1）使用字符串常量直接初始化</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D; &quot;hello!&quot;;</span><br></pre></td></tr></table></figure><h5 id="2）使用构造方法创建并初始化"><a href="#2）使用构造方法创建并初始化" class="headerlink" title="2）使用构造方法创建并初始化"></a>2）使用构造方法创建并初始化</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D; new String(Object);</span><br></pre></td></tr></table></figure><p>初始化源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="comment">// 本质是字符数组常量，所以不可变</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-操作"><a href="#4-2-操作" class="headerlink" title="4.2 操作"></a>4.2 操作</h4><h5 id="1）截取字符串"><a href="#1）截取字符串" class="headerlink" title="1）截取字符串"></a>1）截取字符串</h5><ul><li>单点截取：subString(开始下标)</li><li>双点截取：subString(开始下标，结束下标)</li></ul><h5 id="2）拼接字符串"><a href="#2）拼接字符串" class="headerlink" title="2）拼接字符串"></a>2）拼接字符串</h5><ul><li>+ 号</li><li>join：用一个定界符分割，String.join(“定界符”,“待合并字符串”…)</li></ul><p>字符串的 + 操作其本质是创建了 StringBuilder 对象进行 append 操作，然后将拼接后的 StringBuilder 对象用 toString 方法处理成 String 对象</p><p>一般情况进行字符串拼接用 + 就可以，但是如果是循环拼接，则需要用 StringBuilder 的 append 来实现。</p><p>若不使用 StringBuilder 的 append 方法而使用 + 来进行连接。那么每次在循环体内都将会在 Heap 中创造一个新的 String 对象，造成资源浪费。</p><h5 id="3）获取信息"><a href="#3）获取信息" class="headerlink" title="3）获取信息"></a>3）获取信息</h5><ul><li>下标：indexOf(子字符)，lastIndexOf(子字符)</li><li>字符：charAt(下标)</li><li>字节数组：getBytes()</li><li>字符数组：toCharArray()</li><li>长度：length()</li></ul><h5 id="4）替换字符串"><a href="#4）替换字符串" class="headerlink" title="4）替换字符串"></a>4）替换字符串</h5><ul><li>去掉前后空格：trim()</li><li>子字符串：split(字符串)，StringTokenizer()</li></ul><h5 id="5）判断字符串"><a href="#5）判断字符串" class="headerlink" title="5）判断字符串"></a>5）判断字符串</h5><ul><li>是否相等：.equals()</li><li>不区分大小写：.equalsIgnoreCase()</li><li>是否为空串：.length()==0 或 .equals(“”)</li><li>是否为null：== null</li><li>前缀：startsWith(前缀)</li><li>后缀：endsWith(后缀)</li><li>大小：compareTo()</li></ul><h5 id="6）字符串转换"><a href="#6）字符串转换" class="headerlink" title="6）字符串转换"></a>6）字符串转换</h5><ul><li>大/小写：<ul><li>大写：toLowerCase()</li><li>小写：toUpperCase()</li></ul></li><li>字符串转换为基本类型<ul><li>Long.parseLong(“1231”);</li><li>Double.parseDouble(“0.213”);</li></ul></li><li>基本类型转换为字符串<ul><li>基本数据类型变量 + “”</li><li>String.valueOf(其他类型的参数)；</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 基础设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型</title>
      <link href="/2020/08/15/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/08/15/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>数据类型分为基本类型和对象类型。</p><h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h3><p>Java 中的基本类型有 8 种，其中有 4 种整型、2 种浮点型、char 和 boolean。还有 void 和 reference 类型</p><ol><li>基本类型值存储在内存栈上。</li><li>基本类型所占空间大小固定。</li><li>所有数值类型都有正负号。</li></ol><h4 id="1-1-整型"><a href="#1-1-整型" class="headerlink" title="1.1 整型"></a>1.1 整型</h4><table><thead><tr><th>类型</th><th>包装类</th><th>存储需求</th><th>取值范围</th><th>零值</th><th>备注</th></tr></thead><tbody><tr><td>long</td><td>Long</td><td>8 字节 64 bits</td><td>-2^63 ~ +2^63-1</td><td>0L</td><td>后缀加L或l</td></tr><tr><td>int</td><td>Integer</td><td>4 字节 32 bits</td><td>-2^31 ~ +2^31-1</td><td>0</td><td>最常用，范围超20亿</td></tr><tr><td>short</td><td>Short</td><td>2 字节 16 bits</td><td>-2^15 ~ +2^15-1</td><td>(short)0</td><td>控制占用存储空间的大数组</td></tr><tr><td>byte</td><td>Byte</td><td>1 字节 8 bits</td><td>-2^7 ~ +2^7-1</td><td>(byte)0</td><td>底层文件处理</td></tr></tbody></table><ol><li>十六进制前缀 0x 或0X</li><li>八进制前缀 0</li><li>二进制前缀 0b 或 0B(Java 7 开始)</li><li>数字加下划线更易读，如 1_000_000，编译器会去掉(Java 7 开始)</li><li>没有后缀标识的整数默认为 int 类型</li></ol><h4 id="1-2-浮点"><a href="#1-2-浮点" class="headerlink" title="1.2 浮点"></a>1.2 浮点</h4><table><thead><tr><th>类型</th><th>包装类</th><th>存储需求</th><th>取值范围</th><th>零值</th><th>备注</th></tr></thead><tbody><tr><td>double</td><td>Double</td><td>8 字节 64 bits</td><td>大约-2^1024 ~ -2^-1074 —— 0 —— 2^-1074 ~ 2^1024（有效 15 位）</td><td>0.0d</td><td>后缀 D 或 d，最常用。</td></tr><tr><td>float</td><td>Float</td><td>4 字节 32 bits</td><td>大约-2^128 ~ -2^-149 —— 0 —— 2^-149 ~ 2^128（有效 6~7 位）</td><td>0.0f</td><td>后缀 F 或 f，单精度库或大量数据</td></tr></tbody></table><ol><li>没有后缀F的浮点数默认是 double</li><li>浮点数不能绝对精确，因为二进制种无法精确表示 1/10，不允许误差应使用 BigDecimal 类。</li></ol><p>浮点数的结构与整型不同，指数的底数为 2，尾数表示小数部分</p><table><thead><tr><th>类型</th><th>符号位（S）</th><th>指数位（E）</th><th>尾数位（M）</th></tr></thead><tbody><tr><td>float</td><td>1 bit</td><td>8 bits</td><td>23 bits</td></tr><tr><td>double</td><td>1 bit</td><td>11 bits</td><td>52 bits</td></tr></tbody></table><h4 id="1-3-字符"><a href="#1-3-字符" class="headerlink" title="1.3 字符"></a>1.3 字符</h4><table><thead><tr><th>类型</th><th>包装类</th><th>存储需求</th><th>取值范围</th><th>零值</th><th>备注</th></tr></thead><tbody><tr><td>char</td><td>Character</td><td>2 字节 16 bits</td><td>int0-2^16-1 ,hex’\u0000’~’’\Uffff’</td><td>‘\u0000’</td><td>char 字面量要用单引号括起来。</td></tr></tbody></table><ul><li>转移序列 \u 可以出现在加引号的字符常量或字符串外（其它所有转义序列不可以）</li><li>警告：Unicode 转移序列会在解析代码前得到处理</li><li>警告：当心注释里的 \u，如“\u00A0”换行符，或“c:\user”，语法错误，因为没跟 4 个十六进制数</li><li>解决方案：字符串中用转义符“\”来去除“\u”造成的不必要影响</li></ul><h4 id="1-4-布尔"><a href="#1-4-布尔" class="headerlink" title="1.4 布尔"></a>1.4 布尔</h4><p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。</p><p>JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。</p><p>JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p><p>整型和布尔之间不能转换，不能用 0 当作 false，可以使用条件表达式</p><h4 id="1-5-类型转换"><a href="#1-5-类型转换" class="headerlink" title="1.5 类型转换"></a>1.5 类型转换</h4><p>不要强制转换 boolean 类型，可用条件表达式</p><p>自动类型转换图示：byte -&gt; short(char) -&gt; int -&gt; long -&gt; float -&gt; double ，强制类型与之相反</p><h5 id="1）自动类型转换"><a href="#1）自动类型转换" class="headerlink" title="1）自动类型转换"></a>1）自动类型转换</h5><p>运算或方法调用时，系统会将较小的数据类型自动转换为较大的数据类型</p><ul><li>当使用 +、-、*、/、% 运算符对基本类型进行运算时，转换为较大的数据类型，如最大的小于 int，则转为 int</li></ul><h5 id="2）强制类型转换"><a href="#2）强制类型转换" class="headerlink" title="2）强制类型转换"></a>2）强制类型转换</h5><p>强制类型将较大的数据类型转化为较小的数据类型，可能导致精度损失。</p><ul><li>当使用 +=、-=、*=、/=、%= 运算符对基本类型进行运算时，运算符右边的数值将首先被强制转换成与运算符左边数值相同的类型，然后再执行运算，且运算结果与运算符左边数值类型相同。</li></ul><h3 id="2-包装类型"><a href="#2-包装类型" class="headerlink" title="2. 包装类型"></a>2. 包装类型</h3><ul><li>所有的基本类型都有一个与之对应的类。包装类都是声明为 final的，不可变，不可被继承。</li><li>对象引用存储在内存栈上，而对象本身的值存储在内存堆上。</li><li>对一个对象进行操作时，我们真正操作的是它的句柄。</li><li>自动装箱：基本类型自动转换成包装类，调用了 Integer.valueOf()</li><li>自动拆箱：包装类自动转换为基本类型，调用了 X.intValue()</li></ul><h4 id="2-1-大数值"><a href="#2-1-大数值" class="headerlink" title="2.1 大数值"></a>2.1 大数值</h4><ul><li>BigInteger 支持任意精度的整数。</li><li>BigDecimal 支持任意精度的浮点数字。</li><li>转换方法： valueOf</li><li>运算方法： add, multiply, divide 等</li></ul><h3 id="3-缓存池"><a href="#3-缓存池" class="headerlink" title="3. 缓存池"></a>3. 缓存池</h3><p>基本类型对应的缓冲池如下：</p><ul><li>boolean：true, false</li><li>byte、short、int、long：-128 ~ 127</li><li>char：\u0000 ~ \u007F</li></ul><p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p><h4 id="3-1-IntegerCache"><a href="#3-1-IntegerCache" class="headerlink" title="3.1 IntegerCache"></a>3.1 IntegerCache</h4><p>Integer 缓冲池 IntegerCache， 是静态类，上界可以通过参数调整。</p><p>加载的时候会初始化一个 int 数组，填上 -128 ~ 127 的值。</p><h4 id="3-2-valueOf-方法"><a href="#3-2-valueOf-方法" class="headerlink" title="3.2 valueOf() 方法"></a>3.2 valueOf() 方法</h4><p>valueOf() 方法会使用缓存池中的对象，多次调用会取得同一个对象的引用。</p><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 基础设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>依赖注入</title>
      <link href="/2020/07/13/Spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2020/07/13/Spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> IoC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级装配</title>
      <link href="/2020/07/13/Spring/IoC/%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D/"/>
      <url>/2020/07/13/Spring/IoC/%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="1-环境与-profile"><a href="#1-环境与-profile" class="headerlink" title="1 环境与 profile"></a>1 环境与 profile</h3><h4 id="1-1-配置-profile"><a href="#1-1-配置-profile" class="headerlink" title="1.1 配置 profile"></a>1.1 配置 profile</h4><h5 id="Profile-注解"><a href="#Profile-注解" class="headerlink" title="@Profile 注解"></a>@Profile 注解</h5><p>指定某个 bean 属于哪一个 profile，运行时做出环境决策。</p><p>没有指定 profile 的 bean 始终都会被创建， 与激活哪个 profile 没有关系。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"prod"</span>)</span><br></pre></td></tr></table></figure><h4 id="1-2-激活-profiles"><a href="#1-2-激活-profiles" class="headerlink" title="1.2 激活 profiles"></a>1.2 激活 profiles</h4><p>Spring 提供了两个配置项定义激活哪个 profile：</p><ul><li>spring.profiles.active：优先</li><li>spring.profiles.default：没有 active 则找 default</li></ul><p>如都没有设置，则只会创建没有被 profile 修饰的 bean。</p><h3 id="2-条件化的-bean"><a href="#2-条件化的-bean" class="headerlink" title="2 条件化的 bean"></a>2 条件化的 bean</h3><h4 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h4><p>作用于 @Bean 注解修饰的方法上，通过判断指定的条件是否满足来决定是否创建该 bean。</p><p>传入注解的类一定要实现 Condition 接口，提供 matchs() 方法——如果 matches() 方法返回 true，则被 @Conditional 注解修饰的 bean 就会创建，否则对应的 bean 不会创建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Conditional</span>(MagicExistsCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">MagicBean</span> <span class="title">magicBean</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MagicBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-处理自动装配的歧义"><a href="#3-处理自动装配的歧义" class="headerlink" title="3 处理自动装配的歧义"></a>3 处理自动装配的歧义</h3><h4 id="3-1-Primary"><a href="#3-1-Primary" class="headerlink" title="3.1 @Primary"></a>3.1 @Primary</h4><p>指定优先 bean</p><h4 id="3-2-Qualifier"><a href="#3-2-Qualifier" class="headerlink" title="3.2 @Qualifier"></a>3.2 @Qualifier</h4><p>指定 bean 的 ID</p><p>也可在 bean 和注入的地方注解相同 @Qualifier，或定义自定义 QUALIFIER</p><h3 id="4-bean-的作用域"><a href="#4-bean-的作用域" class="headerlink" title="4 bean 的作用域"></a>4 bean 的作用域</h3><h4 id="4-1-Scope"><a href="#4-1-Scope" class="headerlink" title="4.1 @Scope"></a>4.1 @Scope</h4><p>Spring 中的 bean 默认都是单例，这对可变类型是非线程安全的。如果选择其他的作用域， 要使用 @Scope 注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br></pre></td></tr></table></figure><h4 id="4-2-scoped-代理"><a href="#4-2-scoped-代理" class="headerlink" title="4.2 scoped 代理"></a>4.2 scoped 代理</h4><p>单例 bean 在加载时就会被创建，会话/请求 bean 要创建 request/session 时才会被创建。</p><p>把会话 bean 装配到单例 bean 时，应给单例 bean 装配一个会话 bean 的代理。</p><p>代理类对外暴露的接口和会话 bean 中的一样，当单例 bean 调用对应的接口时，代理采取懒解析策略，并把调用委派给实际的 session-scoped bean。设置 proxyMode 属性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(value=WebApplicationContext.SCOPE_SESSION,</span><br><span class="line">proxyMode=ScopedProxyMode.INTERFACES)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ShoppingCart <span class="title">cart</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="5-运行时值注入"><a href="#5-运行时值注入" class="headerlink" title="5 运行时值注入"></a>5 运行时值注入</h3><p>Spring 提供以下两种方式实现运行时注入：</p><ul><li>属性占位符（ Property placeholder） 。</li><li>Spring 表达式语言（ SpEL） 。</li></ul><h4 id="5-1-Environment"><a href="#5-1-Environment" class="headerlink" title="5.1 Environment"></a>5.1 Environment</h4><p>在 Spring 中解析外部值的最好方法是定义一个配置文件，然后通过 Spring 的 Environment 实例获取配置文件中的配置项的值。属性文件被加载到 Spring 的 Environment 实例中，然后通过 getProperty() 方法解析对应配置项的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/app.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressiveConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">disc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(env.getProperty(<span class="string">"disc.title"</span>),env.getProperty(<span class="string">"disc.artist"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-属性占位符"><a href="#5-2-属性占位符" class="headerlink" title="5.2 属性占位符"></a>5.2 属性占位符</h4><p>将属性定义到外部的属性的文件中， 并使用占位符“${ … }”将其插入到 Spring bean 中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlankDisc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Value(<span class="string">"$&#123;disc.title&#125;"</span>)</span> String title,</span></span><br><span class="line"><span class="function">        @<span class="title">Value</span><span class="params">(<span class="string">"$&#123;disc.artist&#125;"</span>)</span> String artist) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">    <span class="keyword">this</span>.artist = artist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使用占位符的值，需要配置 PropertySourcesPlaceholderConfigurer</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertySourcesPlaceholderConfigurer <span class="title">placeholderConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-SpEL-表达式"><a href="#5-3-SpEL-表达式" class="headerlink" title="5.3 SpEL 表达式"></a>5.3 SpEL 表达式</h4><p>运行时给 bean 的属性或者构造函数参数注入值</p><p>SpEL 表达式被 #{ … } 包围：</p><ul><li>可以通过 bean 的 ID 引用 bean；</li><li>可以调用某个对象的方法或者访问它的属性；</li><li>支持数学、关系和逻辑操作；</li><li>正则表达式匹配；</li><li>支持集合操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> IoC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>依赖注入</title>
      <link href="/2020/07/13/Spring/IoC/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/07/13/Spring/IoC/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>IoC</strong>（Inversion of Control，控制反转 ）：控制权由应用代码中转到了外部容器，控制权的转移，所谓控制反转。</p><p><strong>依赖注入</strong>：依赖注入是控制反转(IOC)的一个层面，用创建对象而只需要描述如何创建它们。</p><p>IoC 负责装配 Bean，即创建应用对象之间协作关系，是<strong>依赖注入</strong>（DI，Dependency injection）的本质。</p><p>装配方式优先级：自动装配 &gt; Java 配置文件 &gt; XML 配置文件</p><h3 id="1-自动装配"><a href="#1-自动装配" class="headerlink" title="1 自动装配"></a>1 自动装配</h3><p>Spring 容器可以自动配置相互协作 beans 之间的关联关系。这意味着 Spring 可以自动配置一个 bean 和其他协作 bean 之间的关系。</p><p>Spring 从两个角度来实现自动装配</p><h4 id="1-1-组件扫描"><a href="#1-1-组件扫描" class="headerlink" title="1.1 组件扫描"></a>1.1 组件扫描</h4><p>Spring 自动发现 ApplicationContext 中所创建的 bean</p><h5 id="1）-Component"><a href="#1）-Component" class="headerlink" title="1）@Component"></a>1）@Component</h5><p>让 Spring 为类自动创建 bean，默认 ID 是类名称的首字母小写。也可给注解传入指定的参数指定名字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"lonelyHeartsClub"</span>)</span><br></pre></td></tr></table></figure><p>还有 @Repository、@Service、@Controller 等</p><h5 id="2）-ComponentScan"><a href="#2）-ComponentScan" class="headerlink" title="2）@ComponentScan"></a>2）@ComponentScan</h5><p>开启 Component 扫描，默认设置该目录以及子目录下所有被 @Component 注解修饰的类。也可指定扫描的包。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"soundsystem"</span>)<span class="comment">//扫描指定包  </span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"soundsystem"</span>)</span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"soundsystem"</span>, <span class="string">"video"</span>&#125;)</span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackageClasses = &#123;CDPlayer<span class="class">.<span class="keyword">class</span>, <span class="title">DVDPlayer</span>.<span class="title">class</span>&#125;)//扫描指定类所属的包</span></span><br></pre></td></tr></table></figure><h4 id="1-2-自动装配"><a href="#1-2-自动装配" class="headerlink" title="1.2 自动装配"></a>1.2 自动装配</h4><p>Spring 自动满足 bean 之间的依赖</p><p><strong>@Autowired</strong>：声明自动装配，可用在构造器、方法、成员变量上。</p><p>只要对应类型的 bean 有且只有一个，则会自动装配。推荐通过构造器注入以避免 NullPointerException 问题。</p><h5 id="1）注入到-Java-集合类"><a href="#1）注入到-Java-集合类" class="headerlink" title="1）注入到 Java 集合类"></a>1）注入到 Java 集合类</h5><p>@Autowired 可直接将接口的实现 Bean 注入到如下几种类型的集合中</p><ul><li>list：用来注入一系列的值，允许有相同的值。</li><li>set：用来注入一些列的值，不允许有相同的值。</li><li>map：用来注入一组”键-值”对，key 必须为 String。</li><li>props：也可以用来注入一组”键-值”对，这里的键、值都字符串类型。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> List&lt;BeanInterface&gt; list;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,Interface&gt; map;</span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">table-info.list[0]=list_value1</span><br><span class="line">table-info.list[1]=list_value2</span><br><span class="line">table-info.map.map_key1=map_value1</span><br><span class="line">table-info.map.map_key2=map_value2</span><br><span class="line">table-info.maplist.map_key1[0]=maplist_value1</span><br><span class="line">table-info.maplist.map_key1[1]=maplist_value2</span><br><span class="line">table-info.maplist.map_key2[0]=maplist_value3</span><br></pre></td></tr></table></figure><p>TableConfig</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"table-info"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; maplist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）允许-null-值"><a href="#2）允许-null-值" class="headerlink" title="2）允许 null 值"></a>2）允许 null 值</h5><p>默认要求依赖对象必须存在，如允许 null 值，可设置 @Autowired(required=false)</p><p>还有 @Resource 等</p><h5 id="3）推荐对构造函数进行注释"><a href="#3）推荐对构造函数进行注释" class="headerlink" title="3）推荐对构造函数进行注释"></a>3）推荐对构造函数进行注释</h5><p>由</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EnterpriseDbService service;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EnterpriseDbService service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnterpriseDbController</span><span class="params">(EnterpriseDbService service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.service = service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以明确成员变量的加载顺序</p><h3 id="2-Java-配置文件"><a href="#2-Java-配置文件" class="headerlink" title="2 Java 配置文件"></a>2 Java 配置文件</h3><p>想要装配第三方库中的组件时，因为没办法在它的类上添加 @Component 和 @Autowired 注解，不能自动化配置，必须要采用显式装配。</p><h4 id="2-1-创建配置类"><a href="#2-1-创建配置类" class="headerlink" title="2.1 创建配置类"></a>2.1 创建配置类</h4><p>@Configuration：表明是配置类</p><h4 id="2-2-声明-bean"><a href="#2-2-声明-bean" class="headerlink" title="2.2 声明 bean"></a>2.2 声明 bean</h4><p><strong>@Bean</strong>：声明 bean，需编写方法创建所需类型实例， 注解 @Bean。默认 ID 是方法名，也可通过 name 属性指定名字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"lonelyHeartsClub"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-装配-bean"><a href="#2-3-装配-bean" class="headerlink" title="2.3 装配 bean"></a>2.3 装配 bean</h4><p>在 JavaConfig 中装配 bean 的最简单方式就是引用创建 bean 的方法。</p><p>默认情况下，Spring 中所有的 bean 都是<strong>单例模式</strong>，Spring 会拦截 @Bean 注解的函数调用，并返回之前创建好的 bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CDPlayer <span class="title">cdPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(sgtPeppers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-XML-配置文件"><a href="#3-XML-配置文件" class="headerlink" title="3 XML 配置文件"></a>3 XML 配置文件</h3><p>维护已有的 XML 配置， 在完成新的 Spring 工作时， 使用自动化配置和 JavaConfig。</p><p>创建一个 XML 文件， 并且以 元素为根。使用 元素声明 bean 并指定 class 属性。 元素注入构造器</p><p>可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用 setter 方法实现可选的依赖关系。</p><h4 id="3-1-set-注入"><a href="#3-1-set-注入" class="headerlink" title="3.1 set 注入"></a>3.1 set 注入</h4><p>首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用 bean 中的setter 方法完成 Setter 方法依赖注入。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> OrderServiceImp orderService;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderService</span><span class="params">(OrderServiceImp orderService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 配置 XML 文件：其中配置声明 OrderAction 类存在属性 orderService。程式运行时候，会将已经实例化的 orderService 对象调用 setOrderService 方式注入。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderAction"</span> <span class="attr">class</span>=<span class="string">"com.pec.action.OrderAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"orderService"</span> <span class="attr">ref</span>=<span class="string">"orderService"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"com.pec.service.imp.OrderServiceImp"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-构造器注入"><a href="#3-2-构造器注入" class="headerlink" title="3.2 构造器注入"></a>3.2 构造器注入</h4><p>构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> OrderServiceImp orderService;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderAction</span><span class="params">(OrderServiceImp orderService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 配置 XML 文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderAction"</span> <span class="attr">class</span>=<span class="string">"com.pec.action.OrderAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"orderService"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"com.pec.service.imp.OrderServiceImp"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-多种配置方法混用"><a href="#4-多种配置方法混用" class="headerlink" title="4 多种配置方法混用"></a>4 多种配置方法混用</h3><p>通常的做法是：无论使用 JavaConfig 或者 XML 装配，都要创建一个 root configuration；并且在这个配置文件中开启自动扫描机制</p><h4 id="4-1-JavaConfig-中引用"><a href="#4-1-JavaConfig-中引用" class="headerlink" title="4.1 JavaConfig 中引用"></a>4.1 JavaConfig 中引用</h4><ul><li>@Import：导入其他的 JavaConfig</li><li>@ImportResource：导入 XML 配置文件</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;CDPlayerConfig<span class="class">.<span class="keyword">class</span>, <span class="title">CDConfig</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line">@ImportResource("classpath: cd-config.xml")</span><br></pre></td></tr></table></figure><h4 id="4-2-XML-配置中引用"><a href="#4-2-XML-配置中引用" class="headerlink" title="4.2 XML 配置中引用"></a>4.2 XML 配置中引用</h4><p>标签引入其他的 XML 配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:/spring/calculate-web.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>标签导入 Java 配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"soundsystem.CDConfig"</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> IoC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC容器和Bean</title>
      <link href="/2020/07/11/Spring/Core/IOC%E5%AE%B9%E5%99%A8/"/>
      <url>/2020/07/11/Spring/Core/IOC%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-IOC-容器"><a href="#1-IOC-容器" class="headerlink" title="1 IOC 容器"></a>1 IOC 容器</h3><p>概念 ： IOC 容器（container）是 Spring 框架的核心，它管理着 Spring 应用中 bean 的创建、 配置和管理，负责对象的整个生命周期。</p><h4 id="1-1-容器实现"><a href="#1-1-容器实现" class="headerlink" title="1.1 容器实现"></a>1.1 容器实现</h4><h5 id="1）BeanFactory"><a href="#1）BeanFactory" class="headerlink" title="1）BeanFactory"></a>1）BeanFactory</h5><p>最简单的容器，提供基本的 DI 支持。使用控制反转将应用的配置和依赖与实际的应用代码分离开来。</p><p>第一次访问某一 Bean 时才实例化它。</p><h5 id="2）ApplicationContext"><a href="#2）ApplicationContext" class="headerlink" title="2）ApplicationContext"></a>2）ApplicationContext</h5><p>基于 BeanFactory 构建， 并提供应用框架级别的服务。</p><p>初始化容器时就实例化所有单例的 Bean。</p><p>有多种 ApplicationContext 的实现， 每一种都提供了配置 Spring 的不同方式。</p><h5 id="3）Bean-Factory-和-ApplicationContext-的区别"><a href="#3）Bean-Factory-和-ApplicationContext-的区别" class="headerlink" title="3）Bean Factory 和 ApplicationContext 的区别"></a>3）Bean Factory 和 ApplicationContext 的区别</h5><p>ApplicationContext 提供了一种解决文档信息的方法，一种加载文件资源的方式(如图片)，他们可以向监听他们的beans发送消息。</p><p>另外，容器或者容器中 beans 的操作，这些必须以 Bean Factory 的编程方式处理的操作可以在 ApplicationContext 中以声明的方式处理。</p><p><strong>这两者的继承关系如下：</strong></p><p><img src="https://imine141.github.io/images/ioc%E7%BB%A7%E6%89%BF%E5%9B%BE2.png" alt=""></p><h4 id="1-2-getBean"><a href="#1-2-getBean" class="headerlink" title="1.2 getBean()"></a>1.2 getBean()</h4><p>通过容器 getBean() 方法从容器获取指定 bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">xxx xxxobj = applicationContext.getBean(xxx<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="2-Spring-Bean"><a href="#2-Spring-Bean" class="headerlink" title="2 Spring Bean"></a>2 Spring Bean</h3><h3 id="2-1-Spring-Bean-定义"><a href="#2-1-Spring-Bean-定义" class="headerlink" title="2.1 Spring Bean 定义"></a>2.1 Spring Bean 定义</h3><p><strong>什么是Bean？</strong></p><p>由于Java语言欠缺属性、事件、多重继承功能，如果在Java程序中实现一些面向对象编程的常见需求，只能手写大量胶水代码。Bean正是编写这套胶水代码的惯用模式或约定。这些约定包括getXxx、setXxx、isXxx、addXxxListener、XxxEvent等。简而言之，Bean就是一个具有规范的Java类</p><p>在spring中。这些bean对象由 Spring IOC 容器实例化、组装、管理。</p><p>Spring Bean 中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。</p><h4 id="2-2-定义-bean-的作用域"><a href="#2-2-定义-bean-的作用域" class="headerlink" title="2.2 定义 bean 的作用域"></a>2.2 定义 bean 的作用域</h4><p>在 Spring 中创建一个 bean 的时候，我们可以通过“scope”属性声明它的作用域。</p><p>Spring 中的 bean 默认都是单例（singleton）的，这对可变类型是非线程安全的。</p><p>Spring 定义了几种 bean 的作用域：</p><ul><li>Singleton：单例。在 Spring IOC 容器中仅存在一个 Bean 实例，Bean 以单实例的方式存在。</li><li>Prototype：原型。每次被装配时，都会创建一个新的实例。</li><li>Request：在 WebApplicationContext 中，在每次 http 请求中创建一个 bean 的实例。</li><li>Session：在 WebApplicationContext 中，在每次 HTTP Session 过程中只创建一个 bean 的实例；</li><li>GlobalSession：在 WebApplicationContext 中，在同一个全局 HTTP Session 只创建一个 Bean 的实例</li></ul><h3 id="3-Bean-的生命周期"><a href="#3-Bean-的生命周期" class="headerlink" title="3 Bean 的生命周期"></a>3 Bean 的生命周期</h3><p>对于普通的 Java 对象，当 new 的时候创建对象，当它没有任何引用的时候被垃圾回收机制回收。而由 Spring IoC 容器托管的对象，它们的生命周期完全由容器控制。</p><p>Spring 只管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p><p><img src="https://imine141.github.io/images/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" alt="bean的生命周期"></p><p>BeanFactory 负责 bean 创建的最初四步，然后移交给 ApplicationContext 做后续创建过程</p><h4 id="3-1-实例化"><a href="#3-1-实例化" class="headerlink" title="3.1 实例化"></a>3.1 实例化</h4><p>Spring 容器（从 XML 文件、注解、Java 配置文件）读取 bean 的定义并实例化 bean。</p><ul><li>对于 BeanFactory 容器：当客户向容器请求一个尚未初始化的 bean 时，或初始化 bean 的时候需要注入另一个尚未初始化的依赖时，容器就会调用 createBean 进行实例化。</li><li>对于 ApplicationContext 容器：当容器启动结束后，便实例化所有的 bean。</li></ul><p>容器通过获取 BeanDefinition 对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。</p><p>实例化对象被包装在 BeanWrapper 对象中，BeanWrapper 提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</p><h4 id="3-2-属性填充（依赖注入）"><a href="#3-2-属性填充（依赖注入）" class="headerlink" title="3.2 属性填充（依赖注入）"></a>3.2 属性填充（依赖注入）</h4><p>实例化后的对象被封装在 BeanWrapper 对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。</p><p>紧接着，Spring 根据 BeanDefinition 中的信息进行依赖注入。</p><p>并且通过 BeanWrapper 提供的设置属性的接口完成依赖注入。</p><h4 id="3-3-注入-Aware-接口"><a href="#3-3-注入-Aware-接口" class="headerlink" title="3.3 注入 Aware 接口"></a>3.3 注入 Aware 接口</h4><p>紧接着，Spring 会检测该对象是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 bean。</p><ul><li>如果该 Bean 实现了 BeanNameAware 接口，Spring 将 bean 的 id 传递给 setBeanName() 方法。</li><li>如果该 Bean 实现了 BeanFactoryAware 接口，Spring 将 BeanFactory 传递给 setBeanFactory() 方法。</li><li>如果该 Bean 实现了 ApplicationContextAware 接口，Spring 将 ApplicationContext 传递给 setApplicationContext() 方法。</li></ul><p>xxxAware 接口可以用于在初始化 bean 时获得 Spring 中的一些对象，如获取 Spring 上下文等。</p><h4 id="3-4-BeanPostProcessor"><a href="#3-4-BeanPostProcessor" class="headerlink" title="3.4 BeanPostProcessor"></a>3.4 BeanPostProcessor</h4><p>当经过上述几个步骤后，bean 对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过 BeanPostProcessor 接口实现。</p><p>该接口提供了两个函数：</p><ul><li>postProcessBeforeInitialzation( Object bean, String beanName )<ul><li>当前正在初始化的 bean 对象会被传递进来，我们就可以对这个 bean 作任何处理。</li><li>这个函数会先于 InitialzationBean 执行，因此称为“前置处理”。</li><li>所有 Aware 接口的注入就是在这一步完成的。</li></ul></li><li>postProcessAfterInitialzation( Object bean, String beanName )<ul><li>当前正在初始化的 bean 对象会被传递进来，我们就可以对这个 bean 作任何处理。</li><li>这个函数会在 InitialzationBean 完成后执行，因此称为“后置处理”。</li></ul></li></ul><h4 id="3-5-自定义初始化"><a href="#3-5-自定义初始化" class="headerlink" title="3.5 自定义初始化"></a>3.5 自定义初始化</h4><p>当 BeanPostProcessor 的“前置处理”完成后就会进入本阶段。</p><h5 id="1）InitializingBean-接口"><a href="#1）InitializingBean-接口" class="headerlink" title="1）InitializingBean 接口"></a>1）InitializingBean 接口</h5><p>InitializingBean 接口只有一个函数：afterPropertiesSet()</p><p>这一阶段也可以在 bean 正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前 bean 对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。</p><p>若要使用它，我们需要让 bean 实现该接口，并把要增加的逻辑写在该函数中。</p><p>Spring 会在前置处理完成后检测当前 bean 是否实现了 InitializingBean 接口，并执行 afterPropertiesSet 函数。</p><h5 id="2）init-method-属性"><a href="#2）init-method-属性" class="headerlink" title="2）init-method 属性"></a>2）init-method 属性</h5><p>Spring 为了降低对客户代码的侵入性，给 bean 的配置提供了 init-method 属性，该属性指定了在这一阶段需要执行的函数名。</p><p>Spring 便会在初始化阶段执行我们设置的函数。init-method 本质上仍然使用了 InitializingBean 接口。</p><h5 id="3）-PostConstruct-注解"><a href="#3）-PostConstruct-注解" class="headerlink" title="3）@PostConstruct 注解"></a>3）@PostConstruct 注解</h5><p>对象构建之后调用</p><h4 id="3-6-自定义销毁"><a href="#3-6-自定义销毁" class="headerlink" title="3.6 自定义销毁"></a>3.6 自定义销毁</h4><p>当 BeanPostProcessor 的“后置处理”完成后就会进入本阶段。</p><h5 id="1）DisposableBean-接口"><a href="#1）DisposableBean-接口" class="headerlink" title="1）DisposableBean 接口"></a>1）DisposableBean 接口</h5><p>如果该 bean 实现了 DisposableBean，调用 destroy() 方法。</p><h5 id="2）destroy-method-属性"><a href="#2）destroy-method-属性" class="headerlink" title="2）destroy-method 属性"></a>2）destroy-method 属性</h5><p>和 init-method 一样，通过给 destroy-method 指定函数，就可以在 bean 销毁前执行指定的逻辑。</p><h5 id="3）-PreDestroy-注解"><a href="#3）-PreDestroy-注解" class="headerlink" title="3）@PreDestroy 注解"></a>3）@PreDestroy 注解</h5><p>对象移除之前调用</p><p><strong>如果想从源码的角度再深入了解IOC这块，推荐看这篇文章</strong></p><p> <a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">https://javadoop.com/post/spring-ioc</a> </p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring基础</title>
      <link href="/2020/07/10/Spring/Core/spring%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/07/10/Spring/Core/spring%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Spring 是一个开源的 Java EE 开发框架。Spring 框架的核心功能可以应用在任何 Java 应用程序中，但对 Java EE 平台上的 Web 应用程序有更好的扩展性。Spring 框架的目标是使得 Java EE 应用程序的开发更加简捷，通过使用 POJO 为基础的编程模型促进良好的编程风格。</p><h3 id="1-Spring-基本理念"><a href="#1-Spring-基本理念" class="headerlink" title="1 Spring 基本理念"></a>1 Spring 基本理念</h3><p>简化 Java 开发</p><ul><li>轻量级：基础版本的 Spring 框架大约只有 2 MB。</li><li>容器：Spring 包含并管理应用程序对象的配置及生命周期。</li><li>控制反转(IOC)：松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。</li><li>面向切面编程(AOP)： 把应用的业务逻辑与系统的服务分离开来。消除样板式代码.</li></ul><h3 id="2-Spring-基本原理"><a href="#2-Spring-基本原理" class="headerlink" title="2 Spring 基本原理"></a>2 Spring 基本原理</h3><ol><li>启动项目后，按照配置找到要 scan 的包（自动装配）</li><li>解析包里面的所有类，找到所有含有 @bean，@service 等注解的类，利用反射解析，封装成各种信息类放到容器（map 实现）里。</li><li>需要 bean 时，从容器里找。找到则通过构造器 new 出来（控制反转），没找到则抛出异常</li><li>如果类中有需要注入的，仍从 container 寻找、解析类，new 出对象，用 setter 注入（依赖注入）。</li><li>嵌套 bean 用了递归，container 会放到 servletcontext 里，每次 request 从 servletcontext 找 container。</li><li>如果 bean 的 scope 是 singleton，会重用，将这个 bean 放到一个 map 里，每次用都先从这个 map 里面找。</li><li>如果 scope 是 session，则该 bean 会放到 session 里面。</li></ol><h3 id="3-Spring-模块"><a href="#3-Spring-模块" class="headerlink" title="3 Spring 模块"></a>3 Spring 模块</h3><p>Spring 4.0 有 20 个模块，这些模块依据其所属的功能可以划分为 6 类不同的功能</p><p><img src="https://imine141.github.io/images/1545011849499.png" alt=""></p><h4 id="3-1-Spring-核心容器"><a href="#3-1-Spring-核心容器" class="headerlink" title="3.1 Spring 核心容器"></a>3.1 Spring 核心容器</h4><p>最核心的部分。除了 BeanFactory 和 ApplicationContext，还提供 E-mail、 JNDI 访问、 EJB 集成和调度等服务。所有的 Spring 模块都构建于核心容器之上</p><h4 id="3-2-面向切面编程"><a href="#3-2-面向切面编程" class="headerlink" title="3.2 面向切面编程"></a>3.2 面向切面编程</h4><p>开发切面的基础。借助于 AOP，可以将遍布系统的关注点（例如事务和安全）从它们所应用的对象中解耦出来。</p><h4 id="3-3-数据访问与集成"><a href="#3-3-数据访问与集成" class="headerlink" title="3.3 数据访问与集成"></a>3.3 数据访问与集成</h4><p>JDBC 和 data-access object 模块封装了样板式代码和异常。</p><p>集成了许多流行的 ORM。支持事务管理。</p><h5 id="1）JDBC-和-DAO"><a href="#1）JDBC-和-DAO" class="headerlink" title="1）JDBC 和 DAO"></a>1）JDBC 和 DAO</h5><p>JDBC 和 DAO（data-access object）模块封装了样板式代码和异常，保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。</p><p>它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用 Spring 的 AOP 模块为 Spring 应用程序中的对象提供事务管理服务。</p><h5 id="2）ORM"><a href="#2）ORM" class="headerlink" title="2）ORM"></a>2）ORM</h5><p>Spring 通过提供对象/关系映射集成（ORM）模块在 JDBC 的基础上支持对象关系映射工具。</p><p>这样的支持使得 Spring 可以集成主流的 ORM 框架，包括 Hibernate, JDO, 及 iBATIS SQL Maps。Spring 的事务管理可以同时支持以上某种框架和 JDBC。</p><h4 id="3-4-Web-与远程调用"><a href="#3-4-Web-与远程调用" class="headerlink" title="3.4 Web 与远程调用"></a>3.4 Web 与远程调用</h4><p>Spring 的 web 模块建立在应用上下文(application context)模块之上，提供了一个适合基于 web 应用程序的上下文环境。该模块还支持了几个面向 web 的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。</p><h5 id="1）Spring-MVC"><a href="#1）Spring-MVC" class="headerlink" title="1）Spring MVC"></a>1）Spring MVC</h5><p>Spring 可以很轻松的同其他 MVC 框架结合，但 Spring 的 MVC 是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。通过 DispatcherServlet, ModelAndView 和 View Resolver，开发 web 应用变得很容易。</p><h5 id="2）HTTP-invoker"><a href="#2）HTTP-invoker" class="headerlink" title="2）HTTP invoker"></a>2）HTTP invoker</h5><p>自带远程调用框架。提供了暴露和使用 REST API 的良好支持。还能集成多种流行远程调用框架。</p><h4 id="3-5-Instrumentation"><a href="#3-5-Instrumentation" class="headerlink" title="3.5 Instrumentation"></a>3.5 Instrumentation</h4><p>提供为 JVM 添加代理的功能。为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文件，就像这些文件是被类加载器加载的一样。</p><h4 id="3-6-测试"><a href="#3-6-测试" class="headerlink" title="3.6 测试"></a>3.6 测试</h4><p>可以与常用的 JUNIT、Mockito、Spock 等测试框架整合使用。</p><p>为使用 JNDI、 Servlet 和 Portlet 编写单元测试提供了一系列的 mock 对象实现。加载 Spring 应用上下文中的 bean 集合以及与 Spring 上下文中的 bean 进行交互提供了支持。</p><h3 id="4-Spring-社区经典项目"><a href="#4-Spring-社区经典项目" class="headerlink" title="4 Spring 社区经典项目"></a>4 Spring 社区经典项目</h3><h4 id="4-1-Spring-Security"><a href="#4-1-Spring-Security" class="headerlink" title="4.1 Spring Security"></a>4.1 Spring Security</h4><p>安全对于许多应用都是一个非常关键的切面。 利用 Spring AOP， 为 Spring 应用提供了声明式的安全机制。</p><h4 id="4-2-Spring-Data"><a href="#4-2-Spring-Data" class="headerlink" title="4.2 Spring Data"></a>4.2 Spring Data</h4><p>使得在 Spring 中使用任何数据库都变得非常容易。 不管使用文档数据库， 还是关系型数据库，Spring Data 都为持久化提供了一种简单的编程模型。包括为多种数据库类型提供了一种自动化的 Repository 机制。</p><h4 id="4-3-Spring-Boot"><a href="#4-3-Spring-Boot" class="headerlink" title="4.3 Spring Boot"></a>4.3 Spring Boot</h4><p>Spring Boot 主要是为了解决使用 Spring 框架需要进行大量的配置太麻烦的问题，所以它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p><p>Spring Boot 大量依赖于自动配置（auto-configuration）技术，它能够消除大部分 Spring 配置。它还提供了多个 Starter 项目，降低了项目搭建的复杂度。同时它集成了大量常用的第三方库配置（例如Jackson, JDBC, Mongo, Redis, Mail等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
