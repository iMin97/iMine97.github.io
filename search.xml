<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>堆</title>
      <link href="/2020/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
      <url>/2020/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>堆(Heap)</strong>是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵<a href="https://baike.baidu.com/item/完全二叉树/7773232" target="_blank" rel="noopener">完全二叉树</a>的数组对象。</p><h2 id="1、二叉堆"><a href="#1、二叉堆" class="headerlink" title="1、二叉堆"></a>1、二叉堆</h2><p>二叉堆是完全二元树或者是近似完全二元树，按照数据的排列方式可以分为两种：最大堆和最小堆。</p><p>二叉堆一般都通过”数组”来实现</p><h2 id="2、左倾堆"><a href="#2、左倾堆" class="headerlink" title="2、左倾堆"></a>2、左倾堆</h2><p>左倾堆(leftist tree 或 leftist heap)，又被成为左偏树、左偏堆，最左堆等。</p><p>它和二叉堆一样，都是优先队列实现方式。可以高效解决”对两个优先队列进行合并”的问题。</p><p><img src="https://imine141.github.io/images/1559037013198.png" alt="img"></p><p>上图是一颗左倾树，它的节点除了和二叉树的节点一样具有左右子树指针外，还有两个属性：键值和零距离。</p><ul><li>键值：作用是来比较节点的大小，从而对节点进行排序。</li><li>零距离：是从一个节点到一个”最近的不满节点”的路径长度。不满节点是指该该节点的左右孩子至少有有一个为NULL。叶节点的NPL为0，NULL节点的NPL为-1。</li></ul><p>左倾堆有以下几个基本性质：</p><ul><li>节点的键值小于或等于它的左右子节点的键值。</li><li>节点的左孩子的NPL &gt;= 右孩子的NPL。</li><li>节点的NPL = 它的右孩子的NPL + 1。</li></ul><p>合并两个左倾堆的基本思想如下：</p><ol><li>如果一个空左倾堆与一个非空左倾堆合并，返回非空左倾堆。</li><li>如果两个左倾堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。</li><li>如果新堆的右孩子的NPL &gt; 左孩子的NPL，则交换左右孩子。</li><li>设置新堆的根节点的NPL = 右子堆NPL + 1</li></ol><h2 id="3、斜堆"><a href="#3、斜堆" class="headerlink" title="3、斜堆"></a>3、斜堆</h2><p>斜堆也叫自适应堆，它是左倾堆的一个变种。和左倾堆一样，它通常也用于实现优先队列；作为一种自适应的左倾堆，它的合并操作的时间复杂度也是O(log n)。</p><p>它与左倾堆的差别是：</p><ol><li>斜堆的节点没有”零距离”这个属性，而左倾堆则有。</li><li>斜堆的合并操作和左倾堆的合并操作算法不同。</li></ol><p>斜堆的合并操作</p><ol><li>如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。</li><li>如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。</li><li>合并后，交换新堆根节点的左孩子和右孩子。</li></ol><p>第 3 步是斜堆和左倾堆的合并操作差别的关键所在，如果是左倾堆，则合并后要比较左右孩子的零距离大小，若右孩子的零距离 &gt; 左孩子的零距离，则交换左右孩子；最后，在设置根的零距离。</p><h2 id="4、二项堆"><a href="#4、二项堆" class="headerlink" title="4、二项堆"></a>4、二项堆</h2><p>二项堆是二项树的集合。在了解二项堆之前，先对二项树进行介绍。</p><h3 id="1）二项树"><a href="#1）二项树" class="headerlink" title="1）二项树"></a>1）二项树</h3><p>二项树是一种递归定义的有序树。它的递归定义如下：</p><ol><li>二项树B0只有一个结点；</li><li>二项树Bk由两棵二项树B(k-1)组成的，其中一棵树是另一棵树根的最左孩子。</li></ol><p><img src="https://imine141.github.io/images/1559037015017.png" alt="img"></p><h3 id="2）二项堆"><a href="#2）二项堆" class="headerlink" title="2）二项堆"></a>2）二项堆</h3><p>二项堆和之前所讲的堆(二叉堆、左倾堆、斜堆)一样，也是用于实现优先队列的。二项堆是指满足以下性质的二项树的集合：</p><ol><li>每棵二项树都满足最小堆性质。即，父节点的关键字 &lt;= 它的孩子的关键字。</li><li>不能有两棵或以上的二项树具有相同的度数(包括度数为0)。换句话说，具有度数k的二项树有0个或1个。</li></ol><p><img src="https://imine141.github.io/images/1559037015069.png" alt="img"></p><h2 id="5、斐波那契堆"><a href="#5、斐波那契堆" class="headerlink" title="5、斐波那契堆"></a>5、斐波那契堆</h2><p>斐波那契堆(Fibonacci heap)是一种可合并堆，可用于实现合并优先队列。它比二项堆具有更好的平摊分析性能，它的合并操作的时间复杂度是O(1)。</p><p>与二项堆一样，它也是由一组堆最小有序树组成，并且是一种可合并堆。</p><p>与二项堆不同的是，斐波那契堆中的树不一定是二项树；而且二项堆中的树是有序排列的，但是斐波那契堆中的树都是有根而无序的。</p><p><img src="https://imine141.github.io/images/1559037015086.png" alt="img"></p><h2 id="6、索引堆"><a href="#6、索引堆" class="headerlink" title="6、索引堆"></a>6、索引堆</h2><p>索引堆是对堆进行了优化。</p><p>索引堆使用了一个新的int类型的数组，用于存放索引信息。</p><p>索引堆的交换操作交换的是元素的索引，而不是直接交换元素。</p><h2 id="7、Treap-树堆"><a href="#7、Treap-树堆" class="headerlink" title="7、Treap 树堆"></a>7、Treap 树堆</h2><p>一棵treap是一棵修改了结点顺序的二叉查找树，如图，显示一个例子，通常树内的每个结点x都有一个关键字值key[x]，另外，还要为结点分配priority[x]，它是一个独立选取的随机数。</p><p><img src="https://imine141.github.io/images/1559037015141.png" alt="img"></p><p>假设所有的优先级是不同的，所有的关键字也是不同的。treap的结点排列成让关键字遵循二叉查找树性质，并且优先级遵循最小堆顺序性质：</p><ol><li>如果v是u的左孩子，则key[v] &lt; key[u].</li><li>如果v是u的右孩子，则key[v] &gt; key[u].</li><li>如果v是u的孩子，则priority[u] &gt; priority[u].</li></ol><p>这两个性质的结合就是为什么这种树被称为“treap”的原因，因为它同时具有二叉查找树和堆的特征。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2020/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
      <url>/2020/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、图的基本概念"><a href="#一、图的基本概念" class="headerlink" title="一、图的基本概念"></a>一、图的基本概念</h2><p>图：由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G(V,E)，其中，G 表示一个图，V 是图 G 中顶点的集合。E 是图 G 中边的集合。</p><h3 id="1、各种图定义"><a href="#1、各种图定义" class="headerlink" title="1、各种图定义"></a>1、各种图定义</h3><ul><li><strong>无向边</strong>：若顶点 <code>V_i</code> 到 <code>V_j</code>，之间的边没有方向，则称这条边为无向边(Edge)。<ul><li>用无序偶对 (<code>V_i</code>，<code>V_j</code>) 来表示。</li></ul></li><li><strong>有向边</strong>：若从顶点 <code>V_i</code> 到 <code>V_j</code>的边有方向，则称这条边为有向边，也称为弧（Arc）。<ul><li>用有序偶&lt;<code>V_i</code>，<code>V_j</code>&gt;来表示 . <code>V_i</code>称为弧尾，<code>V_j</code>称为弧头。</li></ul></li><li><strong>无向图</strong>：如果图中任意两个顶点之间的边都是无向边，则称该图为无向图(Undirected graphs)。</li><li><strong>有向图</strong>：如果图中任意两个顶点之间的边都是有向边，则称该图为有向图(Directed graphs)。</li><li><strong>无向完全图</strong>：在无向图中，如果任意两个顶点之间都存在边，则称该因为无向完全图。<ul><li>含有 n 个顶点的无向完全图有  n(n-1)/2  条边。</li></ul></li><li><strong>有向完全图</strong>：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。<ul><li>含有 n 个顶点的有向完全图有 <code>n*(n-1)</code> 条边</li></ul></li><li><strong>权</strong>：与图的边或弧相关的数叫做权(Weight)</li><li><strong>网</strong>：带权的图通常称为网 (Network) 。</li><li><strong>简单图</strong>：在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。</li><li>有很少条边或弧的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong>。稀疏、稠密是相对的。</li><li><strong>子图</strong>：假设有两个图 G= (V,{E}) 和 G’= (V’,{E’}) ，如果 <code>V&#39;为 V的子图</code> 且 <code>E&#39;为 E的子图</code>，则称 G’ 为 G 的子图。</li></ul><h3 id="2、图的顶点与边间关系"><a href="#2、图的顶点与边间关系" class="headerlink" title="2、图的顶点与边间关系"></a>2、图的顶点与边间关系</h3><ul><li><strong>邻接点</strong>：无向图中，顶点之间如有边相连，则互为邻接点</li><li><strong>顶点的度</strong>：记为TD(v)<ul><li>无向图中，和顶点相关联的边的数目，就是顶点的度</li><li>有向图中，TD(v) = ID(v) + OD(v)<ul><li><strong>入度</strong>：有向图中，以顶点为头的弧的数目，记为ID(v)</li><li><strong>出度</strong>：有向图中，以顶点为尾的弧的数目，记为OD(v)</li></ul></li></ul></li><li><strong>路径</strong>：<ul><li>无向图中，顶点到顶点的路径是一个顶点序列</li><li>有向图中，路径也是有向的</li><li><strong>路径的长度</strong>：是路径上的边或弧的数目。</li></ul></li><li><strong>回路或环</strong>：第一个顶点到最后一个顶点相同的路径称为回路或环</li><li><strong>简单路径</strong>：序列中顶点不重复出现的路径称为简单路径</li><li><strong>简单回路</strong>：除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。</li></ul><h3 id="3、连通图相关术语"><a href="#3、连通图相关术语" class="headerlink" title="3、连通图相关术语"></a>3、连通图相关术语</h3><ul><li><strong>连通</strong>：无向图中，如果顶点间有路径，则称为连通的</li><li><strong>连通图</strong>：无向图中，如果图中任意两个顶点都是连通的，则为连通图</li><li><strong>强连通图</strong>：有向图中，每一对顶点之间都<em>相互</em>存在路径，则为强连通图</li><li><strong>连通分量</strong>：无向图中的<em>极大</em>连通子图称为连通分量</li><li><strong>强连通分量</strong>：有向图中的<em>极大</em>强连通子图称做有向图的强连通分量。</li><li><strong>生成树</strong>：无向图中连通且有 n 个顶点 n-l 条边。</li><li><strong>有向树</strong>：有向图恰有一个顶点的入度为 0 ，其余顶点的入度均为 1。</li><li><strong>生成森林</strong>：一个有向图的生成森林由若干棵有向树组成 ， 含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</li></ul><h2 id="二、图的存储及基本操作"><a href="#二、图的存储及基本操作" class="headerlink" title="二、图的存储及基本操作"></a>二、图的存储及基本操作</h2><h3 id="1、邻接矩阵：适合稠密图"><a href="#1、邻接矩阵：适合稠密图" class="headerlink" title="1、邻接矩阵：适合稠密图"></a>1、邻接矩阵：适合稠密图</h3><p>邻接矩阵 (Adjacency Matrix)用两个数组来表示图：</p><ul><li><p>一维数组：存储图中顶点信息</p></li><li><p>二维数组：存储图中的边或弧的信息。</p></li></ul><h4 id="1）无向图"><a href="#1）无向图" class="headerlink" title="1）无向图"></a>1）无向图</h4><p><img src="https://imine141.github.io/images/%E5%9B%BE1" alt="img"></p><ul><li>无向图的边数组是一个对称矩阵</li><li>有无边：arc[i][j] 是否为 1</li><li>顶点的度：顶点<code>v_i</code>在邻接矩阵中第 i 行(或第 i列)的元素之和</li><li>邻接点：邻接矩阵中第 i 行元素值为 1 就是顶点<code>v_i</code>的邻接点。</li></ul><h4 id="2）有向图"><a href="#2）有向图" class="headerlink" title="2）有向图"></a>2）有向图</h4><p><img src="https://imine141.github.io/images/%E5%9B%BE2" alt="img"></p><ul><li>有向图的矩阵不对称。</li><li>有无弧：arc[i][j] 是否为 1</li><li>入度：第 i 行元素之和</li><li>出度：第 i 列元素之和</li><li>邻接点：第 i 行元素值为 1 的</li></ul><h4 id="3）网"><a href="#3）网" class="headerlink" title="3）网"></a>3）网</h4><p>网的对应边或弧存权值</p><p><img src="https://imine141.github.io/images/%E5%9B%BE3.jpg" alt="img"></p><h3 id="2、邻接表：适合稀疏图"><a href="#2、邻接表：适合稀疏图" class="headerlink" title="2、邻接表：适合稀疏图"></a>2、邻接表：适合稀疏图</h3><p>邻接表(Adjacency List) 使用数组与链表相结合存储图</p><ul><li>一维数组：存顶点，和指向第一个邻接点的指针</li><li>单链表：存每个顶点的所有邻接点。邻接点在顶点表中的下标，</li></ul><h4 id="1）无向图-1"><a href="#1）无向图-1" class="headerlink" title="1）无向图"></a>1）无向图</h4><p><img src="https://imine141.github.io/images/%E5%9B%BE4.jpg" alt="img"></p><ul><li>度：顶点的边表中结点的个数</li><li>是否存在边：测试定点边表中是否存在结点下标</li><li>邻接点：顶点的边表</li></ul><h4 id="2）有向图-1"><a href="#2）有向图-1" class="headerlink" title="2）有向图"></a>2）有向图</h4><p>以顶点为弧尾来存储边表</p><p>有向图的逆邻接表：以顶点为弧头的边表</p><p><img src="https://imine141.github.io/images/%E5%9B%BE5.jpg" alt="img"></p><h4 id="3）网-1"><a href="#3）网-1" class="headerlink" title="3）网"></a>3）网</h4><p>在边表结点定义中再增加一个 weight 的数据域，存储权值信息</p><p><img src="https://imine141.github.io/images/%E5%9B%BE6.jpg" alt="img"></p><h3 id="3、十字链表：适合有向图"><a href="#3、十字链表：适合有向图" class="headerlink" title="3、十字链表：适合有向图"></a>3、十字链表：适合有向图</h3><p>对于有向图来说，邻接表是有缺陷的。出度入度只能关心一个。</p><p>十字链表把邻接表与逆邻接表结合起来。</p><ul><li>一维数组：顶点表结点<ul><li>data</li><li>firstin：入边表头指针</li><li>firstout：出边表头指针</li></ul></li><li>边表结点：<ul><li>tailvex：弧起点在顶点表的下标</li><li>headvex：弧终点在顶点表中的下标</li><li>headlink：入边表指针域</li><li>taillink ：边表指针域</li><li>weight：如果是网，存储权值</li></ul></li></ul><p>实线箭头指针的图示与邻接表相同。虚线箭头是逆邻接表的表示。</p><p><img src="https://imine141.github.io/images/%E5%9B%BE7.jpg" alt="img"></p><h3 id="4、邻接多重表：适合处理无向图的边"><a href="#4、邻接多重表：适合处理无向图的边" class="headerlink" title="4、邻接多重表：适合处理无向图的边"></a>4、邻接多重表：适合处理无向图的边</h3><p>ivex 和 jvex 是与某条边依附的两个顶点在顶点表中下标。ilink 指向依附顶点 ivex 的下一条边， jlink 指向依附顶点 jvex 的下一条边。这就是邻接多重表结构。</p><p>邻接多重表与邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。</p><p><img src="https://imine141.github.io/images/%E5%9B%BE8.jpg" alt="img"></p><h3 id="5、边集数组：适合对边依次处理"><a href="#5、边集数组：适合对边依次处理" class="headerlink" title="5、边集数组：适合对边依次处理"></a>5、边集数组：适合对边依次处理</h3><p>边集数组是由两个一维数组构成。一个是存储顶点的信息;另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标 (begin) 、终点下标 (end) 和权(weigbt) 组成</p><p><img src="https://imine141.github.io/images/%E5%9B%BE9" alt="img"></p><h2 id="三、图的遍历"><a href="#三、图的遍历" class="headerlink" title="三、图的遍历"></a>三、图的遍历</h2><p>图的遍历(Traversing Grapb)：从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次</p><h3 id="1、深度优先搜索"><a href="#1、深度优先搜索" class="headerlink" title="1、深度优先搜索"></a>1、深度优先搜索</h3><p>深度优先遍历(Depth_First_Search)，也有称为深度优先搜索，简称为 DFS。</p><p>类似于树的前序遍历，用数组记录访问：</p><ol><li>访问初始结点v，并标记结点v为已访问。</li><li>查找结点v的第一个邻接结点w。</li><li>若w存在，则继续执行4，否则算法结束。</li><li>若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。</li><li>查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</li></ol><h3 id="2、广度优先搜索"><a href="#2、广度优先搜索" class="headerlink" title="2、广度优先搜索"></a>2、广度优先搜索</h3><p>广度优先遍历 (Breadth.First.Search) ，又称为广度优先搜索，简称 BFS。</p><p>类似于树的分层遍历，用队列保持访问过的结点的顺序：</p><ol><li>访问初始结点v并标记结点v为已访问。</li><li>结点v入队列</li><li>当队列非空时，继续执行，否则算法结束。</li><li>出队列，取得队头结点u。</li><li>查找结点u的第一个邻接结点w。</li><li>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：<ol><li>若结点w尚未被访问，则访问结点w并标记为已访问。</li><li>结点w入队列</li><li>查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</li></ol></li></ol><h2 id="四、图的基本应用"><a href="#四、图的基本应用" class="headerlink" title="四、图的基本应用"></a>四、图的基本应用</h2><h3 id="1、最小（代价）生成树"><a href="#1、最小（代价）生成树" class="headerlink" title="1、最小（代价）生成树"></a>1、最小（代价）生成树</h3><p>最小生成树： 一个具有n个顶点的加权的无向连通图，用n-1条边连接这n个顶点，并且使得连接之后的所有边的权值之和最小的树。</p><h4 id="1）普里姆-Prim-算法"><a href="#1）普里姆-Prim-算法" class="headerlink" title="1）普里姆 ( Prim )算法"></a>1）普里姆 ( Prim )算法</h4><ol><li>将点分为两拨，已经加入最小生成树的，未加入的</li><li>找到未加入中距离集合最近的点，添加该点，修改其它点到集合的距离</li><li>直到所有结点都加入到最小生成树</li></ol><h4 id="2）克鲁斯卡尔-Kruskal-算法"><a href="#2）克鲁斯卡尔-Kruskal-算法" class="headerlink" title="2）克鲁斯卡尔( Kruskal )算法"></a>2）克鲁斯卡尔( Kruskal )算法</h4><ol><li>现将所有边进行权值的从小到大排序</li><li>定义一个一维数组代表连接过的边，数组的下标为边的起点，值为边的终点</li><li>按照排好序的集合用边对顶点进行依次连接，连接的边则存放到一维数组中</li><li>用一维数组判断是否对已经连接的边能构成回路，有回路则无效，没回路则是一条有效边</li><li>重复3，4直至遍历完所有的边为止，即找到最小生成树</li></ol><h3 id="2、最短路径"><a href="#2、最短路径" class="headerlink" title="2、最短路径"></a>2、最短路径</h3><p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</p><h4 id="1）迪杰斯特拉-Dijkstra-算法"><a href="#1）迪杰斯特拉-Dijkstra-算法" class="headerlink" title="1）迪杰斯特拉( Dijkstra ) 算法"></a>1）迪杰斯特拉( Dijkstra ) 算法</h4><p>适用于求一个节点到其他节点的最短路径，通过广度搜索来遍历其他所有需要求距离的点。</p><ol><li>选取初始节点作为一个集合，D(v)表示初始节点到V节点的最短路径</li><li>所有能直接到达V的节点路径记为 D(v)=距离，不能直接到达的节点路径记为 D(v)=无穷</li><li>选取 D(v) 最小的节点加入初始节点集合，最短路径记为<code>D(w)=min(D(w),D(v)+j(v,w))</code>（j(v,w)为节点V到W的距离）</li><li>重复步骤3，直到所有节点都加入初始节点集合</li></ol><h4 id="2）弗洛伊德-Floyd-算法"><a href="#2）弗洛伊德-Floyd-算法" class="headerlink" title="2）弗洛伊德( Floyd )算法"></a>2）弗洛伊德( Floyd )算法</h4><p>适用于求所有顶点至所有顶点的最短路径问题。</p><p><img src="https://imine141.github.io/images/%E5%9B%BE10.jpg" alt="img"></p><ol><li>确定一个中间点</li><li>定义两个二维数组 D[][] 和 P[][]<ul><li>D 代表顶点到顶点的最短路径权值和的矩阵，即点的邻接矩阵</li><li>P 代表对应顶点的最小路径的前驱矩阵</li></ul></li><li>对于每一对顶点 v 和 w，看看是否存在一个顶点 u 使得从 v 到 u 再到 w 比己知的路径更短。</li></ol><h3 id="3、拓扑排序"><a href="#3、拓扑排序" class="headerlink" title="3、拓扑排序"></a>3、拓扑排序</h3><ul><li>AOV：有向无环图</li><li>拓扑序列：是一个有向无环图的所有顶点的线性序列。<ul><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ul></li><li>拓扑排序：对一个有向图构造拓扑序列的过程<ul><li>从 AOV 中选择一个入度为0的顶点并输出。</li><li>从图中删除该顶点，井删除以此顶点为尾的弧</li><li>重复此步骤，直到输出全部顶点，或不存在入度为0的顶点为止。</li></ul></li></ul><p>建立一个邻接表，在顶点表结点结构中，增加一个人度域 in</p><h3 id="4、关键路径"><a href="#4、关键路径" class="headerlink" title="4、关键路径"></a>4、关键路径</h3><ul><li>AOE：有向无环网</li><li>路径长度：路径上各个活动所持续的时间之和</li><li>关键路径：从源点到汇点具有最大长度的路径</li><li>关键活动：在关键路径上的活动</li></ul><h5 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h5><ol><li>事件最早开始时间（etv）：顶点<code>v_k</code>最早发生的时间。</li><li>事件最晚开始时间（ltv）：顶点<code>v_k</code>最晚发生的时间，超出则会延误整个工期。</li><li>活动的最早开始时间（ete）：弧<code>a_k</code>最早发生时间。</li><li>活动的最晚开始时间（lte）：弧<code>a_k</code>最晚发生时间。不推迟工期的最晚开工时间。</li></ol><p>由 1 和 2 可以求得 3 和 4 ，然后再根据 ete[k] 是否与 lte[k] 相等来判断<code>a_k</code>是 否是关键活动。</p><p>建立一个邻接表，弧链表增加了 weight 域，用来存储弧的权值。</p><ul><li>先要调用一次拓扑序列算法的代码来计算etv和拓扑序列表。</li><li>数组etv存储事件最早发生时间</li><li>数组ltv存储事件最迟发生时间</li><li>全局栈用来保存拓扑序列</li></ul><p>如果是多条关键路径，则单是提高一条关键路径上的关键活动速度并不是能导致整个工程缩短工期、而必须提高同时在几条关键路径上的活动的速度。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2020/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
      <url>/2020/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="一、树的基本概念"><a href="#一、树的基本概念" class="headerlink" title="一、树的基本概念"></a>一、树的基本概念</h2><p>树：是 n ( n&gt;=0 ) 个结点的有限集。</p><ul><li>n = 0 时称为空树。</li><li>在任意一棵非空树中:<ul><li>有且仅有一个根结点</li><li>当 n &gt; 1 时，其余结点可分为一个或多个互不相交的有限集。 其中每一个集合本身又是一棵树，并且称为根的子树。</li></ul></li></ul><h3 id="1、结点分类"><a href="#1、结点分类" class="headerlink" title="1、结点分类"></a>1、结点分类</h3><ul><li>结点的度：结点拥有的子树数</li><li>叶结点：度为 0 的结点</li><li>分支结点：度不为 0 的结点</li><li>树的度：树内各结点的度的最大值</li></ul><h3 id="2、结点间关系"><a href="#2、结点间关系" class="headerlink" title="2、结点间关系"></a>2、结点间关系</h3><ul><li>孩子：结点的子树的根称</li><li>双亲：上一结点</li><li>兄弟：同一个双亲的孩子</li><li>祖先：从根到该结点所经分支上的所有结点</li></ul><h3 id="3、树的其他相关概念"><a href="#3、树的其他相关概念" class="headerlink" title="3、树的其他相关概念"></a>3、树的其他相关概念</h3><ul><li>层次：根开始定义起，根为第一层 ，根的孩子为第二层</li><li>堂兄弟：双亲在同一层的结点</li><li>树的深度：树中结点的最大层次</li><li>有序树：树中结点的各子树从左至右有次序，不能互换</li><li>无序树：非有序树</li><li>森林：m (m&gt;=0) 互不相交的树的集合</li></ul><h2 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h2><h3 id="1、二叉树的定义"><a href="#1、二叉树的定义" class="headerlink" title="1、二叉树的定义"></a>1、二叉树的定义</h3><p>二叉树：是 n(n &gt;= 0) 个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p><h4 id="1）主要特征"><a href="#1）主要特征" class="headerlink" title="1）主要特征"></a>1）主要特征</h4><ul><li>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。</li><li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树.</li></ul><h4 id="2）特殊二叉树"><a href="#2）特殊二叉树" class="headerlink" title="2）特殊二叉树"></a>2）特殊二叉树</h4><ul><li>斜树：都只有一边子结点<ul><li>左斜树：所有的结点都只有左子树的二叉树</li><li>右斜树：所有结点都是只有右子树的二叉树</li><li>线性表结构可以理解为是树的一种极其特殊的表现形式</li></ul></li><li>满二叉树：每层结点都排满了</li><li>完全二叉树：按层排序，到结尾中间没有漏掉的结点</li></ul><h4 id="3）二叉树性质"><a href="#3）二叉树性质" class="headerlink" title="3）二叉树性质"></a>3）二叉树性质</h4><ul><li><p>在二叉树的第 i 层上至多有 <code>2^{i-1}</code> 个结点 (i &gt;= 1 ) 。</p></li><li><p>深度为 k 的二叉树至多有<code>2^k-1</code>个结点 (k &gt;= l) 。</p></li><li><p>对任何一棵二叉树 T，如果其终端结点数为 <code>n_0</code>，度为 2 的结点数为 <code>n_2</code>，则 <code>n_0 = n_2 +1</code>。</p></li><li><p>具有 n 个结点的完全二叉树的深度为 <code>[log_2n]+1</code> ([x] 表示不大于 x 的最大整数)。</p></li><li><p>如果对一棵有 n 个结点的完全二叉树(其深度为 <code>[log_2n]+1</code> ) 的结点按层序编号(从第 1 层到第<code>[log_2n]+1</code>层，每层从左到右) ，对任一结点 i (1&lt;= i&lt;= n)有:</p><ul><li>如果 i = 1 ，则结点 i 是二叉树的根，无双亲；如果 i &gt; 1 ，则其双亲是结点 [i/2]。</li></ul></li><li><p>如果 2i &gt; n ，则结点 i 无左孩子(结点 i 为叶子结点)；否则其左孩子是结点 2i。</p><ul><li>如果 2i+1 &gt; n ，则结点 i 无右孩子；否则其右孩子是结点 2i+1 。</li></ul></li></ul><h3 id="2、二叉树的存储结构"><a href="#2、二叉树的存储结构" class="headerlink" title="2、二叉树的存储结构"></a>2、二叉树的存储结构</h3><h4 id="1）顺序存储结构"><a href="#1）顺序存储结构" class="headerlink" title="1）顺序存储结构"></a>1）顺序存储结构</h4><p>顺序存储结构一般只用于完全二叉树。</p><p>用一维数组存储二叉树中的结点，数组的下标和结点序号一致。没有结点的存空。</p><h4 id="2）链式存储结构"><a href="#2）链式存储结构" class="headerlink" title="2）链式存储结构"></a>2）链式存储结构</h4><p>二叉链表：一个数据域和两个指针域的链表。</p><p>指针域分别存左孩子和右孩子的指针。</p><h3 id="3、二叉树的遍历"><a href="#3、二叉树的遍历" class="headerlink" title="3、二叉树的遍历"></a>3、二叉树的遍历</h3><h4 id="1）遍历方法"><a href="#1）遍历方法" class="headerlink" title="1）遍历方法"></a>1）遍历方法</h4><ul><li>前序遍历：根节点-&gt;左子树-&gt;右子树</li><li>中序遍历：左子树-&gt;根节点-&gt;右子树</li><li>后序遍历：左子树-&gt;右子树-&gt;根节点</li><li>层序（宽度优先、广度优先）遍历：每一层从左向右输出</li></ul><p>前序、中序、后序遍历用迭代很简单。</p><p>层序遍历，元素储存有先进先出的特性，选用队列。</p><h4 id="2）遍历推导"><a href="#2）遍历推导" class="headerlink" title="2）遍历推导"></a>2）遍历推导</h4><ul><li>己知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li><li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树 。</li><li>已知前序和后序遍历，是不能确定一棵二叉树的</li></ul><h4 id="3）二叉树的建立"><a href="#3）二叉树的建立" class="headerlink" title="3）二叉树的建立"></a>3）二叉树的建立</h4><p>扩展二叉树：将每个结点的空指针引出一个虚结点，值为特定值（如“#”）</p><p>扩展二叉树可以用递归采用前序、中序、后序遍历的一个遍历序列就确定一颗二叉树。</p><h3 id="4、线索二叉树"><a href="#4、线索二叉树" class="headerlink" title="4、线索二叉树"></a>4、线索二叉树</h3><h4 id="1）基本概念"><a href="#1）基本概念" class="headerlink" title="1）基本概念"></a>1）基本概念</h4><ul><li>线索：指向前驱和后继的指针称为线索</li><li>线索链表：加上线索的二叉链表称为线索链表</li><li>线索化：将二叉链表中的空指针改为指向前驱或后继的线索</li></ul><p>线索二叉树，等于是把一棵二叉树转属变成了一个双向链表，对插入删除结点、查找某个结点都带来了方便</p><h4 id="2）构造"><a href="#2）构造" class="headerlink" title="2）构造"></a>2）构造</h4><p>每个结点增设两个标志域 ltag 和 rtag，区分指针是指向孩子还是指向前驱、后继。</p><p>在遍历的过程中修改空指针。</p><p>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p><h2 id="三、树、森林"><a href="#三、树、森林" class="headerlink" title="三、树、森林"></a>三、树、森林</h2><h3 id="1、树的存储结构"><a href="#1、树的存储结构" class="headerlink" title="1、树的存储结构"></a>1、树的存储结构</h3><h4 id="1-）双亲表示法"><a href="#1-）双亲表示法" class="headerlink" title="1 ）双亲表示法"></a>1 ）双亲表示法</h4><p>除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。</p><p><img src="https://imine141.github.io/images/%E6%A0%911" alt=""></p><p>存储结构的设计是一个非常灵活的过程。</p><ul><li>双亲域：增加一个结点指示其双亲结点的域</li><li>长子域：增加一个结点最左边孩子的域</li><li>右兄弟域：增加一个右兄弟域体现兄弟关系</li></ul><p>当算法中需要在树结构中频繁地查找某结点的父结点时，使用双亲表示法最合适。当频繁地访问结点的孩子结点时，双亲表示法就很麻烦，采用孩子表示法就很简单。</p><h4 id="2）孩子表示法"><a href="#2）孩子表示法" class="headerlink" title="2）孩子表示法"></a>2）孩子表示法</h4><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。</p><ul><li>方案一：指针域的个数就等于树的度<ul><li>树中各结点的度相差很大时，浪费空间</li></ul></li><li>方案二：每个结点指针域的个数等于该结点的度<ul><li>各个结点的链表是不相同的结构，还要维护结点的度的数值，浪费运算时间</li></ul></li></ul><h5 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h5><p>把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</p><p><img src="https://imine141.github.io/images/%E6%A0%912" alt=""></p><h5 id="双亲孩子表示法"><a href="#双亲孩子表示法" class="headerlink" title="双亲孩子表示法"></a>双亲孩子表示法</h5><p>使用孩子表示法存储的树结构，正好和双亲表示法相反，适用于查找某结点的孩子结点，不适用于查找其父结点。可以将两种表示方法合二为一</p><p><img src="https://imine141.github.io/images/%E6%A0%913" alt=""></p><h5 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h5><p>把一棵复杂的树变成一棵二叉树</p><p>链表中每个结点由 3 部分组成：</p><ul><li>孩子指针域：表示指向当前结点的第一个孩子结点</li><li>数据域</li><li>兄弟指针域：表示指向当前结点的下一个兄弟结点</li></ul><p><img src="https://imine141.github.io/images/%E6%A0%914" alt=""></p><h3 id="2、树、森林与二叉树的转换"><a href="#2、树、森林与二叉树的转换" class="headerlink" title="2、树、森林与二叉树的转换"></a>2、树、森林与二叉树的转换</h3><h4 id="1）树转换为二叉树"><a href="#1）树转换为二叉树" class="headerlink" title="1）树转换为二叉树"></a>1）树转换为二叉树</h4><ol><li>加线。在所有兄弟结点之间加一条连线。</li><li>去钱。对树中每个结点，只保留它与第一个孩子结点的连线，删除色与其他孩子结点之间的连线。</li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。（注意第一个孩子是结点的左孩子，兄弟转换过来的孩子是结点的右孩子）</li></ol><p><img src="https://imine141.github.io/images/%E6%A0%915" alt=""></p><h4 id="2）森林转换为二叉树"><a href="#2）森林转换为二叉树" class="headerlink" title="2）森林转换为二叉树"></a>2）森林转换为二叉树</h4><ol><li>把每棵树转换为二叉树。</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。</li></ol><p><img src="https://imine141.github.io/images/%E6%A0%916" alt=""></p><h4 id="3）二叉树转换为树"><a href="#3）二叉树转换为树" class="headerlink" title="3）二叉树转换为树"></a>3）二叉树转换为树</h4><ol><li>加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。</li><li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li><li>层次调整。</li></ol><p><img src="https://imine141.github.io/images/%E6%A0%917" alt=""></p><h4 id="4）二叉树转换为森林"><a href="#4）二叉树转换为森林" class="headerlink" title="4）二叉树转换为森林"></a>4）二叉树转换为森林</h4><p>假如一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则将转换为一棵树。</p><ol><li>从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除…。直到所有这些根节点与右孩子的连线都删除为止。</li><li>将每棵分离后的二叉树转换为树。</li></ol><p><img src="https://imine141.github.io/images/%E6%A0%918" alt=""></p><h3 id="3、树和森林的遍历"><a href="#3、树和森林的遍历" class="headerlink" title="3、树和森林的遍历"></a>3、树和森林的遍历</h3><h4 id="1）树的遍历"><a href="#1）树的遍历" class="headerlink" title="1）树的遍历"></a>1）树的遍历</h4><p>分为两种方式</p><ul><li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历棍的每棵子树。</li><li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点</li></ul><h4 id="2）森林的遍历"><a href="#2）森林的遍历" class="headerlink" title="2）森林的遍历"></a>2）森林的遍历</h4><p>也分为两种方式:</p><ul><li>前序遍历: 先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依放用同样方式遍历除去第一棵树的剩余树构成的森林。</li><li>后序遍历: 是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。</li></ul><p>森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。</p><p>当以二叉链表作树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现。</p><h2 id="四、二叉树的应用"><a href="#四、二叉树的应用" class="headerlink" title="四、二叉树的应用"></a>四、二叉树的应用</h2><h3 id="1、BST（二叉排序树-二叉查找树-二叉搜索树）"><a href="#1、BST（二叉排序树-二叉查找树-二叉搜索树）" class="headerlink" title="1、BST（二叉排序树/二叉查找树/二叉搜索树）"></a>1、BST（二叉排序树/二叉查找树/二叉搜索树）</h3><h4 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h4><p>二叉排序树：又称为二叉查找树、二叉搜索树。它或者是一棵空树，或者是具有下列性质的二叉树。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值;</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值;</li><li>它的左、右子树也分别为二叉排序树。</li></ul><p>二叉排序树利于插入和删除的实现。</p><h4 id="2-操作"><a href="#2-操作" class="headerlink" title="2)操作"></a>2)操作</h4><ul><li>查找：查找成功返回ture，指向成功结点；查找失败返回false，指向上一结点。</li><li>插入：查找不成功，则插入到上一节点的子节点</li><li>构建：反复插入</li><li>删除：<ul><li>叶子节点直接删；</li><li>只有左或右子树的，“子继父业”；</li><li>左右子树都有的，找到需要删除的结点 p 的直接前驱(或直接后继) s，用 s 来替换结点 p，然后再删除此结点 s，s 的子结点移到 s 原来的位置</li></ul></li></ul><h3 id="2、平衡二叉树"><a href="#2、平衡二叉树" class="headerlink" title="2、平衡二叉树"></a>2、平衡二叉树</h3><h4 id="1）定义-1"><a href="#1）定义-1" class="headerlink" title="1）定义"></a>1）定义</h4><ul><li>平衡二叉树：是一种二叉排序树，其中每一个节点的左子树和右子树的高度之差的绝对值不超过 1。</li><li>平衡因子：二叉树上结点的左子树深度减去右子树深度的值（只可能是-1 、0 和 1）</li><li>最小失衡子树：在新插入的结点向上查找，以第一个平衡因子的绝对值超过1的结点为根的子树称为最小不平衡子树。</li></ul><h4 id="2）失衡调整"><a href="#2）失衡调整" class="headerlink" title="2）失衡调整"></a>2）失衡调整</h4><p><img src="https://imine141.github.io/images/%E6%A0%919" alt=""></p><ul><li>LL失衡：右旋（Zig）。当传入一个二叉排序树 P，将它的左孩子结点定义为 L ，将 L 的右子树变成 P 的左子树，再将 P 改成 L 的右子树，最后将 L 替换 P 成为根结点。</li><li>RR失衡：左旋（Zag）。与右旋对称。</li><li>LR失衡：先左旋后右旋（Zig-zag）</li><li>RL失衡：先右旋后左旋（Zag-zig）</li></ul><h3 id="3、堆"><a href="#3、堆" class="headerlink" title="3、堆"></a>3、堆</h3><p>最大堆、最小堆</p><h3 id="4、红黑树"><a href="#4、红黑树" class="headerlink" title="4、红黑树"></a>4、红黑树</h3><p>把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍。</p><h3 id="5、哈夫曼-Huffman-树和哈夫曼编码"><a href="#5、哈夫曼-Huffman-树和哈夫曼编码" class="headerlink" title="5、哈夫曼(Huffman)树和哈夫曼编码"></a>5、哈夫曼(Huffman)树和哈夫曼编码</h3><h4 id="1）赫夫曼树定义"><a href="#1）赫夫曼树定义" class="headerlink" title="1）赫夫曼树定义"></a>1）赫夫曼树定义</h4><ul><li>路径长度：从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。</li><li>树的路径长度：就是从树根到每一结点的路径长度之和。</li><li>带权路径长度：结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。</li><li>树的带权路径长度：为树中所有叶子结点的带权路径长度之和 。</li></ul><p>赫夫曼树：带权路径长度 WPL 最小的二叉树称做赫夫曼树。</p><h4 id="2-赫夫曼树构造"><a href="#2-赫夫曼树构造" class="headerlink" title="2)赫夫曼树构造"></a>2)赫夫曼树构造</h4><ol><li>根据给定的 n 个权值 {<code>w_1,w_2,...,w_n</code>} 构成 n 棵二叉树的集合 F={ <code>T_1,T_2,...,T_n</code>}，其中每棵二叉树 <code>T_i</code> 中只有一个带权为 <code>w_i</code> 根结点，其左右子树均为空。</li><li>在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li><li>在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中 。</li><li>重复 2 和 3 步骤，直到 F 只含一棵树为止。这棵树便是赫夫曼树。</li></ol><h4 id="3-赫夫曼编码"><a href="#3-赫夫曼编码" class="headerlink" title="3)赫夫曼编码"></a>3)赫夫曼编码</h4><p>赫夫曼编码：对需要编码的字符集，统计各个字符出现的次数或频率，作为权值，构造赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，从根节点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码。</p><ul><li>定长编码：像 ASCII 编码</li><li>变长编码：单个编码的长度不一致，可以根据整体出现频率来调节</li><li>前缀码：所谓的前缀码，就是没有任何码字是其他码字的前缀</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="/2020/08/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2020/08/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h3><ul><li>栈：是限定仅在表尾进行插入和删除操作的线性表。后进先出LIFO<ul><li>栈顶(top)：允许插入和删除的一端</li><li>核底(bottom)：另一端</li></ul></li><li>栈的引入简化了程序设计，使关注范围缩小，聚焦于要解决的问题核心。</li></ul><h3 id="2-栈的顺序存储结构-顺序栈"><a href="#2-栈的顺序存储结构-顺序栈" class="headerlink" title="2 栈的顺序存储结构 - 顺序栈"></a>2 栈的顺序存储结构 - 顺序栈</h3><h5 id="1）存储结构"><a href="#1）存储结构" class="headerlink" title="1）存储结构"></a>1）存储结构</h5><p>栈是线性表的特例，栈的顺序存储是线性表顺序存储的简化。</p><ul><li>栈底：数组0端</li><li>top 变量：指示栈顶元素在数组中的位置，空栈-1</li></ul><h5 id="2）基本操作"><a href="#2）基本操作" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>进栈push：栈顶指针加一，新插元素赋值栈顶空间</li><li>出栈pop：栈顶指针减一，返回原栈顶</li></ul><h5 id="3）两栈共享空间"><a href="#3）两栈共享空间" class="headerlink" title="3）两栈共享空间"></a>3）两栈共享空间</h5><p>一个数组来存储两个具有相同数据类型的栈，数组两端为栈底，向中间靠拢。</p><p>通常都是当两个栈的空间需求有相反关系时，才使用这样的数据结构。</p><h3 id="3-栈的链式存储结构-链栈"><a href="#3-栈的链式存储结构-链栈" class="headerlink" title="3 栈的链式存储结构 - 链栈"></a>3 栈的链式存储结构 - 链栈</h3><h5 id="1）存储结构-1"><a href="#1）存储结构-1" class="headerlink" title="1）存储结构"></a>1）存储结构</h5><ul><li>栈顶：单链表的头部，替代头结点</li></ul><h5 id="2）基本操作-1"><a href="#2）基本操作-1" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>进栈push：当前栈顶元素赋值给新结点后继，新结点赋值给栈顶指针</li><li>出栈pop：栈顶指针下移，释放原栈顶结点</li></ul><h5 id="3）顺序栈与链栈对比"><a href="#3）顺序栈与链栈对比" class="headerlink" title="3）顺序栈与链栈对比"></a>3）顺序栈与链栈对比</h5><ul><li>如元素变化不可预料，最好是用链栈；</li><li>如元素变化在可控范围内，使用顺序栈。</li></ul><h3 id="4-栈的应用"><a href="#4-栈的应用" class="headerlink" title="4 栈的应用"></a>4 栈的应用</h3><h5 id="1）递归"><a href="#1）递归" class="headerlink" title="1）递归"></a>1）递归</h5><p>编译器使用栈实现递归</p><h5 id="2）四则运算表达式求值"><a href="#2）四则运算表达式求值" class="headerlink" title="2）四则运算表达式求值"></a>2）四则运算表达式求值</h5><ul><li>中缀表达式：标准四则运算表达式，所有的运算符号都在两数字的中间<ul><li><code>9 + (3 - 1) * 3 + 10/2</code></li></ul></li><li>逆波兰表示：一种不需要括号的后缀表达法，所有的符号都是在要运算数字的后面出现<ul><li><code>9 3 1-3 * + 10 2 / +</code></li></ul></li></ul><h6 id="1-将中缀表达式转化为后缀表达式-栈用来进出运算的符号-。"><a href="#1-将中缀表达式转化为后缀表达式-栈用来进出运算的符号-。" class="headerlink" title="1. 将中缀表达式转化为后缀表达式(栈用来进出运算的符号)。"></a>1. 将中缀表达式转化为后缀表达式(栈用来进出运算的符号)。</h6><ul><li>从左到右遍历中缀表达式的每一数字和符号，若是数字就输出，即成为后缀表达式的一部分</li><li>若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈</li><li>一直到最终输出后缀表达式为止。</li></ul><h6 id="2-将后缀表达式进行运算得出结果-栈用来进出运算的数字-。"><a href="#2-将后缀表达式进行运算得出结果-栈用来进出运算的数字-。" class="headerlink" title="2. 将后缀表达式进行运算得出结果(栈用来进出运算的数字)。"></a>2. 将后缀表达式进行运算得出结果(栈用来进出运算的数字)。</h6><ul><li>从左到右遍历表达式的每个数字和符号，遇到是数字就进栈；</li><li>遇到是符号，就将处于栈顶两个数字出拢，进行运算，运算结果进栈</li><li>一直到最终获得结果。</li></ul><h2 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1 基本概念"></a>1 基本概念</h3><ul><li>队列：是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。先进先出FIFO<ul><li>队尾：允许插入的一端</li><li>队头：允许删除的一端称</li></ul></li></ul><h3 id="2-队列的顺序存储结构-循环队列"><a href="#2-队列的顺序存储结构-循环队列" class="headerlink" title="2 队列的顺序存储结构 - 循环队列"></a>2 队列的顺序存储结构 - 循环队列</h3><h5 id="1）存储结构-2"><a href="#1）存储结构-2" class="headerlink" title="1）存储结构"></a>1）存储结构</h5><ul><li>循环队列：队列的头尾相接的顺序存储结构</li><li>front 指针：头指针</li><li>rear 指针：尾指针。若队列不空，指向队尾的下一个位置</li><li>标志变量 flag：标记队列是否满了</li></ul><h5 id="2）基本操作-2"><a href="#2）基本操作-2" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>入队EnQueue：判满，新元素给尾指针位置，尾指针后移</li><li>出队DeQueue：判空，返回对头元素，头指针后移</li></ul><h3 id="3-队列的链式存储结构-链队列"><a href="#3-队列的链式存储结构-链队列" class="headerlink" title="3 队列的链式存储结构 - 链队列"></a>3 队列的链式存储结构 - 链队列</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。</p><ul><li>front 指针：头指针。指向头结点。</li><li>rear 指针：尾指针。指向终端结点。</li></ul><h5 id="2）基本操作-3"><a href="#2）基本操作-3" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>入队EnQueue：新结点赋值给原对尾结点后继，新结点设为队尾结点，尾指针指向新结点</li><li>出队DeQueue：头结点的后继结点出队，头结点的后继改为其后面的结点。若链表除头结点外只剩一个元素时， 则需将尾指针指向头结点</li></ul><h5 id="3）循环队列与链队列对比"><a href="#3）循环队列与链队列对比" class="headerlink" title="3）循环队列与链队列对比"></a>3）循环队列与链队列对比</h5><ul><li>在可以确定队列长度最大值的情况下，建议用循环队列</li><li>如果无法预估队列的长度时，则用链队列</li></ul><h3 id="4-队列的应用"><a href="#4-队列的应用" class="headerlink" title="4 队列的应用"></a>4 队列的应用</h3><p>键盘输入显示器输出</p><p>排队</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表List</title>
      <link href="/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、线性表的定义和基本操作"><a href="#一、线性表的定义和基本操作" class="headerlink" title="一、线性表的定义和基本操作"></a>一、线性表的定义和基本操作</h2><h5 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h5><p>线性表：零个或多个数据元素的有序排列。</p><blockquote><p>除第一个元素外，每个元素有且只有一个直接前驱元素；除最后一个元素外，每个元素有且只有一个直接后继元素。</p></blockquote><h5 id="2）基本操作"><a href="#2）基本操作" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>InitList：初始化</li><li>ListEmpty：判空</li><li>ClearList：清空</li><li>GetElem：取值</li><li>LocateElem：定位</li><li>Listlnsert：插入</li><li>ListDelete：删除</li><li>ListLength：长度</li></ul><h2 id="二、线性表的实现"><a href="#二、线性表的实现" class="headerlink" title="二、线性表的实现"></a>二、线性表的实现</h2><h3 id="1-顺序存储"><a href="#1-顺序存储" class="headerlink" title="1 顺序存储"></a>1 顺序存储</h3><h5 id="1）定义-1"><a href="#1）定义-1" class="headerlink" title="1）定义"></a>1）定义</h5><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p><h5 id="2）存储结构"><a href="#2）存储结构" class="headerlink" title="2）存储结构"></a>2）存储结构</h5><p>一维数组，存取时间性能为O(1)，随机存取结构</p><ul><li>存储空间的起始位置：数组 data 的存储位置</li><li>线性表的最大容量：数组长度 MaxSize</li><li>线性表的当前长度 : length</li></ul><h5 id="3）主要操作"><a href="#3）主要操作" class="headerlink" title="3）主要操作"></a>3）主要操作</h5><ul><li>取值O(1)：返回数组中指定下标的值。下标超限抛异常</li><li>插入O(n)：从最后一个元素到插入位置元素依次后移，插入，表长+1。位置或长度有问题抛异常或扩容。</li><li>删除O(n)：从删除位置到最后元素依次前移，表长-1。删除位置不合理抛异常。</li></ul><h5 id="4）优缺点"><a href="#4）优缺点" class="headerlink" title="4）优缺点"></a>4）优缺点</h5><p>优点</p><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li><li>可以快速地存取表中任一位置的元素</li></ul><p>缺点</p><ul><li>插入和删除操作需要移动大量元素</li><li>当线性表长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的”碎片”</li></ul><h3 id="2-链式存储"><a href="#2-链式存储" class="headerlink" title="2 链式存储"></a>2 链式存储</h3><h4 id="2-1-单链表"><a href="#2-1-单链表" class="headerlink" title="2.1 单链表"></a>2.1 单链表</h4><h5 id="1）定义-2"><a href="#1）定义-2" class="headerlink" title="1）定义"></a>1）定义</h5><p>不考虑相邻，哪有空就存哪，让每个元素知道它下一个元素的位置</p><h5 id="2）存储结构-1"><a href="#2）存储结构-1" class="headerlink" title="2）存储结构"></a>2）存储结构</h5><p>链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。</p><ul><li>单链表：每个结点中只包含一个指针域，n 个结点链结成一个链表</li><li>结点：数据元素的存储映像，由数据域和指针域组成<ul><li>数据域：存储数据元素信息的域</li><li>指针域：存储直接后继位置的域</li></ul></li><li>头指针：（必要元素）指向链表中第一个结点的存储位置</li><li>头结点：（可选元素）为方便操作，可在第一个结点前附设一个头结点。<ul><li>头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息。</li><li>有了头节点，对第一结点前插入和删除第一结点，与其他结点的操作就统一了</li></ul></li><li>线性链表的最后一个结点指针为“空”</li></ul><h5 id="3）主要操作-1"><a href="#3）主要操作-1" class="headerlink" title="3）主要操作"></a>3）主要操作</h5><ul><li>读取O(n)：从第一个节点遍历</li><li>插入、删除：遍历查找第i个元素O(n)，改变指针，插入和删除O(1)<ul><li>若不知道位置，与顺序存储结构没有优势。知道位置后，优势很大</li><li>对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显</li></ul></li><li>整表创建：动态生成链表。从空表起，依次建立元素结点，插入链表。<ul><li>头插法：新结点插入到头结点与前一新元素之间。</li><li>尾插法：记录尾结点，新结点插在终端结点后面</li></ul></li><li>整表删除：便利每个节点，在内存中将它释放</li></ul><h5 id="4）单链表与顺序存储优缺点"><a href="#4）单链表与顺序存储优缺点" class="headerlink" title="4）单链表与顺序存储优缺点"></a>4）单链表与顺序存储优缺点</h5><ul><li>时间性能<ul><li>查找<ul><li>顺序：o(1)</li><li>单链表：O(n)</li></ul></li><li>插入和删除<ul><li>顺序：平均移动一半元素，O(n)</li><li>单链表：找出位置后，O(1)</li></ul></li></ul></li><li>空间性能<ul><li>顺序：需预分配，大了浪费，小了溢出</li><li>单链表：无需分配不受限</li></ul></li><li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。</li><li>若需要频繁插入和删除时，宜采用单链表结构。</li><li>元素个数变化较大或未知时，最好用单链表。</li><li>如长度确定，顺序存储结构效率会高很多。</li></ul><h4 id="2-2-静态链表"><a href="#2-2-静态链表" class="headerlink" title="2.2 静态链表"></a>2.2 静态链表</h4><h5 id="1）定义-3"><a href="#1）定义-3" class="headerlink" title="1）定义"></a>1）定义</h5><p>针对没有指针的语言，用数组来代替指针描述链表，被称为静态链表。</p><h5 id="2）存储结构-2"><a href="#2）存储结构-2" class="headerlink" title="2）存储结构"></a>2）存储结构</h5><p>游标实现法：数组的元素都是由两个数据域组成， data 和 cur</p><ul><li>数据域data ：用来存放数据元素</li><li>游标 cur ：相当于单链表中的 next 指针，存放该元素的后继在数组中的下标</li><li>第一个元素：存放备用链表的第一个结点的下标</li><li>最后一个元素：存放第一个有数值的元素的下标</li></ul><h5 id="3）主要操作-2"><a href="#3）主要操作-2" class="headerlink" title="3）主要操作"></a>3）主要操作</h5><p>将可用空间链成备用链表</p><ul><li>插入<ul><li>模拟空间分配：从备用链表上取第一个结点作为待插入的新结点</li></ul></li><li>删除<ul><li>模拟空间释放：将删除位置加入备用链表第一位</li></ul></li></ul><h5 id="4）静态链表优缺点"><a href="#4）静态链表优缺点" class="headerlink" title="4）静态链表优缺点"></a>4）静态链表优缺点</h5><ul><li>插入和删除操作时 ，只需要修改游标。</li><li>没有解决连镇存储分配带来的表长难以确定的问题</li><li>失去了顺序存储结构随机存取的特性</li></ul><h4 id="2-3-循环链表"><a href="#2-3-循环链表" class="headerlink" title="2.3 循环链表"></a>2.3 循环链表</h4><h5 id="1）定义-4"><a href="#1）定义-4" class="headerlink" title="1）定义"></a>1）定义</h5><p>循环链表：将单链表中终端结点的指针端由空指针改为指向头结点，这种头尾相接的单链表称为单循环链表，简称循环链表。</p><h5 id="2）差异"><a href="#2）差异" class="headerlink" title="2）差异"></a>2）差异</h5><p>循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断 p-&gt;next 是否为空，现在则是 p -&gt; next 不等于头结点，则循环未结束。</p><h5 id="3）尾指针"><a href="#3）尾指针" class="headerlink" title="3）尾指针"></a>3）尾指针</h5><p>如用尾指针替代头指针，则查找开始结点和终端结点都很方便。</p><h4 id="2-4-双向链表"><a href="#2-4-双向链表" class="headerlink" title="2.4 双向链表"></a>2.4 双向链表</h4><h5 id="1）定义-5"><a href="#1）定义-5" class="headerlink" title="1）定义"></a>1）定义</h5><p>双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</p><h5 id="2）主要操作"><a href="#2）主要操作" class="headerlink" title="2）主要操作"></a>2）主要操作</h5><p>在插入和删除时，需要更改两个指针变量。顺序很重要，千万不能写反了。</p><ul><li>插入<ul><li>先搞定插入结点的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。</li></ul></li><li>删除<ul><li>将前结点的后继指向后结点，将后结点的前驱指向前结点</li></ul></li></ul><h3 id="3-线性表的应用"><a href="#3-线性表的应用" class="headerlink" title="3 线性表的应用"></a>3 线性表的应用</h3><p>队列和堆栈</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组与广义表</title>
      <link href="/2020/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
      <url>/2020/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数组的概念、多维数组的实现"><a href="#1-数组的概念、多维数组的实现" class="headerlink" title="1 数组的概念、多维数组的实现"></a>1 数组的概念、多维数组的实现</h3><h4 id="1）数组的概念"><a href="#1）数组的概念" class="headerlink" title="1）数组的概念"></a>1）数组的概念</h4><ul><li>数组的特点：元素数目固定；下标有界。</li><li>数组的操作：按照下标进行读写。</li></ul><h4 id="2）多维数组的实现"><a href="#2）多维数组的实现" class="headerlink" title="2）多维数组的实现"></a>2）多维数组的实现</h4><h5 id="行优先顺序"><a href="#行优先顺序" class="headerlink" title="行优先顺序"></a>行优先顺序</h5><p>存储时先按行从小到大的顺序存储，在每一行中按列号从小到大存储。</p><h5 id="列优先顺序"><a href="#列优先顺序" class="headerlink" title="列优先顺序"></a>列优先顺序</h5><p>存储时先按列从小到大的顺序存储，在每一列中按行号从小到大存储。</p><h3 id="2-矩阵的压缩存储"><a href="#2-矩阵的压缩存储" class="headerlink" title="2 矩阵的压缩存储"></a>2 矩阵的压缩存储</h3><p>矩阵的压缩存储就是存储数组时，尽量减少存储空间，但数组中每个元素必须存储。</p><p>在矩阵中，如果有规律可寻，只要存储其中一部分，而另外一部分的存储地址可以通过相应的算法将它计算出来，从而占有较少的存储空间达到存储整个矩阵的目的。</p><p>矩阵的压缩存储仅能针对特殊矩阵使用，对于没有规律可循的二维数组则不能使用。</p><h4 id="1）对称矩阵"><a href="#1）对称矩阵" class="headerlink" title="1）对称矩阵"></a>1）对称矩阵</h4><p>只需对对称矩阵中n(n+1)/2个元素进行储存表示</p><p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E5%B9%BF%E4%B9%89%E8%A1%A81" alt=""></p><h4 id="2）三角矩阵"><a href="#2）三角矩阵" class="headerlink" title="2）三角矩阵"></a>2）三角矩阵</h4><p>以主对角线划分，三角矩阵有上三角和下三角两种。上三角矩阵它的下三角中的元素均为常数。下三角矩阵正好相反，它的主对角线上方均为常数。</p><p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A82" alt=""></p><h4 id="3）稀疏矩阵"><a href="#3）稀疏矩阵" class="headerlink" title="3）稀疏矩阵"></a>3）稀疏矩阵</h4><p>if 一个 m * n 的矩阵含有 t 个非零元素，且 t 远远小于 m * n，则称这个矩阵为稀疏矩阵</p><p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A83" alt=""></p><p>除了记录非零元素的值之外，还必须同时几下它所在的行和列的位置。稀疏矩阵的存储方法一般有三种：三元组法、行逻辑连接顺序表和十字链表法。</p><h5 id="三元组法"><a href="#三元组法" class="headerlink" title="三元组法"></a>三元组法</h5><p>用三项内容表示稀疏矩阵中的每个非零元素，形式为：（i,j,value）。<br>其中，i 表示行序号，j 表示列序号，value 表示非零元素的值</p><h3 id="3-广义表的基本概念"><a href="#3-广义表的基本概念" class="headerlink" title="3 广义表的基本概念"></a>3 广义表的基本概念</h3><h4 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h4><ul><li>广义表：是线性表的扩展，具体定义为n（n≥0）个元素的有限集合。<br>n的值是广义表的长度，如果n=0称广义表为空表。</li><li>长度：广义表中含有元素的个数称</li><li>深度：广义表中含有的括号对数</li></ul><h5 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h5><p>广义表的数据元素有两种类型：一个是不可再分的元素（原子元素）；一个是可以再分的元素（子表）。</p><ul><li>如果所有的元素都是原子元素，则称为线性表。</li><li>如果数据元素中含有子表元素，则称为广义表。</li></ul><h5 id="记法"><a href="#记法" class="headerlink" title="记法"></a>记法</h5><p>广义表一般记作：LS=(a1,a2,……,an)</p><p>常见的广义表为：A=()、B=(())、C=(a,b)、D=(A,B,C)、E=(a,E)</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>广义表有三个重要的特点：</p><ul><li>第一：广义表的元素可以是子表，而子表的元素还可以是子表，广义表是一个多层次的结构。</li><li>第二：广义表可以为其他广义表所共享。</li><li>第三：广义表可以是一个递归表，即表也可以是其本身的一个子表。</li></ul><h4 id="2）存储方式"><a href="#2）存储方式" class="headerlink" title="2）存储方式"></a>2）存储方式</h4><p>广义表的存储方法有很多种，一般采用链表存储。</p><p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A84" alt=""></p><p>flag表示标志位。当flag为0时，表示该结点为原子元素，info表示原子元素的值；当flag为1时表示该结点为子表，info表示指针，指向该子表的第一个结点。 link表示指针，指向广义表的下一个元素。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修饰符</title>
      <link href="/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
      <url>/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-访问修饰符"><a href="#1-访问修饰符" class="headerlink" title="1 访问修饰符"></a>1 访问修饰符</h3><ul><li>private：仅对本类可见</li><li>public：对所有类可见<ul><li>接口里方法默认 public</li></ul></li><li>protected：对本包和所有子类可见</li><li>default：对本包可见</li></ul><p>一个方法可以访问所属类的所有对象的私有对象</p><h3 id="2-非访问修饰符"><a href="#2-非访问修饰符" class="headerlink" title="2 非访问修饰符"></a>2 非访问修饰符</h3><h4 id="2-1-final"><a href="#2-1-final" class="headerlink" title="2.1 final"></a>2.1 final</h4><ul><li>final 域（常量）<ul><li>final 域必须显式指定初始值，赋值后，不能被重新赋值。</li><li>基本类型：final 使数值不变</li><li>引用类型：final 使引用不变，但是被引用的对象本身是可以修改的</li></ul></li><li>final 方法<ul><li>final 方法可以被子类继承，但是不能被子类修改。</li><li>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</li></ul></li><li>final 类<ul><li>final 类不能被继承</li></ul></li></ul><h4 id="2-2-static"><a href="#2-2-static" class="headerlink" title="2.2 static"></a>2.2 static</h4><ul><li>静态域（变量）<ul><li>类变量，多实例也只有一份拷贝</li></ul></li><li>静态常量<ul><li>多与 final 组成静态常量，一般大写</li></ul></li><li>静态方法<ul><li>类方法，独立于对象，没有隐式参数 this 和 super，可以访问静态域</li><li>不可从一个 static 方法内部发出对非 static 方法的调用</li><li>必须有实现，不能是抽象方法</li></ul></li><li>静态内部类<ul><li>只有内部类能被声明为 static。</li><li>静态内部类不能访问外部类的非静态的变量和方法。</li></ul></li><li>静态代码块<ul><li>静态块在类加载时自动执行</li></ul></li><li>静态导包<ul><li>JDK 1.5，用 import static 代替 import 静态导入，可以直接使用类的静态方法和静态域，而不需要使用类名作为前缀。</li></ul></li></ul><p>存在继承的情况下，初始化顺序为：</p><blockquote><p>父类（静态变量、静态语句块）<br>子类（静态变量、静态语句块）<br>父类（实例变量、普通语句块）<br>父类（构造函数）<br>子类（实例变量、普通语句块）<br>子类（构造函数）</p></blockquote><h4 id="2-3-abstract"><a href="#2-3-abstract" class="headerlink" title="2.3 abstract"></a>2.3 abstract</h4><ul><li>抽象类<ul><li>抽象类不能实例化，唯一目的是为了对该类进行扩充。</li><li>抽象类可以不包含抽象方法。</li></ul></li><li>抽象方法<ul><li>抽象方法是一种没有任何实现的方法，具体实现由子类提供。</li><li>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</li><li>包含抽象方法的类，一定要声明为抽象类。</li></ul></li></ul><h4 id="2-4-synchronized"><a href="#2-4-synchronized" class="headerlink" title="2.4 synchronized"></a>2.4 synchronized</h4><ul><li>方法</li><li>代码块<ul><li>synchronized 声明的方法同一时间只能被一个线程访问。</li></ul></li></ul><h4 id="2-5-transient"><a href="#2-5-transient" class="headerlink" title="2.5 transient"></a>2.5 transient</h4><ul><li>transient 变量<ul><li>序列化时被跳过</li></ul></li></ul><h4 id="2-6-volatile"><a href="#2-6-volatile" class="headerlink" title="2.6 volatile"></a>2.6 volatile</h4><p>volatile 同步变量</p><ul><li>原子性：不保证</li><li>可见性：保证，读写立刻与主内存交换</li><li>有序性：保证，禁止指令重排序优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 对象与类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类</title>
      <link href="/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E7%B1%BB/"/>
      <url>/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="1-类"><a href="#1-类" class="headerlink" title="1 类"></a>1 类</h3><p>类是构造对象的模板。</p><p>由类构造对象的过程称为创建类的实例。</p><p>一个源文件中，只能有一个公共类，类名必须与文件名相同。</p><h4 id="1-1-类之间的关系"><a href="#1-1-类之间的关系" class="headerlink" title="1.1 类之间的关系"></a>1.1 类之间的关系</h4><p>最常见的关系有：</p><ol><li>依赖（uses-a）：一个类的方法需要操纵另一个类的对象</li><li>聚合（has-a）：类 A 的对象包含着类 B 的对象</li><li>继承（is-a）：继承是一种用于表示特殊与一般的关系，父类更一般</li></ol><p>应该尽可能地将相互依赖的类减至最少。</p><h4 id="1-2-构造器"><a href="#1-2-构造器" class="headerlink" title="1.2 构造器"></a>1.2 构造器</h4><ol><li>构造器和类名同名，参数不限，没有返回值。</li><li>构造器中的局部变量会覆盖同名实例域。</li><li>若未手动编写构造器，会默认提供一个无参构造器，设默认值。手动提供构造器后，不会自动提供无参构造器。</li><li>构造器不能被继承，因此不能被重写，但可以被重载。</li><li>父类与子类的构造函数调用次序：若子类构造器没有显式调用父类构造器，不管子类构造器有无参数，都默认调用父类无参构造器。</li></ol><h4 id="1-3-finalize-方法"><a href="#1-3-finalize-方法" class="headerlink" title="1.3 finalize 方法"></a>1.3 finalize 方法</h4><p>可以为任何一个类添加 finalize 方法，将在垃圾回收器清除对象之前调用。不要依赖，不能保证被调用。</p><h4 id="1-4-Object：所有类的超类"><a href="#1-4-Object：所有类的超类" class="headerlink" title="1.4 Object：所有类的超类"></a>1.4 Object：所有类的超类</h4><p>如果重新定义 equals 方法，就必须重新定义 hashCode 方法。eauals 与 hashCode 的定义必须一致：如果 x.eauals(y) 返回 true，那么 x.hashCode() 必须与 y.hashCode() 具有相同的值。</p><h5 id="1）equals-方法"><a href="#1）equals-方法" class="headerlink" title="1）equals()方法"></a>1）equals()方法</h5><h6 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h6><p>两个对象具有等价关系，需要满足以下五个条件：</p><ul><li><p>自反性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>对称性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>传递性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure></li><li><p>一致性</p><ul><li>多次调用 equals() 方法结果不变</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>与 null 的比较</p><ul><li>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(<span class="keyword">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="等价与相等"><a href="#等价与相等" class="headerlink" title="等价与相等"></a>等价与相等</h6><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><h5 id="2）hashCode"><a href="#2）hashCode" class="headerlink" title="2）hashCode()"></a>2）hashCode()</h5><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p><p>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</p><h5 id="3）toString"><a href="#3）toString" class="headerlink" title="3）toString()"></a>3）toString()</h5><p>默认返回 ClassName@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><h5 id="4）clone"><a href="#4）clone" class="headerlink" title="4）clone()"></a>4）clone()</h5><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><p>clone() 方法并不是 Cloneable 接口的方法，Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><ul><li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。</li><li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。</li></ul><h4 id="1-5-枚举类"><a href="#1-5-枚举类" class="headerlink" title="1.5 枚举类"></a>1.5 枚举类</h4><p>枚举类定义的是一个类，有着指定的几个实例。<br>比较两个枚举类型的值时，不需要调用 equals 方法，而直接使用”==”就可以了。</p><h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2 对象"></a>2 对象</h3><h4 id="2-1-创建对象"><a href="#2-1-创建对象" class="headerlink" title="2.1 创建对象"></a>2.1 创建对象</h4><ol><li>用 new 语句创建对象</li><li>运用反射</li><li>调用对象的 clone() 方法</li><li>运用反序列化手段，调用 java.io.ObjectInputStream 对象的 readObject() 方法</li></ol><p>(1) 和 (2) 都会明确的显式的调用构造函数；(3) 是在内存上对已有对象的影印，所以不会调用构造函数；(4) 是从文件中还原类的对象，也不会调用构造函数。</p><h4 id="2-2-对象克隆"><a href="#2-2-对象克隆" class="headerlink" title="2.2 对象克隆"></a>2.2 对象克隆</h4><p>有两种方式：</p><ul><li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法；</li><li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li></ul><h4 id="2-3-序列化"><a href="#2-3-序列化" class="headerlink" title="2.3 序列化"></a>2.3 序列化</h4><ul><li>对象序列化（Serializable）是指将对象转换为字节序列的过程，而反序列化则是根据字节序列恢复对象的过程。只有实现了 Serializable 和 Externalizable 接口的类的对象才能被序列化。</li><li>java.io.ObjectOutputStream 代表对象输出流，它的 writeObject(Objectobj) 方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</li><li>java.io.ObjectInputStream 代表对象输入流，它的 readObject() 方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</li></ul><h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><h4 id="3-1-方法签名"><a href="#3-1-方法签名" class="headerlink" title="3.1 方法签名"></a>3.1 方法签名</h4><p>方法签名只有<strong>方法名</strong>和<strong>参数</strong>，没有返回值。也就是说，不能有两个名字相同、参数也相同而返回值不同的方法。</p><h4 id="3-2-隐式参数与显式参数"><a href="#3-2-隐式参数与显式参数" class="headerlink" title="3.2 隐式参数与显式参数"></a>3.2 隐式参数与显式参数</h4><p>隐式参数是出现在方法名前的类对象（this），显式参数位于方法名后面的括号中。</p><p>使用 this 可以区分开隐式参数的类对象的实例域和局部变量</p><h4 id="3-3-方法参数"><a href="#3-3-方法参数" class="headerlink" title="3.3 方法参数"></a>3.3 方法参数</h4><p>Java 方法参数是<strong>值传递</strong>，不是引用传递。</p><p>方法在执行时，先定义了局部变量，这些局部变量指向，传入参数的指向。对局部变量重新指向时，完全不影响原本传入参数的那些指向。</p><ul><li>值传递：方法接收的是调用者提供的值。</li><li>引用传递：方法接受的是调用所对应的变量地址。</li></ul><h4 id="3-4-参数变量可变的方法"><a href="#3-4-参数变量可变的方法" class="headerlink" title="3.4 参数变量可变的方法"></a>3.4 参数变量可变的方法</h4><p>Object… 参数类型与 Object[] 完全一样，省略号表明这个方法可以接收任意数量的的对象。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 对象与类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-抽象"><a href="#1-抽象" class="headerlink" title="1 抽象"></a>1 抽象</h3><p>抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2 封装"></a>2 封装</h3><p>把数据和行为隐藏，只能通过暴露的接口访问数据。</p><h3 id="3-继承"><a href="#3-继承" class="headerlink" title="3 继承"></a>3 继承</h3><p>通过扩展一个类来建立另一个新的类。</p><h4 id="3-1-慎用继承"><a href="#3-1-慎用继承" class="headerlink" title="3.1 慎用继承"></a>3.1 慎用继承</h4><ol><li>将公共操作和域放在超类。</li><li>不要使用受保护的域。</li><li>使用继承实现”is-a”。</li><li>除非所有继承的方法都有意义，否则不要使用继承。</li><li>在覆盖方法时，不要改变预期的行为。</li><li>使用多态，而非类型信息。</li><li>不要过多地使用反射。</li></ol><h4 id="3-2-强制类型转换"><a href="#3-2-强制类型转换" class="headerlink" title="3.2 强制类型转换"></a>3.2 强制类型转换</h4><p>只能在继承层次内进行类型转换。</p><p>在将超类转换成子类之前，应该使用 instanceof 进行检查。</p><ul><li>上溯造型（Upcasting）：把衍生类型当作它的基本类型处理</li><li>下溯造型（Downcasting）：向下转型，超类可用子类置换。</li></ul><h4 id="3-3-重写（override）"><a href="#3-3-重写（override）" class="headerlink" title="3.3 重写（override）"></a>3.3 重写（override）</h4><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p><p>为了满足里式替换原则，重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li></ul><p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p><ul><li>this.func(this)</li><li>super.func(this)</li><li>this.func(super)</li><li>super.func(super)</li></ul><h4 id="3-4-重载（overload）"><a href="#3-4-重载（overload）" class="headerlink" title="3.4 重载（overload）"></a>3.4 重载（overload）</h4><p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p><p>应该注意的是，返回值不同，其它都相同不算是重载。</p><h3 id="4-多态"><a href="#4-多态" class="headerlink" title="4 多态"></a>4 多态</h3><p>一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism）。</p><p>Java 实现多态有三个必要条件：继承、重写、上溯造型。</p><p>虚拟机预先为每个类创建了一个方法表（method table），其中列出了所有方法的签名和实际调用的方法。</p><h4 id="4-1-动态绑定"><a href="#4-1-动态绑定" class="headerlink" title="4.1 动态绑定"></a>4.1 动态绑定</h4><p>在运行时能够自动选择调用哪个方法的现象称为动态绑定。</p><ol><li>编译器会列举类方法表中同名方法，和超类方法表中同名且为 public 的方法。</li><li>编译器重载匹配参数类型，若有完全匹配的就选择，没有就匹配允许类型转换的方法，如果这样还是不能找到匹配项，编译器就会报错；同时如果找到多于一个匹配项，编译器也会报错。</li></ol><h4 id="4-2-静态绑定"><a href="#4-2-静态绑定" class="headerlink" title="4.2 静态绑定"></a>4.2 静态绑定</h4><p>如果是 private,static,final 方法或者构造器，那么编译器可以明确地知道该调用哪个方法，这种调用方式成为静态绑定。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 对象与类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符</title>
      <link href="/2020/08/18/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/08/18/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数学函数与常量"><a href="#1-数学函数与常量" class="headerlink" title="1 数学函数与常量"></a>1 数学函数与常量</h3><ul><li>Math.sqrt(x)：平方根</li><li>Math.pow(x, y)：幂运算，x 的 y 次幂</li><li>Math.floorMod(x, y)：求余</li></ul><h3 id="2-自增与自减运算符"><a href="#2-自增与自减运算符" class="headerlink" title="2 自增与自减运算符"></a>2 自增与自减运算符</h3><p>建议不要在表达式中使用 ++，容易带来疑惑和 bug</p><h3 id="3-关系和-boolean-运算符"><a href="#3-关系和-boolean-运算符" class="headerlink" title="3 关系和 boolean 运算符"></a>3 关系和 boolean 运算符</h3><ul><li><code>==</code></li><li><code>!=</code></li><li><code>&lt;</code></li><li><code>&gt;</code></li><li><code>&lt;=</code></li><li><code>&gt;=</code></li><li><code>&amp;&amp;</code>（短路）</li><li><code>||</code>（短路）</li><li><code>?:</code></li></ul><h3 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4 位运算符"></a>4 位运算符</h3><ul><li><p>逻辑</p><ul><li>整型<ul><li><code>|</code> (或)</li><li><code>&amp;</code> (且)</li><li><code>~</code> (非)</li><li><code>^</code> (抑或)</li></ul></li><li>布尔值<ul><li>可用 <code>&amp;</code> 和 <code>|</code>，只是不短路</li></ul></li></ul></li><li><p>位移</p><ul><li><pre><code>&lt;&lt;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  （左移）</span><br><span class="line"></span><br><span class="line">  - &#96;&lt;&lt;&#96; 时 int 模 32，long 模 64，如 1 &lt;&lt; 35 等于 1 &lt;&lt; 3</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>&gt;&gt;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  （带符号右移）</span><br><span class="line"></span><br><span class="line">  - “符号扩展”：若值为正，则在高位插入 0；若值为负，则在高位插入 1。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>&gt;&gt;&gt;</code></pre><p>（无符号右移）</p><ul><li>“零扩展”：无论正负，都在高位插入0。</li></ul></li><li><p>不存在 <code>&lt;&lt;&lt;</code></p></li></ul></li></ul><h3 id="5-括号与运算符级别"><a href="#5-括号与运算符级别" class="headerlink" title="5 括号与运算符级别"></a>5 括号与运算符级别</h3><h3 id="6-枚举类型"><a href="#6-枚举类型" class="headerlink" title="6 枚举类型"></a>6 枚举类型</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 基础设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2020/08/17/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E6%95%B0%E7%BB%84/"/>
      <url>/2020/08/17/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1. 一维数组"></a>1. 一维数组</h3><h4 id="1-1-声明"><a href="#1-1-声明" class="headerlink" title="1.1 声明"></a>1.1 声明</h4><p>一旦创建了数组就不能改变它的大小。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br></pre></td></tr></table></figure><h4 id="1-2-初始化"><a href="#1-2-初始化" class="headerlink" title="1.2 初始化"></a>1.2 初始化</h4><p>数字数组初始化为 0。boolean 数组初始化 false。对象数组初始化 null。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; ;</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-多维数组"><a href="#2-多维数组" class="headerlink" title="2. 多维数组"></a>2. 多维数组</h3><p>java 实际上没有多维数组，只有一维数组，多维数组被解释成“数组的数组”</p><h4 id="2-1-声明"><a href="#2-1-声明" class="headerlink" title="2.1 声明"></a>2.1 声明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[n][]</span><br></pre></td></tr></table></figure><h4 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] A &#x3D; &#123;</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Arrays-类"><a href="#3-Arrays-类" class="headerlink" title="3. Arrays 类"></a>3. Arrays 类</h3><h4 id="3-1-填充-fill"><a href="#3-1-填充-fill" class="headerlink" title="3.1 填充 fill()"></a>3.1 填充 <code>fill()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.fill(type[] a,type v);</span><br></pre></td></tr></table></figure><h4 id="3-2-排序-sort"><a href="#3-2-排序-sort" class="headerlink" title="3.2 排序 sort()"></a>3.2 排序 <code>sort()</code></h4><p>优化的快排</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序排序 </span></span><br><span class="line">Arrays.sort(type[] a);</span><br><span class="line"><span class="comment">//给开始位到结束位排序</span></span><br><span class="line">Arrays.sort(type[] a,<span class="keyword">int</span> start,<span class="keyword">int</span> end);</span><br></pre></td></tr></table></figure><h4 id="3-3-比较-equals"><a href="#3-3-比较-equals" class="headerlink" title="3.3 比较 equals()"></a>3.3 比较 <code>equals()</code></h4><p>比较元素是否相等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.equals(type[] a,type[] b);</span><br></pre></td></tr></table></figure><h4 id="3-4-查找-binarySearch"><a href="#3-4-查找-binarySearch" class="headerlink" title="3.4 查找 binarySearch()"></a>3.4 查找 <code>binarySearch()</code></h4><p>二分查找，数组一定要是先排好序，返回最后一个找到的位置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.binarySearch(type[] a,type v);</span><br><span class="line"><span class="comment">//范围查找</span></span><br><span class="line">Arrays.binarySearch(type[] a,type v,<span class="keyword">int</span> start,<span class="keyword">int</span> end);</span><br></pre></td></tr></table></figure><h4 id="3-5-拷贝-copyOf"><a href="#3-5-拷贝-copyOf" class="headerlink" title="3.5 拷贝 copyOf()"></a>3.5 拷贝 <code>copyOf()</code></h4><p>使用 Arrays 类的 copyOf 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度拷贝</span></span><br><span class="line"><span class="keyword">int</span>[] a = Arrays.copyOf(b,b.length);</span><br><span class="line"><span class="comment">//扩展</span></span><br><span class="line"><span class="keyword">int</span>[] a = Arrays.copyOf(b,b.length*<span class="number">2</span>);</span><br><span class="line"><span class="comment">//部分拷贝</span></span><br><span class="line">Arrays.copyOfRange(a,<span class="number">0</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="3-6-转字符串-toString"><a href="#3-6-转字符串-toString" class="headerlink" title="3.6 转字符串 toString()"></a>3.6 转字符串 <code>toString()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.toString(a)</span><br><span class="line"><span class="comment">//打印多维数组</span></span><br><span class="line">Arrays.deepToString()</span><br></pre></td></tr></table></figure><h4 id="3-7-转列表-asList"><a href="#3-7-转列表-asList" class="headerlink" title="3.7 转列表 asList()"></a>3.7 转列表 <code>asList()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Moe"</span>, <span class="string">"Curly"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 基础设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2020/08/16/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/08/16/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-String-底层实现"><a href="#1-String-底层实现" class="headerlink" title="1 String 底层实现"></a>1 String 底层实现</h3><p>String 被声明为 final，因此它不可被继承。</p><p>底层是 char 或 byte 类型的 value 数组，value 数组也被声明为 final，这意味着数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><p>编辑器可让字符串共享在常量池。</p><h4 id="1-1-Java-8-char-数组"><a href="#1-1-Java-8-char-数组" class="headerlink" title="1.1 Java 8 - char 数组"></a>1.1 Java 8 - char 数组</h4><p>在 Java 8 中，String 内部使用 char 数组存储数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-Java-9-byte-数组"><a href="#1-2-Java-9-byte-数组" class="headerlink" title="1.2 Java 9 - byte 数组"></a>1.2 Java 9 - byte 数组</h4><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-不可变的好处"><a href="#1-3-不可变的好处" class="headerlink" title="1.3 不可变的好处"></a>1.3 不可变的好处</h4><ul><li>可以缓存 hash 值<ul><li>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li></ul></li><li>String Pool 的需要<ul><li>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li></ul></li><li>安全性<ul><li>String 经常作为参数，String 不可变性可以保证参数不可变。</li><li>例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li></ul></li><li>线程安全<ul><li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li></ul></li></ul><h3 id="2-StringBuilder-和-StringBuffer"><a href="#2-StringBuilder-和-StringBuffer" class="headerlink" title="2 StringBuilder 和 StringBuffer"></a>2 StringBuilder 和 StringBuffer</h3><h4 id="2-1-可变性与线程安全"><a href="#2-1-可变性与线程安全" class="headerlink" title="2.1 可变性与线程安全"></a>2.1 可变性与线程安全</h4><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 可变，不是线程安全的，效率比 StringBuffer 高</li><li>StringBuffer 可变，是线程安全的，内部使用 synchronized 进行同步</li></ul><h4 id="2-2-底层实现"><a href="#2-2-底层实现" class="headerlink" title="2.2 底层实现"></a>2.2 底层实现</h4><p>StringBuilder 和 StringBuffer 继承了 AbstractStringBuilder，AbstractStringBuilder 的 char 数组没有 final 关键字修饰，字符数组长度可变，所有 StringBuilder 和 StringBuffer 也是可变的</p><p>AbstractStringBuilder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// StringBuilder 类继承 AbstractStringBuilder 抽象类</span></span><br><span class="line">    <span class="comment">// 创建长度 16 的字符数组</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-String-Pool-与引用"><a href="#3-String-Pool-与引用" class="headerlink" title="3 String Pool 与引用"></a>3 String Pool 与引用</h3><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。</p><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><ul><li>new String()：会在堆新建对象</li><li>intern() 方法： String 对象的 intern 方法会得到字符串对象在常量池中对应的版本的引用，如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；</li><li>“”字面量：使用字面量的形式创建字符串，会自动地将字符串放入 String Pool 中</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"Programming"</span>;<span class="comment">//先去常量池取，没有就新建对象放在常量池</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"Programming"</span>);<span class="comment">//两个字符串对象，一个是常量池的"Programming"，一个是用 new 创建在堆上的对象</span></span><br><span class="line">String s3 = <span class="string">"Program"</span>;<span class="comment">//常量池</span></span><br><span class="line">String s4 = <span class="string">"ming"</span>;<span class="comment">//常量池</span></span><br><span class="line">String s5 = <span class="string">"Program"</span> + <span class="string">"ming"</span>;<span class="comment">//常量池</span></span><br><span class="line">String s6 = s3 + s4;<span class="comment">//堆</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s5);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s6.intern());<span class="comment">//true</span></span><br><span class="line">System.out.println(s2 == s2.intern());<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="4-String-常用方法"><a href="#4-String-常用方法" class="headerlink" title="4 String 常用方法"></a>4 String 常用方法</h3><h4 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h4><h5 id="1）使用字符串常量直接初始化"><a href="#1）使用字符串常量直接初始化" class="headerlink" title="1）使用字符串常量直接初始化"></a>1）使用字符串常量直接初始化</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D; &quot;hello!&quot;;</span><br></pre></td></tr></table></figure><h5 id="2）使用构造方法创建并初始化"><a href="#2）使用构造方法创建并初始化" class="headerlink" title="2）使用构造方法创建并初始化"></a>2）使用构造方法创建并初始化</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D; new String(Object);</span><br></pre></td></tr></table></figure><p>初始化源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="comment">// 本质是字符数组常量，所以不可变</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-操作"><a href="#4-2-操作" class="headerlink" title="4.2 操作"></a>4.2 操作</h4><h5 id="1）截取字符串"><a href="#1）截取字符串" class="headerlink" title="1）截取字符串"></a>1）截取字符串</h5><ul><li>单点截取：subString(开始下标)</li><li>双点截取：subString(开始下标，结束下标)</li></ul><h5 id="2）拼接字符串"><a href="#2）拼接字符串" class="headerlink" title="2）拼接字符串"></a>2）拼接字符串</h5><ul><li>+ 号</li><li>join：用一个定界符分割，String.join(“定界符”,“待合并字符串”…)</li></ul><p>字符串的 + 操作其本质是创建了 StringBuilder 对象进行 append 操作，然后将拼接后的 StringBuilder 对象用 toString 方法处理成 String 对象</p><p>一般情况进行字符串拼接用 + 就可以，但是如果是循环拼接，则需要用 StringBuilder 的 append 来实现。</p><p>若不使用 StringBuilder 的 append 方法而使用 + 来进行连接。那么每次在循环体内都将会在 Heap 中创造一个新的 String 对象，造成资源浪费。</p><h5 id="3）获取信息"><a href="#3）获取信息" class="headerlink" title="3）获取信息"></a>3）获取信息</h5><ul><li>下标：indexOf(子字符)，lastIndexOf(子字符)</li><li>字符：charAt(下标)</li><li>字节数组：getBytes()</li><li>字符数组：toCharArray()</li><li>长度：length()</li></ul><h5 id="4）替换字符串"><a href="#4）替换字符串" class="headerlink" title="4）替换字符串"></a>4）替换字符串</h5><ul><li>去掉前后空格：trim()</li><li>子字符串：split(字符串)，StringTokenizer()</li></ul><h5 id="5）判断字符串"><a href="#5）判断字符串" class="headerlink" title="5）判断字符串"></a>5）判断字符串</h5><ul><li>是否相等：.equals()</li><li>不区分大小写：.equalsIgnoreCase()</li><li>是否为空串：.length()==0 或 .equals(“”)</li><li>是否为null：== null</li><li>前缀：startsWith(前缀)</li><li>后缀：endsWith(后缀)</li><li>大小：compareTo()</li></ul><h5 id="6）字符串转换"><a href="#6）字符串转换" class="headerlink" title="6）字符串转换"></a>6）字符串转换</h5><ul><li>大/小写：<ul><li>大写：toLowerCase()</li><li>小写：toUpperCase()</li></ul></li><li>字符串转换为基本类型<ul><li>Long.parseLong(“1231”);</li><li>Double.parseDouble(“0.213”);</li></ul></li><li>基本类型转换为字符串<ul><li>基本数据类型变量 + “”</li><li>String.valueOf(其他类型的参数)；</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 基础设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器</title>
      <link href="/2020/08/15/Java%E5%9F%BA%E7%A1%80/%E5%AE%89%E5%85%A8/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2020/08/15/Java%E5%9F%BA%E7%A1%80/%E5%AE%89%E5%85%A8/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、类加载器"><a href="#一、类加载器" class="headerlink" title="一、类加载器"></a>一、类加载器</h2><h3 id="1-类加载过程"><a href="#1-类加载过程" class="headerlink" title="1 类加载过程"></a>1 类加载过程</h3><p>虚拟机只加载程序执行时所需要的类文件。假设程序从 MyProgram.class 开始运行，下面是虚拟机执行的步骤：</p><ol><li>虚拟机有一个用于加载类文件的机制。</li><li>如果类拥有类型为另一个类的域，或者是拥有超类，那么这些类文件也会被加载。</li><li>接着，虚拟机执行类中的 main 方法。</li><li>如果 main 方法或者 main 调用的方法要用到更多的类，那么接下来就会加载这些类。</li></ol><p>每个Java程序至少拥有<strong>三个类加载器</strong>：</p><ul><li><p>启动类加载器(Bootstrap ClassLoader)</p><p>​    这个类加载器负责负责加载JDK中的核心类库，这个类加载器完全由JVM控制</p></li><li><p>扩展类加载器(Extendsion ClassLoader)</p><p>​    这个类加载器负责加载\lib\ext目录下的类库</p></li><li><p>应用程序类加载器(Application ClassLoader)</p><p>​    这个类加载器负责加载用户类路径(CLASSPATH)下的类库,一般我们编写的java类都是由这个类加载器加载</p></li></ul><h3 id="2-类加载器的层次结构"><a href="#2-类加载器的层次结构" class="headerlink" title="2 类加载器的层次结构"></a>2 类加载器的层次结构</h3><p>类加载器有一种父/子关系。除了引导类加载器外，每个类加载器都有一个父类加载器。父类加载失败子类才加载。</p><p>如果插件被打包为 JAR 文件，那就可以直接用 URLClassLoader 类的实例去加载这些类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"path"</span>);</span><br><span class="line">URLClassLoader pluginLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123;url&#125;);</span><br><span class="line">Class&lt;?&gt; cl = pluginLoader.loadClass(<span class="string">"mypackage.MyClass"</span>);</span><br></pre></td></tr></table></figure><p>可以通过下面将其设置成为任何类加载器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">t.setContextClassLoader(loader);</span><br></pre></td></tr></table></figure><p>助手方法可以获取这个上下文类加载器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ClassLoader loader = t.getCOntextClassLoader();</span><br><span class="line">Class cl = loader.loaderClass(className);</span><br></pre></td></tr></table></figure><p>当调用由不同的类加载器加载的插件类的方法时，进行上下文类加载器的设置是一种好的思路；或者，让助手方法的调用者设置上下文类加载器。</p><h3 id="3-将类加载器作为命名空间"><a href="#3-将类加载器作为命名空间" class="headerlink" title="3 将类加载器作为命名空间"></a>3 将类加载器作为命名空间</h3><p>同一虚拟机中，可以有两个类的类名和包名都相同。类是由它的全名和类加载器来确定的。</p><h3 id="4-编写自己的类加载器"><a href="#4-编写自己的类加载器" class="headerlink" title="4 编写自己的类加载器"></a>4 编写自己的类加载器</h3><p>编写自己的类加载器，只需要继承 ClassLoader 类，然后覆盖下面这个方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">findClass(String className)</span><br></pre></td></tr></table></figure><p>ClassLoader 超类的 loadClass 方法用于将类的加载操作委托给其父类加载器去进行，只有当该类尚未加载并且父类加载器也无法加载该类时，才调用 findClass 方法。</p><p>如果要实现该方法，必须做到以下几点：</p><ol><li>为来自本地文件系统或者其他来源的类加载其字节码</li><li>调用 ClassLoader 超类的 defineClass 方法，想虚拟机提供字节码。</li></ol><h3 id="5-字节码校验"><a href="#5-字节码校验" class="headerlink" title="5 字节码校验"></a>5 字节码校验</h3><p>当类加载器将新在加载的 Java 平台类的字节码传递给虚拟机，这些字节码首先要接受校验器的校验。校验器负责检查那些指令无法执行的明细那有破坏性的操作。出了系统类外，所有的类都要被校验。</p><p>下面是校验器执行的一些检查：</p><ul><li>变量要在使用之前进行初始化。</li><li>方法调用与对象引用类型之间要匹配。</li><li>访问私有类型和方法的规则没有被违反。</li><li>对本地变量的访问都落在运行时堆栈内。</li><li>运行时堆栈没有用溢出。</li></ul><h2 id="二、双亲委派原则"><a href="#二、双亲委派原则" class="headerlink" title="二、双亲委派原则"></a>二、双亲委派原则</h2><h3 id="1-双亲委派原则"><a href="#1-双亲委派原则" class="headerlink" title="1 双亲委派原则"></a>1 双亲委派原则</h3><p>一个类加载器受到类加载的请求，它会把这个请求转交到它的父加载器去请求，如果上级还有加载器，就继续把请求上传，直到启动类加载器。然后找到就返回给子加载器，直到第一个发出请求的类加载器。如果最后还是没有找到，就让子加载器自己去找</p><p><img src="https://imine141.github.io/images/1858901-20200325152628228-1073837913.png" alt="img"></p><h3 id="2-破坏双亲委派原则"><a href="#2-破坏双亲委派原则" class="headerlink" title="2 破坏双亲委派原则"></a>2 破坏双亲委派原则</h3><p>单一责任原则（SRP）不是绝对的。 它的存在有助于代码的可维护性和可读性。 但是您可能会不时看到解决方案，破坏SRP的模式，而且还可以。 其他原则也是如此，但是这次我想谈谈SRP。</p><p>在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由Bootstrap类加载器加载，而 SPI 的第三方实现代码则是作为Java应用所依赖的 jar 包被存放在classpath路径下，由于SPI接口中的代码经常需要加载具体的第三方实现类并调用其相关方法，但SPI的核心接口类是由引导类加载器来加载的，而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，而线程上下文类加载器就是很好的选择。</p><h4 id="2-1-线程上下文类加载器（contextClassLoader）"><a href="#2-1-线程上下文类加载器（contextClassLoader）" class="headerlink" title="2.1 线程上下文类加载器（contextClassLoader）"></a>2.1 线程上下文类加载器（contextClassLoader）</h4><p>通过java.lang.Thread类中的<code>getContextClassLoader()</code>和 <code>setContextClassLoader(ClassLoader cl)</code>方法来获取和设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器（AppClassLoader）,在线程中运行的代码可以通过此类加载器来加载类和资源，如下图所示，以jdbc.jar加载为例</p><p><img src="https://imine141.github.io/images/SouthEast.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型</title>
      <link href="/2020/08/15/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/08/15/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>数据类型分为基本类型和对象类型。</p><h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h3><p>Java 中的基本类型有 8 种，其中有 4 种整型、2 种浮点型、char 和 boolean。还有 void 和 reference 类型</p><ol><li>基本类型值存储在内存栈上。</li><li>基本类型所占空间大小固定。</li><li>所有数值类型都有正负号。</li></ol><h4 id="1-1-整型"><a href="#1-1-整型" class="headerlink" title="1.1 整型"></a>1.1 整型</h4><table><thead><tr><th>类型</th><th>包装类</th><th>存储需求</th><th>取值范围</th><th>零值</th><th>备注</th></tr></thead><tbody><tr><td>long</td><td>Long</td><td>8 字节 64 bits</td><td>-2^63 ~ +2^63-1</td><td>0L</td><td>后缀加L或l</td></tr><tr><td>int</td><td>Integer</td><td>4 字节 32 bits</td><td>-2^31 ~ +2^31-1</td><td>0</td><td>最常用，范围超20亿</td></tr><tr><td>short</td><td>Short</td><td>2 字节 16 bits</td><td>-2^15 ~ +2^15-1</td><td>(short)0</td><td>控制占用存储空间的大数组</td></tr><tr><td>byte</td><td>Byte</td><td>1 字节 8 bits</td><td>-2^7 ~ +2^7-1</td><td>(byte)0</td><td>底层文件处理</td></tr></tbody></table><ol><li>十六进制前缀 0x 或0X</li><li>八进制前缀 0</li><li>二进制前缀 0b 或 0B(Java 7 开始)</li><li>数字加下划线更易读，如 1_000_000，编译器会去掉(Java 7 开始)</li><li>没有后缀标识的整数默认为 int 类型</li></ol><h4 id="1-2-浮点"><a href="#1-2-浮点" class="headerlink" title="1.2 浮点"></a>1.2 浮点</h4><table><thead><tr><th>类型</th><th>包装类</th><th>存储需求</th><th>取值范围</th><th>零值</th><th>备注</th></tr></thead><tbody><tr><td>double</td><td>Double</td><td>8 字节 64 bits</td><td>大约-2^1024 ~ -2^-1074 —— 0 —— 2^-1074 ~ 2^1024（有效 15 位）</td><td>0.0d</td><td>后缀 D 或 d，最常用。</td></tr><tr><td>float</td><td>Float</td><td>4 字节 32 bits</td><td>大约-2^128 ~ -2^-149 —— 0 —— 2^-149 ~ 2^128（有效 6~7 位）</td><td>0.0f</td><td>后缀 F 或 f，单精度库或大量数据</td></tr></tbody></table><ol><li>没有后缀F的浮点数默认是 double</li><li>浮点数不能绝对精确，因为二进制种无法精确表示 1/10，不允许误差应使用 BigDecimal 类。</li></ol><p>浮点数的结构与整型不同，指数的底数为 2，尾数表示小数部分</p><table><thead><tr><th>类型</th><th>符号位（S）</th><th>指数位（E）</th><th>尾数位（M）</th></tr></thead><tbody><tr><td>float</td><td>1 bit</td><td>8 bits</td><td>23 bits</td></tr><tr><td>double</td><td>1 bit</td><td>11 bits</td><td>52 bits</td></tr></tbody></table><h4 id="1-3-字符"><a href="#1-3-字符" class="headerlink" title="1.3 字符"></a>1.3 字符</h4><table><thead><tr><th>类型</th><th>包装类</th><th>存储需求</th><th>取值范围</th><th>零值</th><th>备注</th></tr></thead><tbody><tr><td>char</td><td>Character</td><td>2 字节 16 bits</td><td>int0-2^16-1 ,hex’\u0000’~’’\Uffff’</td><td>‘\u0000’</td><td>char 字面量要用单引号括起来。</td></tr></tbody></table><ul><li>转移序列 \u 可以出现在加引号的字符常量或字符串外（其它所有转义序列不可以）</li><li>警告：Unicode 转移序列会在解析代码前得到处理</li><li>警告：当心注释里的 \u，如“\u00A0”换行符，或“c:\user”，语法错误，因为没跟 4 个十六进制数</li><li>解决方案：字符串中用转义符“\”来去除“\u”造成的不必要影响</li></ul><h4 id="1-4-布尔"><a href="#1-4-布尔" class="headerlink" title="1.4 布尔"></a>1.4 布尔</h4><p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。</p><p>JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。</p><p>JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p><p>整型和布尔之间不能转换，不能用 0 当作 false，可以使用条件表达式</p><h4 id="1-5-类型转换"><a href="#1-5-类型转换" class="headerlink" title="1.5 类型转换"></a>1.5 类型转换</h4><p>不要强制转换 boolean 类型，可用条件表达式</p><p>自动类型转换图示：byte -&gt; short(char) -&gt; int -&gt; long -&gt; float -&gt; double ，强制类型与之相反</p><h5 id="1）自动类型转换"><a href="#1）自动类型转换" class="headerlink" title="1）自动类型转换"></a>1）自动类型转换</h5><p>运算或方法调用时，系统会将较小的数据类型自动转换为较大的数据类型</p><ul><li>当使用 +、-、*、/、% 运算符对基本类型进行运算时，转换为较大的数据类型，如最大的小于 int，则转为 int</li></ul><h5 id="2）强制类型转换"><a href="#2）强制类型转换" class="headerlink" title="2）强制类型转换"></a>2）强制类型转换</h5><p>强制类型将较大的数据类型转化为较小的数据类型，可能导致精度损失。</p><ul><li>当使用 +=、-=、*=、/=、%= 运算符对基本类型进行运算时，运算符右边的数值将首先被强制转换成与运算符左边数值相同的类型，然后再执行运算，且运算结果与运算符左边数值类型相同。</li></ul><h3 id="2-包装类型"><a href="#2-包装类型" class="headerlink" title="2. 包装类型"></a>2. 包装类型</h3><ul><li>所有的基本类型都有一个与之对应的类。包装类都是声明为 final的，不可变，不可被继承。</li><li>对象引用存储在内存栈上，而对象本身的值存储在内存堆上。</li><li>对一个对象进行操作时，我们真正操作的是它的句柄。</li><li>自动装箱：基本类型自动转换成包装类，调用了 Integer.valueOf()</li><li>自动拆箱：包装类自动转换为基本类型，调用了 X.intValue()</li></ul><h4 id="2-1-大数值"><a href="#2-1-大数值" class="headerlink" title="2.1 大数值"></a>2.1 大数值</h4><ul><li>BigInteger 支持任意精度的整数。</li><li>BigDecimal 支持任意精度的浮点数字。</li><li>转换方法： valueOf</li><li>运算方法： add, multiply, divide 等</li></ul><h3 id="3-缓存池"><a href="#3-缓存池" class="headerlink" title="3. 缓存池"></a>3. 缓存池</h3><p>基本类型对应的缓冲池如下：</p><ul><li>boolean：true, false</li><li>byte、short、int、long：-128 ~ 127</li><li>char：\u0000 ~ \u007F</li></ul><p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p><h4 id="3-1-IntegerCache"><a href="#3-1-IntegerCache" class="headerlink" title="3.1 IntegerCache"></a>3.1 IntegerCache</h4><p>Integer 缓冲池 IntegerCache， 是静态类，上界可以通过参数调整。</p><p>加载的时候会初始化一个 int 数组，填上 -128 ~ 127 的值。</p><h4 id="3-2-valueOf-方法"><a href="#3-2-valueOf-方法" class="headerlink" title="3.2 valueOf() 方法"></a>3.2 valueOf() 方法</h4><p>valueOf() 方法会使用缓存池中的对象，多次调用会取得同一个对象的引用。</p><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 基础设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC</title>
      <link href="/2020/07/21/Spring/Web/Spring%20MVC/"/>
      <url>/2020/07/21/Spring/Web/Spring%20MVC/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Spring-MVC-概览"><a href="#1-Spring-MVC-概览" class="headerlink" title="1 Spring MVC 概览"></a>1 Spring MVC 概览</h3><p>Spring 提供了一个功能齐全的 MVC 框架用于构建 Web 应用程序。Spring 框架可以很容易的和其他的 MVC 框架融合(如 Struts)，该框架使用控制反转(IOC)将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。</p><ul><li>DispatcherServlet<ul><li>Spring 的 MVC 框架是围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP 请求和响应。</li></ul></li><li>WebApplicationContext<ul><li>WebApplicationContext 继承了 ApplicationContext，并添加了一些 web 应用程序需要的功能。和普通的 ApplicationContext 不同，WebApplicationContext 可以用来处理主题样式，它也知道如何找到相应的 servlet。</li></ul></li><li>Controller<ul><li>控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。</li><li>@Controller 注解表示该类扮演控制器的角色。Spring 不需要继承任何控制器基类或应用 Servlet API。</li></ul></li><li>@RequestMapping 注解用于将 URL 映射到任何一个类或者一个特定的处理方法上。</li></ul><h4 id="1-1-Spring-MVC-运行原理"><a href="#1-1-Spring-MVC-运行原理" class="headerlink" title="1.1 Spring MVC 运行原理"></a>1.1 Spring MVC 运行原理</h4><p><img src="https://imine141.github.io/images/1545011851570.png" alt="img"></p><ol><li>Spring MVC 通过一个单独的前端控制器（DispatcherServlet）过滤分发请求。</li><li>DispatcherServlet 根据处理器映射（HandlerMapping）和请求携带的 URL 决定将请求发送给某个控制器（Controller）。</li><li>控制器从请求中取得信息，然后委托业务逻辑组件处理。将处理结果打包在模型（model）中，然后指定一个视图（view）的逻辑名称，然后将请求和模型、视图名称一起发送回 DispatcherServlet。</li><li>DispatcherServlet 用视图名称查找对应的视图解析器（ViewResolver），负责将逻辑名称转换成对应的页面实现。</li><li>最后一步就是视图的实现。视图会使用模型数据填充到视图实现中，然后将结果放在 HTTP 响应对象中。</li></ol><h4 id="1-2-Spring-MVC-配置"><a href="#1-2-Spring-MVC-配置" class="headerlink" title="1.2 Spring MVC 配置"></a>1.2 Spring MVC 配置</h4><h5 id="1）配置前端控制器"><a href="#1）配置前端控制器" class="headerlink" title="1）配置前端控制器"></a>1）配置前端控制器</h5><p>继承了 AbstractAnnotationConfigDispatcherServletInitializer，会在项目运行初始化被自动发现并加载。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 根容器</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123; </span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; RootConfig<span class="class">.<span class="keyword">class</span> &#125;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Spring mvc 容器，指定配置类</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123; </span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; WebConfig<span class="class">.<span class="keyword">class</span> &#125;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// DispatcherServlet 映射,从"/"开始</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> String[] getServletMappings() &#123; </span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"/"</span> &#125;;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppInitializer 类需要实现三个方法，RootConfig 和 WebConfig 是两个关键配置类，而 getServletMappings 只需要返回一个 String 的列表，{“/”}的意思是监听访问 url 下所有的请求。</p><h5 id="2）配置视图解析器"><a href="#2）配置视图解析器" class="headerlink" title="2）配置视图解析器"></a>2）配置视图解析器</h5><p>@EnableWebMvc：启动 Spring MVC 特性<br>configer.enable()：静态资源的请求将转交给 servlert 容器的 default servlet 处理。</p><ul><li>setPrefix() 方法用于设置视图路径的前缀；</li><li>setSuffix() 用于设置视图路径的后缀；</li><li>setExposeContextBeansAsAttributes(true) 使得可以在 JSP 页面中通过 ${ } 访问容器中的 bean</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span><span class="comment">//启动Spring MVC</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"org.test.spittr.web"</span>)<span class="comment">//启动组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Bean</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123; </span><br><span class="line">             <span class="comment">// 配置JSP视图解析器</span></span><br><span class="line">             InternalResourceViewResolver resolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">             resolver.setPrefix(<span class="string">"/WEB-INF/views/"</span>);</span><br><span class="line">             resolver.setSuffix(<span class="string">".jsp"</span>);</span><br><span class="line">             <span class="comment">// 可以在JSP页面中通过$&#123;&#125;访问beans</span></span><br><span class="line">             resolver.setExposeContextBeansAsAttributes(<span class="keyword">true</span>);</span><br><span class="line">             <span class="keyword">return</span> resolver;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.enable(); <span class="comment">//配置静态文件处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3）配置-Bean"><a href="#3）配置-Bean" class="headerlink" title="3）配置 Bean"></a>3）配置 Bean</h5><p>RootConfig 在设置扫描机制的时候，将之前 WebConfig 设置过的那个包排除了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123; <span class="string">"org.test.spittr.controller"</span> &#125;, excludeFilters = &#123;</span><br><span class="line">             <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION, value = EnableWebMvc<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RootConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-编写-Controller"><a href="#2-编写-Controller" class="headerlink" title="2 编写 Controller"></a>2 编写 Controller</h3><h4 id="2-1-控制器类"><a href="#2-1-控制器类" class="headerlink" title="2.1 控制器类"></a>2.1 控制器类</h4><p>控制器类就是含有被 @RequestMapping 注解修饰的方法的类。@Controller 是 @Component 的别名，返回一个视图逻辑名称。</p><p>@RequestMapping 可加在类上和方法上，可同时映射多个路径</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">     <span class="meta">@RequestMapping</span>(value = &#123; <span class="string">"/"</span>, <span class="string">"/homepage"</span> &#125;, method = RequestMethod.GET)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"home"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-请求参数"><a href="#2-2-请求参数" class="headerlink" title="2.2 请求参数"></a>2.2 请求参数</h4><p>Spring MVC 提供了三种方式，可以让客户端给控制器的 handler 传入参数：</p><h5 id="1）查询参数"><a href="#1）查询参数" class="headerlink" title="1）查询参数"></a>1）查询参数</h5><p>@RequestParam，可设默认和非必填</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">spittles</span><span class="params">(@RequestParam(<span class="string">"max"</span>)</span> <span class="keyword">long</span> max, </span></span><br><span class="line"><span class="function">                              @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"count"</span>, defaultValue = <span class="string">"20"</span>)</span> <span class="keyword">int</span> count) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> spittleRepository.findSpittles(max, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）表单参数"><a href="#2）表单参数" class="headerlink" title="2）表单参数"></a>2）表单参数</h5><ul><li>“redirect:”前缀：解析为重定向的规则， 而不是视图的名称。</li><li>“forward:”前缀：请求将会前往（forward） 指定的 URL 路径， 而不再是重定向。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/register"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processRegistration</span><span class="params">(Spitter spitter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/spitter/"</span> + spitter.getUsername();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3）路径参数"><a href="#3）路径参数" class="headerlink" title="3）路径参数"></a>3）路径参数</h5><p>@PathVariable，如果函数参数和占位符名称相同，可省略注解的参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"abc/&#123;spittleId&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">showSpittle</span><span class="params">(@PathVariable(<span class="string">"spittleId"</span>)</span> <span class="keyword">long</span> spittleId,Model model) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-校验参数"><a href="#2-3-校验参数" class="headerlink" title="2.3 校验参数"></a>2.3 校验参数</h4><p>Java Validation API 定义了多个注解， 这些注解可以放到属性上，从而限制这些属性的值。</p><table><thead><tr><th>注 解</th><th>描 述</th></tr></thead><tbody><tr><td>@AssertFalse</td><td>所注解的元素必须是 Boolean 类型， 并且值为 false</td></tr><tr><td>@AssertTrue</td><td>所注解的元素必须是 Boolean 类型， 并且值为 true</td></tr><tr><td>@DecimalMax</td><td>所注解的元素必须是数字， 并且它的值要小于或等于给定的 BigDecimalString 值</td></tr><tr><td>@DecimalMin</td><td>所注解的元素必须是数字， 并且它的值要大于或等于给定的 BigDecimalString 值</td></tr><tr><td>@Digits</td><td>所注解的元素必须是数字， 并且它的值必须有指定的位数</td></tr><tr><td>@Future</td><td>所注解的元素的值必须是一个将来的日期</td></tr><tr><td>@Max</td><td>所注解的元素必须是数字， 并且它的值要小于或等于给定的值</td></tr><tr><td>@Min</td><td>所注解的元素必须是数字， 并且它的值要大于或等于给定的值</td></tr><tr><td>@NotNull</td><td>所注解元素的值必须不能为 null</td></tr><tr><td>@Null</td><td>所注解元素的值必须为 null</td></tr><tr><td>@Past</td><td>所注解的元素的值必须是一个已过去的日期</td></tr><tr><td>@Pattern</td><td>所注解的元素的值必须匹配给定的正则表达式</td></tr><tr><td>@Size</td><td>所注解的元素的值必须是 String、 集合或数组， 并且它的长度要符合给定的范围</td></tr></tbody></table><h5 id="校验-bean-对象"><a href="#校验-bean-对象" class="headerlink" title="校验 bean 对象"></a>校验 bean 对象</h5><p>@Valid 注解标注要检验的参数，Errors 参数要紧跟其后面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/register"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processRegistration</span><span class="params">(@Valid Spitter spitter, Errors errors)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(errors.hasErrors())&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/spitter/"</span> + spitter.getUsername();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-其他注解"><a href="#2-4-其他注解" class="headerlink" title="2.4 其他注解"></a>2.4 其他注解</h4><ul><li>@RequestBody：将方法参数直接绑定到 HTTP 请求 Body 上</li><li>@ResponseBody：将返回值作为响应体</li><li>@RestController：避免重复写 @ResponseBody</li><li>@CookieValue</li><li>@RequestHeader</li></ul><p>Spring 4.3 中引进了｛@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping｝ 来帮助简化常用的 HTTP 方法的映射 并更好地表达被注解方法的语义</p><ul><li>@GetMapping 是一个组合注解：是 @RequestMapping(method = RequestMethod.GET) 的缩写</li><li>@PostMapping 是一个组合注解：是 @RequestMapping(method = RequestMethod.POST) 的缩写</li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring RestTemplate</title>
      <link href="/2020/07/21/Spring/Web/Spring%20RestTemplate/"/>
      <url>/2020/07/21/Spring/Web/Spring%20RestTemplate/</url>
      
        <content type="html"><![CDATA[<p>RestTemplate 属于 Spring-Web，是 Spring 的同步客户端HTTP访问的中心类。简化了与 HTTP 服务器的通信，并应用了 RESTful 原则。</p><p>RestTemplate 默认依赖 JDK 的 HttpURLConnection 来建立 HTTP 连接。 可切换到使用不同的 HTTP 库，例如 Apache HttpComponents，Netty 和 OkHttp。</p><h3 id="1-组成"><a href="#1-组成" class="headerlink" title="1 组成"></a>1 组成</h3><p>RestTemplate 包含以下几个部分：</p><ul><li>HttpMessageConverter：对象转换器</li><li>ClientHttpRequestFactory：客户端连接器，默认是 JDK 的 HttpURLConnection</li><li>ResponseErrorHandler：异常处理</li><li>ClientHttpRequestInterceptor：请求拦截器</li></ul><p><img src="https://imine141.github.io/images/1545011851872.png" alt="img"></p><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2 初始化"></a>2 初始化</h3><p>初始化时，可以传入 ClientHttpRequestFactory，自定义参数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">RestTemplate restTemplate()&#123;</span><br><span class="line">    SimpleClientHttpRequestFactory requestFactory &#x3D; new SimpleClientHttpRequestFactory();</span><br><span class="line">    &#x2F;&#x2F;设置超时时间</span><br><span class="line">    requestFactory.setConnectTimeout(1000);</span><br><span class="line">    requestFactory.setReadTimeout(1000);</span><br><span class="line">    RestTemplate restTemplate &#x3D; new RestTemplate(requestFactory);</span><br><span class="line">    return restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RestTemplate restTemplate;</span><br></pre></td></tr></table></figure><h3 id="3-访问服务"><a href="#3-访问服务" class="headerlink" title="3 访问服务"></a>3 访问服务</h3><h4 id="3-1-HTTP-方法"><a href="#3-1-HTTP-方法" class="headerlink" title="3.1 HTTP 方法"></a>3.1 HTTP 方法</h4><p>使用 java.net.URI 代替 String 形式的 URI，不会被 URL 编码两次<br>以 get 和 post 为例，更多见 <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="noopener">官网api</a></p><h5 id="1）GET"><a href="#1）GET" class="headerlink" title="1）GET"></a>1）GET</h5><ul><li>getForObject()</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... urlVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; urlVariables)</span></span></span><br></pre></td></tr></table></figure><ul><li>getForEntity()</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(URI url,Class&lt;T&gt; responseType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(String url,Class&lt;T&gt; responseType,Object... uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(String url,Class&lt;T&gt; responseType,Map&lt;String,?&gt; uriVariables)</span></span></span><br></pre></td></tr></table></figure><h5 id="2）POST"><a href="#2）POST" class="headerlink" title="2）POST"></a>2）POST</h5><ul><li>postForObject()</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(URI url,Object request,Class&lt;T&gt; responseType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; T <span class="title">postForObject</span><span class="params">(String url,Object request,Class&lt;T&gt; responseType,Object... uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; T <span class="title">postForObject</span><span class="params">(String url,Object request,Class&lt;T&gt; responseType,Map&lt;String,?&gt; uriVariables)</span></span></span><br></pre></td></tr></table></figure><ul><li>postForEntity()</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(String url,@NullableObject request,Class&lt;T&gt; responseType,Object... uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(String url,Object request,Class&lt;T&gt; responseType,Map&lt;String,?&gt; uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(URI url,Object request,Class&lt;T&gt; responseType)</span></span></span><br></pre></td></tr></table></figure><h5 id="3）实例"><a href="#3）实例" class="headerlink" title="3）实例"></a>3）实例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.add(<span class="string">"X-Auth-Token"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">MultiValueMap&lt;String, String&gt; postParameters = <span class="keyword">new</span> LinkedMultiValueMap&lt;String, String&gt;();</span><br><span class="line">postParameters.add(<span class="string">"parameter1"</span>, <span class="string">"111"</span>);</span><br><span class="line">postParameters.add(<span class="string">"parameter2"</span>, <span class="string">"222"</span>);</span><br><span class="line">postParameters.add(<span class="string">"parameter3"</span>, <span class="string">"333"</span>);</span><br><span class="line"></span><br><span class="line">HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; requestEntity = <span class="keyword">new</span> HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(postParameters, headers);</span><br><span class="line"></span><br><span class="line">Object result = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    result = restTemplate.postForObject(<span class="string">"http://demo"</span>, requestEntity, ParseResultVo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (RestClientException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4 异常处理"></a>4 异常处理</h3><h5 id="1）捕获-HttpServerErrorException"><a href="#1）捕获-HttpServerErrorException" class="headerlink" title="1）捕获 HttpServerErrorException"></a>1）捕获 HttpServerErrorException</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> retryCount = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        responseEntity = restTemplate.exchange(requestEntity, String<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HttpServerErrorException e) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (retryCount == <span class="number">3</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> e;  </span><br><span class="line">        &#125;  </span><br><span class="line">        retryCount++;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）自定义异常处理"><a href="#2）自定义异常处理" class="headerlink" title="2）自定义异常处理"></a>2）自定义异常处理</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomErrorHandler</span> <span class="keyword">extends</span> <span class="title">DefaultResponseErrorHandler</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasError</span><span class="params">(ClientHttpResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleError</span><span class="params">(ClientHttpResponse response, HttpStatus statusCode)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(statusCode.isError())&#123;</span><br><span class="line">            <span class="keyword">switch</span> (statusCode.series()) &#123;</span><br><span class="line">                <span class="keyword">case</span> CLIENT_ERROR:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> HttpClientErrorException(statusCode, response.getStatusText(), response.getHeaders(), <span class="keyword">this</span>.getResponseBody(response), <span class="keyword">this</span>.getCharset(response));</span><br><span class="line">                <span class="keyword">case</span> SERVER_ERROR:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> HttpServerErrorException(statusCode, response.getStatusText(), response.getHeaders(), <span class="keyword">this</span>.getResponseBody(response), <span class="keyword">this</span>.getCharset(response));</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UnknownHttpStatusCodeException(statusCode.value(), response.getStatusText(), response.getHeaders(), <span class="keyword">this</span>.getResponseBody(response), <span class="keyword">this</span>.getCharset(response));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClientConfig</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();  </span><br><span class="line">        restTemplate.setErrorHandler(<span class="keyword">new</span> CustomErrorHandler());  </span><br><span class="line">        <span class="keyword">return</span> restTemplate;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-设置连接池"><a href="#5-设置连接池" class="headerlink" title="5 设置连接池"></a>5 设置连接池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClientConfig</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> ClientHttpRequestFactory <span class="title">httpRequestFactory</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient());  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate(httpRequestFactory());  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpClient <span class="title">httpClient</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Registry&lt;ConnectionSocketFactory&gt; registry = RegistryBuilder.&lt;ConnectionSocketFactory&gt; create()  </span><br><span class="line">        .register(<span class="string">"http"</span>, PlainConnectionSocketFactory.getSocketFactory())  </span><br><span class="line">        .register(<span class="string">"https"</span>, SSLConnectionSocketFactory.getSocketFactory())  </span><br><span class="line">        .build();  </span><br><span class="line">    PoolingHttpClientConnectionManager connectionManager = <span class="keyword">new</span> PoolingHttpClientConnectionManager(registry);  </span><br><span class="line">    connectionManager.setMaxTotal(<span class="number">200</span>);  </span><br><span class="line">    connectionManager.setDefaultMaxPerRoute(<span class="number">20</span>);  </span><br><span class="line">  </span><br><span class="line">    RequestConfig requestConfig = RequestConfig.custom()  </span><br><span class="line">        .setSocketTimeout(<span class="number">8000</span>)  </span><br><span class="line">        .setConnectTimeout(<span class="number">8000</span>)  </span><br><span class="line">        .setConnectionRequestTimeout(<span class="number">8000</span>)  </span><br><span class="line">        .build();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> HttpClientBuilder.create()  </span><br><span class="line">        .setDefaultRequestConfig(requestConfig)  </span><br><span class="line">        .setConnectionManager(connectionManager)  </span><br><span class="line">        .setConnectionManagerShared(<span class="keyword">true</span>)<span class="comment">//设置共享连接池</span></span><br><span class="line">        .build();  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-处理文件"><a href="#6-处理文件" class="headerlink" title="6 处理文件"></a>6 处理文件</h3><h4 id="6-1-发送文件"><a href="#6-1-发送文件" class="headerlink" title="6.1 发送文件"></a>6.1 发送文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MultiValueMap&lt;String, Object&gt; multiPartBody = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();  </span><br><span class="line">multiPartBody.add(<span class="string">"file"</span>, <span class="keyword">new</span> ClassPathResource(<span class="string">"/tmp/user.txt"</span>));  </span><br><span class="line">RequestEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; requestEntity = RequestEntity  </span><br><span class="line">        .post(uri)  </span><br><span class="line">        .contentType(MediaType.MULTIPART_FORM_DATA)  </span><br><span class="line">        .body(multiPartBody);</span><br></pre></td></tr></table></figure><h4 id="6-2-下载文件"><a href="#6-2-下载文件" class="headerlink" title="6.2 下载文件"></a>6.2 下载文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小文件  </span></span><br><span class="line">RequestEntity requestEntity = RequestEntity.get(uri).build();  </span><br><span class="line">ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; responseEntity = restTemplate.exchange(requestEntity, <span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line"><span class="keyword">byte</span>[] downloadContent = responseEntity.getBody();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 大文件  </span></span><br><span class="line">ResponseExtractor&lt;ResponseEntity&lt;File&gt;&gt; responseExtractor = <span class="keyword">new</span> ResponseExtractor&lt;ResponseEntity&lt;File&gt;&gt;() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;File&gt; <span class="title">extractData</span><span class="params">(ClientHttpResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        File rcvFile = File.createTempFile(<span class="string">"rcvFile"</span>, <span class="string">"zip"</span>);  </span><br><span class="line">        FileCopyUtils.copy(response.getBody(), <span class="keyword">new</span> FileOutputStream(rcvFile));  </span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(response.getStatusCode()).headers(response.getHeaders()).body(rcvFile);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">File getFile = <span class="keyword">this</span>.restTemplate.execute(targetUri, HttpMethod.GET, <span class="keyword">null</span>, responseExtractor);</span><br></pre></td></tr></table></figure><h3 id="7-Spring-Boot"><a href="#7-Spring-Boot" class="headerlink" title="7 Spring Boot"></a>7 Spring Boot</h3><p>RestTemplateBuilder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRestTemplateCustomizer</span> <span class="keyword">implements</span> <span class="title">RestTemplateCustomizer</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> RestTemplateBuilder()  </span><br><span class="line">                .detectRequestFactory(<span class="keyword">false</span>)  </span><br><span class="line">                .basicAuthorization(<span class="string">"username"</span>, <span class="string">"password"</span>)  </span><br><span class="line">                .uriTemplateHandler(<span class="keyword">new</span> OkHttp3ClientHttpRequestFactory())  </span><br><span class="line">                .errorHandler(<span class="keyword">new</span> CustomResponseErrorHandler())  </span><br><span class="line">                .configure(restTemplate);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单独设置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestClientService</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRestClientService</span><span class="params">(RestTemplateBuilder restTemplateBuilder)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplateBuilder  </span><br><span class="line">            .basicAuthorization(<span class="string">"username"</span>, <span class="string">"password"</span>)  </span><br><span class="line">            .setConnectTimeout(<span class="number">3000</span>)  </span><br><span class="line">            .setReadTimeout(<span class="number">5000</span>)  </span><br><span class="line">            .rootUri(<span class="string">"http://api.example.com/"</span>)  </span><br><span class="line">            .errorHandler(<span class="keyword">new</span> CustomResponseErrorHandler())  </span><br><span class="line">            .additionalMessageConverters(<span class="keyword">new</span> CustomHttpMessageConverter())  </span><br><span class="line">            .uriTemplateHandler(<span class="keyword">new</span> OkHttp3ClientHttpRequestFactory())  </span><br><span class="line">            .build();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">site</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://rensanning.iteye.com/"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-参数设置"><a href="#8-参数设置" class="headerlink" title="8 参数设置"></a>8 参数设置</h3><h4 id="8-1-指定转换器"><a href="#8-1-指定转换器" class="headerlink" title="8.1 指定转换器"></a>8.1 指定转换器</h4><p>RestTemplate 默认注册了一组 HttpMessageConverter 用来处理一些不同的 contentType 的请求。</p><p>StringHttpMessageConverter 来处理 text/plain;</p><p>MappingJackson2HttpMessageConverter 来处理 application/json;</p><p>MappingJackson2XmlHttpMessageConverter 来处理 application/xml。</p><p>可实现 org.springframework.http.converter.HttpMessageConverter 接口自己写一个转换器。</p><p>替换例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取RestTemplate默认配置好的所有转换器</span></span><br><span class="line">List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters();</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的MappingJackson2HttpMessageConverter在第7个 先把它移除掉</span></span><br><span class="line">messageConverters.remove(<span class="number">6</span>); </span><br><span class="line"><span class="comment">//添加上GSON的转换器</span></span><br><span class="line">messageConverters.add(<span class="number">6</span>, <span class="keyword">new</span> GsonHttpMessageConverter());</span><br></pre></td></tr></table></figure><h4 id="8-2-设置底层连接方式"><a href="#8-2-设置底层连接方式" class="headerlink" title="8.2 设置底层连接方式"></a>8.2 设置底层连接方式</h4><p>通过构造参数设置，以切换 HttpClient 为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成一个设置了连接超时时间、请求超时时间、异常最大重试次数的 httpClient</span></span><br><span class="line">RequestConfig config = RequestConfig.custom().setConnectionRequestTimeout(<span class="number">10000</span>).setConnectTimeout(<span class="number">10000</span>).setSocketTimeout(<span class="number">30000</span>).build();</span><br><span class="line"></span><br><span class="line">HttpClientBuilder builder = HttpClientBuilder.create().setDefaultRequestConfig(config).setRetryHandler(<span class="keyword">new</span> DefaultHttpRequestRetryHandler(<span class="number">5</span>, <span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">HttpClient httpClient = builder.build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用httpClient创建一个 ClientHttpRequestFactory 的实现</span></span><br><span class="line">ClientHttpRequestFactory requestFactory = <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClientHttpRequestFactory作为参数构造一个使用作为底层的 RestTemplate</span></span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate(requestFactory);</span><br></pre></td></tr></table></figure><h4 id="8-3-设置拦截器"><a href="#8-3-设置拦截器" class="headerlink" title="8.3 设置拦截器"></a>8.3 设置拦截器</h4><p>拦截器需要我们实现 org.springframework.http.client.ClientHttpRequestInterceptor 接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenInterceptor</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestInterceptor</span></span>&#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(HttpRequest request, <span class="keyword">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        String checkTokenUrl = request.getURI().getPath(); </span><br><span class="line">        <span class="comment">//请求方法名 POST、GET等</span></span><br><span class="line">        String methodName = request.getMethod().name(); </span><br><span class="line">        <span class="comment">//请求内容</span></span><br><span class="line">        String requestBody = <span class="keyword">new</span> String(body); </span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">        <span class="keyword">return</span> execution.execute(request, body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 RestTemplate 实例的时候，添加拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line"><span class="comment">//向restTemplate中添加自定义的拦截器</span></span><br><span class="line">restTemplate.getInterceptors().add(<span class="keyword">new</span> TokenInterceptor());</span><br></pre></td></tr></table></figure><h4 id="8-4-使用-Proxy"><a href="#8-4-使用-Proxy" class="headerlink" title="8.4 使用 Proxy"></a>8.4 使用 Proxy</h4><h5 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SimpleClientHttpRequestFactory requestFactory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</span><br><span class="line">    Proxy proxy = <span class="keyword">new</span> Proxy(Proxy.Type.HTTP, <span class="keyword">new</span> InetSocketAddress(<span class="string">"your.proxy.server"</span>, <span class="number">8080</span>));</span><br><span class="line">    requestFactory.setProxy(proxy);</span><br><span class="line">    RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate(requestFactory);</span><br><span class="line">    <span class="keyword">return</span> restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="System-properties"><a href="#System-properties" class="headerlink" title="System properties"></a>System properties</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = System.getProperties();</span><br><span class="line">props.put(<span class="string">"https.proxyHost"</span>, <span class="string">"your.proxy.server"</span>);</span><br><span class="line">props.put(<span class="string">"https.proxyPort"</span>, <span class="string">"8080"</span>);</span><br><span class="line">props.put(<span class="string">"http.proxyHost"</span>, <span class="string">"your.proxy.server"</span>);</span><br><span class="line">props.put(<span class="string">"http.proxyPort"</span>, <span class="string">"8080"</span>);</span><br><span class="line"></span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">String tt = restTemplate.getForObject(<span class="string">"https://baike.baidu.com/"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(tt);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域</title>
      <link href="/2020/07/21/Spring/Web/%E8%B7%A8%E5%9F%9F/"/>
      <url>/2020/07/21/Spring/Web/%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>常用的跨域解决方案有 JSONP 和 CORS， spingboot 2.0 开始不推荐使用 JSONP。</p><h2 id="1-CORS"><a href="#1-CORS" class="headerlink" title="1 CORS"></a>1 CORS</h2><h3 id="1-1-属性含义"><a href="#1-1-属性含义" class="headerlink" title="1.1 属性含义"></a>1.1 属性含义</h3><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>value</td><td>指定所支持域的集合， 表示所有域都支持，默认值为 。这些值对应于 HTTP 请求头中的 Access-Control-Allow-Origin</td></tr><tr><td>origins</td><td>@AliasFor(“value”)，与 value 属性一样</td></tr><tr><td>allowedHeaders</td><td>允许请求头中的 headers，在预检请求 Access-Control-Allow-Headers 响应头中展示</td></tr><tr><td>exposedHeaders</td><td>响应头中允许访问的 headers，在实际请求的 Access-Control-Expose-Headers</td></tr><tr><td>methods</td><td>支持的 HTTP 请求方法列表，默认和 Controller 中的方法上标注的一致。</td></tr><tr><td>allowCredentials</td><td>表示浏览器在跨域请求中是否携带凭证，比如 cookies。在预检请求的 Access-Control-Allow-Credentials</td></tr><tr><td>maxAge</td><td>预检请求响应的最大缓存时间，单位为秒。在预检请求的 Access-Control-Max-Age 响应头中展示</td></tr></tbody></table><h3 id="1-2-实现方法"><a href="#1-2-实现方法" class="headerlink" title="1.2 实现方法"></a>1.2 实现方法</h3><h4 id="1）-CrossOrigin-注解"><a href="#1）-CrossOrigin-注解" class="headerlink" title="1） CrossOrigin 注解"></a>1） CrossOrigin 注解</h4><p>在 Spring Boot 中为我们提供了一个注解 @CrossOrigin 来实现跨域，这个注解可以加在类或者方法上。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/xxx"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@CrossOrigin</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">xxx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"xxx"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）实现-WebMvcConfigurer-接口"><a href="#2）实现-WebMvcConfigurer-接口" class="headerlink" title="2）实现 WebMvcConfigurer 接口"></a>2）实现 WebMvcConfigurer 接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"GET"</span>, <span class="string">"HEAD"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>, <span class="string">"OPTIONS"</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">168000</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）过滤器"><a href="#3）过滤器" class="headerlink" title="3）过滤器"></a>3）过滤器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        config.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, config);</span><br><span class="line">        FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean(<span class="keyword">new</span> CorsFilter(source));</span><br><span class="line">        bean.setOrder(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Jsonp"><a href="#2-Jsonp" class="headerlink" title="2 Jsonp"></a>2 Jsonp</h2><blockquote><p>spingboot2.0 已不支持 JSONP</p></blockquote><p>通过 jsonp 调用，对格式重新封装，解决前端跨域。<br>如：请求<code>http://xxxx?&amp;callback=exec</code>, 那么返回的jsonp格式为<code>exec({&quot;code&quot;:0, &quot;message&quot;:&quot;success&quot;});</code>。</p><p>继承<code>AbstractJsonpResponseBodyAdvice</code>，加入<code>@ControllerAdvice</code>注解,basePackages 标识要被处理的 controller。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span>(basePackages = <span class="string">"xxx.controller"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonpAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractJsonpResponseBodyAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] jsonpQueryParamNames;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonpAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"callback"</span>, <span class="string">"jsonp"</span>);</span><br><span class="line">        <span class="keyword">this</span>.jsonpQueryParamNames = <span class="keyword">new</span> String[]&#123;<span class="string">"callback"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeBodyWriteInternal</span><span class="params">(MappingJacksonValue bodyContainer, MediaType contentType, MethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HttpServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest();</span><br><span class="line">　　　　　</span><br><span class="line">　　　　<span class="comment">//如果不存在callback这个请求参数，直接返回，不需要处理为jsonp</span></span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.isEmpty(servletRequest.getParameter(<span class="string">"callback"</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">　　　　<span class="comment">//按设定的请求参数处理返回结果为jsonp格式</span></span><br><span class="line">        <span class="keyword">for</span> (String name : <span class="keyword">this</span>.jsonpQueryParamNames) &#123;</span><br><span class="line">            String value = servletRequest.getParameter(name);</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                MediaType contentTypeToUse = getContentType(contentType, request, response);</span><br><span class="line">                response.getHeaders().setContentType(contentTypeToUse);</span><br><span class="line">                bodyContainer.setJsonpFunction(value);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ehcache 3.8 简单持久化</title>
      <link href="/2020/07/20/Spring/Data/Ehcache%203.8%20%E7%AE%80%E5%8D%95%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2020/07/20/Spring/Data/Ehcache%203.8%20%E7%AE%80%E5%8D%95%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1 引入依赖"></a>1 引入依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.ehcache&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ehcache&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.8.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-持久化配置"><a href="#2-持久化配置" class="headerlink" title="2 持久化配置"></a>2 持久化配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EhcacheHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CacheManager cacheManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CacheManager <span class="title">getCacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isAvailable())&#123;</span><br><span class="line">            cacheManager = CacheManagerBuilder.newCacheManagerBuilder()</span><br><span class="line">                    .with(CacheManagerBuilder.persistence(<span class="keyword">new</span> File(<span class="string">"java.io.tmpdir"</span>, <span class="string">"EhcacheData"</span>)))</span><br><span class="line">                    .withCache(<span class="string">"xxxCache"</span>,</span><br><span class="line">                            CacheConfigurationBuilder.newCacheConfigurationBuilder(Long<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">ResourcePoolsBuilder</span>.<span class="title">newResourcePoolsBuilder</span>()</span></span><br><span class="line"><span class="class">                                            .<span class="title">heap</span>(2000, <span class="title">EntryUnit</span>.<span class="title">ENTRIES</span>)</span></span><br><span class="line"><span class="class">                                            .<span class="title">offheap</span>(1, <span class="title">MemoryUnit</span>.<span class="title">MB</span>)</span></span><br><span class="line"><span class="class">                                            .<span class="title">disk</span>(20, <span class="title">MemoryUnit</span>.<span class="title">MB</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                            )</span></span><br><span class="line"><span class="class">                    ).<span class="title">build</span>(<span class="title">true</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isAvailable())&#123;</span><br><span class="line">            cacheManager.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> != cacheManager &amp;&amp; cacheManager.getStatus().equals(Status.AVAILABLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3 使用示例"></a>3 使用示例</h3><p>存放</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CacheManager persistentCacheManager = EhcacheHelper.getCacheManager();</span><br><span class="line">    Cache&lt;Long, String&gt; persistentCache = persistentCacheManager.getCache(<span class="string">"threeTieredCache"</span>, Long<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i ++)&#123;</span><br><span class="line">        persistentCache.put(i, <span class="string">"这是第:-"</span> + i + <span class="string">"-条信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    persistentCache.forEach( cc -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"persistentCache,主键：&#123;&#125;，值：&#123;&#125;"</span>,cc.getKey(),cc.getValue());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    persistentCacheManager.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CacheManager persistentCacheManager = EhcacheHelper.getCacheManager();</span><br><span class="line">    Cache&lt;Long, String&gt; persistentCache = persistentCacheManager.getCache(<span class="string">"threeTieredCache"</span>, Long<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Iterator&lt;Cache.Entry&lt;Long,String&gt;&gt; iterator = persistentCache.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        ++ count;</span><br><span class="line">        Cache.Entry&lt;Long,String&gt; entry = iterator.next();</span><br><span class="line">        log.info(<span class="string">"threeTieredCache,主键：&#123;&#125;，值：&#123;&#125;"</span>,entry.getKey(),entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"信息的总条数为：&#123;&#125;"</span>,count);</span><br><span class="line">    persistentCacheManager.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-关闭钩子"><a href="#4-关闭钩子" class="headerlink" title="4 关闭钩子"></a>4 关闭钩子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SkuSyncApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 hook 线程添加到运行时环境中去</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                EhcacheHelper.close();</span><br><span class="line">                System.out.println(<span class="string">"ShutdownHook ==&gt; Ehcache closed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transaction</title>
      <link href="/2020/07/20/Spring/Data/Transaction/"/>
      <url>/2020/07/20/Spring/Data/Transaction/</url>
      
        <content type="html"><![CDATA[<p>Spring 事务的本质是数据库对事务的支持。</p><p><code>@EnableTransactionManagement</code> 开启对事务注解的解析</p><h3 id="1-声明式事务"><a href="#1-声明式事务" class="headerlink" title="1 声明式事务"></a>1 声明式事务</h3><h4 id="1-1-Transactional-注解"><a href="#1-1-Transactional-注解" class="headerlink" title="1.1 @Transactional 注解"></a>1.1 @Transactional 注解</h4><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>事务管理器</td></tr><tr><td>propagation</td><td>Propagation</td><td>传播级别</td></tr><tr><td>isolation</td><td>Isolation</td><td>隔离级别</td></tr><tr><td>readOnly</td><td>boolean</td><td>读/写与只读事务</td></tr><tr><td>timeout</td><td>int</td><td>事务超时(秒)</td></tr><tr><td>rollbackFor</td><td>Class</td><td>触发事务回滚的类，默认只对未检查异常有效</td></tr><tr><td>noRollbackFor</td><td>Class</td><td>设置不需要进行回滚的异常类数组</td></tr></tbody></table><h4 id="1-2-Transactional-特性"><a href="#1-2-Transactional-特性" class="headerlink" title="1.2 Transactional 特性"></a>1.2 Transactional 特性</h4><ul><li>类上添加 @Transactional，在每个方法单开一个事务，管理方式相同。</li><li>@Transactional 注解只在 public 方法上起作用。</li><li>默认只对未检查异常回滚</li><li>只读事务只在事务启动时应用，否则即使配置也会被忽略。</li></ul><h4 id="1-3-传播级别"><a href="#1-3-传播级别" class="headerlink" title="1.3 传播级别"></a>1.3 传播级别</h4><ul><li>PROPAGATION_REQUIRED<br>（默认设置）存在则加入，没有则创建</li><li>PROPAGATION_REQUIRES_NEW<br>创建新事务，如当前事务存在，则挂起当前事务</li><li>PROPAGATION_SUPPORTS<br>存在则加入；没有则以非事务的方式运行</li><li>PROPAGATION_NOT_SUPPORTED<br>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>PROPAGATION_MANDATORY<br>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>PROPAGATION_NEVER<br>以非事务方式运行，如果当前存在事务，则抛出异常</li><li>PROPAGATION_NESTED<br>存在则创建嵌套事务；没有则创建</li></ul><h4 id="1-4-隔离级别"><a href="#1-4-隔离级别" class="headerlink" title="1.4 隔离级别"></a>1.4 隔离级别</h4><ul><li>ISOLATION_DEFAULT<br>（默认设置）使用底层数据库的默认隔离级别。</li><li>ISOLATION_READ_UNCOMMITTED<br>可读取修改还没有提交的数据</li><li>ISOLATION_READ_COMMITTED<br>只能读取已经提交的数据。推荐。</li><li>ISOLATION_REPEATABLE_READ<br>可重复读，每次返回相同。</li><li>ISOLATION_SERIALIZABLE<br>逐个执行事务，性能低。</li></ul><h3 id="2-编程式事务"><a href="#2-编程式事务" class="headerlink" title="2 编程式事务"></a>2 编程式事务</h3><h4 id="2-1-TransactionTemplate"><a href="#2-1-TransactionTemplate" class="headerlink" title="2.1 TransactionTemplate"></a>2.1 TransactionTemplate</h4><p>在 doIntransaction 里处理逻辑。如果出异常了，就执行 isRollbackOnly 方法进行回滚。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">transactionTemplate.execute((TransactionStatus transactionStatus) -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        transactionStatus.isRollbackOnly();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="2-2-TransactionManager"><a href="#2-2-TransactionManager" class="headerlink" title="2.2 TransactionManager"></a>2.2 TransactionManager</h4><p>手动 commit，异常就 rollback</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    userRepository.save(user);</span><br><span class="line">    transactionManager.commit(status);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    transactionManager.rollback(status);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic DataSource</title>
      <link href="/2020/07/19/Spring/Data/Dynamic%20DataSource/"/>
      <url>/2020/07/19/Spring/Data/Dynamic%20DataSource/</url>
      
        <content type="html"><![CDATA[<h2 id="一、AOP-实现"><a href="#一、AOP-实现" class="headerlink" title="一、AOP 实现"></a>一、AOP 实现</h2><p>AOP 实现多数据源，可读写分离</p><h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1 配置文件"></a>1 配置文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dynamic-db.master.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span> </span>= com.mysql.jdbc.Driver</span><br><span class="line">dynamic-db.master.jdbc-url = jdbc:mysql:<span class="comment">//somehost:3306/sometable?characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line">dynamic-db.master.username = xxx</span><br><span class="line">dynamic-db.master.password = xxx</span><br><span class="line"></span><br><span class="line">dynamic-db.slave.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span> </span>= com.mysql.jdbc.Driver</span><br><span class="line">dynamic-db.slave.jdbc-url = jdbc:mysql:<span class="comment">//somehost:3306/sometable?characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line">dynamic-db.slave.username = xxx</span><br><span class="line">dynamic-db.slave.password = xxx</span><br></pre></td></tr></table></figure><h3 id="2-ContextHolder"><a href="#2-ContextHolder" class="headerlink" title="2 ContextHolder"></a>2 ContextHolder</h3><p>管理 DataSource</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceContextHolder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储当前 DataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; CONTEXT_HOLDER = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有 DataSource 的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; dataSourceKeys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换 DataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataSourceKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        CONTEXT_HOLDER.set(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前 DataSource，默认为 master</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataSourceKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String key = CONTEXT_HOLDER.get();</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="string">"master"</span> : key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空当前 DataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDataSourceKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CONTEXT_HOLDER.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否当前 DataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containDataSourceKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataSourceKeys.contains(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-注册动态配置"><a href="#3-注册动态配置" class="headerlink" title="3 注册动态配置"></a>3 注册动态配置</h3><p>继承 AbstractRoutingDataSource</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicRoutingDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将当前DataSource加入应用上下文</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DynamicDataSourceContextHolder.getDataSourceKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-加载配置"><a href="#4-加载配置" class="headerlink" title="4 加载配置"></a>4 加载配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"master"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"dynamic-db.master"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">master</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"slave"</span>)</span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"dynamic-db.slave"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">slave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置动态 DataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dynamicDataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dynamicDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DynamicRoutingDataSource dynamicRoutingDataSource = <span class="keyword">new</span> DynamicRoutingDataSource();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//所有DataSource</span></span><br><span class="line">        Map&lt;Object, Object&gt; dataSourceMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        dataSourceMap.put(<span class="string">"master"</span>, master());</span><br><span class="line">        dataSourceMap.put(<span class="string">"slave"</span>, slave());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置默认DataSource</span></span><br><span class="line">        dynamicRoutingDataSource.setDefaultTargetDataSource(master());</span><br><span class="line">        <span class="comment">//设置所有DataSource</span></span><br><span class="line">        dynamicRoutingDataSource.setTargetDataSources(dataSourceMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将所有DataSource的key放入，以供判断</span></span><br><span class="line">        DynamicDataSourceContextHolder.dataSourceKeys.addAll(dataSourceMap.keySet());</span><br><span class="line">        <span class="keyword">return</span> dynamicRoutingDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据源添加到 SqlSession 工厂；获取 mybatis 配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"mybatis"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title">sqlSessionFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dynamicDataSource());</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据源添加到事物管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dynamicDataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-注解"><a href="#5-注解" class="headerlink" title="5 注解"></a>5 注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TargetDataSource &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Aspect"><a href="#6-Aspect" class="headerlink" title="6 Aspect"></a>6 Aspect</h3><p>要用 @Order(0) 注解让这个切面的优先级最高，以免被其他切面（如事务管理器）影响</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//切换</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"@annotation(targetDataSource))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchDataSource</span><span class="params">(JoinPoint point, TargetDataSource targetDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DynamicDataSourceContextHolder.containDataSourceKey(targetDataSource.value()))&#123;</span><br><span class="line">            DynamicDataSourceContextHolder.setDataSourceKey(targetDataSource.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还原</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"@annotation(targetDataSource))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreDataSource</span><span class="params">(JoinPoint point, TargetDataSource targetDataSource)</span> </span>&#123;</span><br><span class="line">        DynamicDataSourceContextHolder.clearDataSourceKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-实例"><a href="#7-实例" class="headerlink" title="7 实例"></a>7 实例</h3><p>读写分离</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterMsgMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@InsertProvider</span>(type = InterMsgProvider<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"insert"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(InterMsg interMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TargetDataSource</span>(<span class="string">"slave"</span>)</span><br><span class="line">    <span class="meta">@SelectProvider</span>(type = InterMsgProvider<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"findMessages"</span>)</span><br><span class="line">    <span class="function">List&lt;InterMsg&gt; <span class="title">findMessages</span><span class="params">(Long userId, Integer limit, Long lastId, Long currentTime)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、普通配置"><a href="#二、普通配置" class="headerlink" title="二、普通配置"></a>二、普通配置</h2><h3 id="1-配置文件-1"><a href="#1-配置文件-1" class="headerlink" title="1 配置文件"></a>1 配置文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dynamic-db.master.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span> </span>= com.mysql.jdbc.Driver</span><br><span class="line">dynamic-db.master.jdbc-url = jdbc:mysql:<span class="comment">//somehost:3306/sometable?characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line">dynamic-db.master.username = xxx</span><br><span class="line">dynamic-db.master.password = xxx</span><br><span class="line"></span><br><span class="line">dynamic-db.slave.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span> </span>= com.mysql.jdbc.Driver</span><br><span class="line">dynamic-db.slave.jdbc-url = jdbc:mysql:<span class="comment">//somehost:3306/sometable?characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line">dynamic-db.slave.username = xxx</span><br><span class="line">dynamic-db.slave.password = xxx</span><br></pre></td></tr></table></figure><h3 id="2-DataSourceConfig"><a href="#2-DataSourceConfig" class="headerlink" title="2 DataSourceConfig"></a>2 DataSourceConfig</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开启 数据库下划线转驼峰</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>) <span class="comment">//默认单例会使多数据源失效</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"mybatis.configuration"</span>)</span><br><span class="line">    <span class="keyword">public</span> org.apache.ibatis.session.<span class="function">Configuration <span class="title">globalConfiguration</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"masterDataSource"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"dynamic-db.master"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">master</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"slaveDataSource"</span>)</span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"dynamic-db.slave"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">slave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多数据源事务管理</span></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"tranMagMaster"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">bfTransactionManager</span><span class="params">(@Qualifier(<span class="string">"masterDataSource"</span>)</span>DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"tranMagSlave"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">bfscrmTransactionManager</span><span class="params">(@Qualifier(<span class="string">"slaveDataSource"</span>)</span>DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-JdbcTemplatesConfig"><a href="#3-JdbcTemplatesConfig" class="headerlink" title="3 JdbcTemplatesConfig"></a>3 JdbcTemplatesConfig</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplatesConfig</span> <span class="keyword">extends</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//支持JdbcTemplate实现多数据源</span></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"masterJdbcTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">masterJdbcTemplate</span><span class="params">(@Qualifier(<span class="string">"masterDataSource"</span>)</span> DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"slaveJdbcTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">slaveJdbcTemplate</span><span class="params">(@Qualifier(<span class="string">"slaveDataSource"</span>)</span> DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-MybatisConfigMaster"><a href="#3-MybatisConfigMaster" class="headerlink" title="3 MybatisConfigMaster"></a>3 MybatisConfigMaster</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.xxx.mapper.master"</span>, </span><br><span class="line">        sqlSessionTemplateRef = <span class="string">"masterSqlSessionTemplate"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfigMaster</span> <span class="keyword">extends</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionFactory <span class="title">masterSqlSessionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">            sqlSessionFactoryBean.setConfiguration(globalConfiguration());</span><br><span class="line">            sqlSessionFactoryBean.setDataSource(masterDataSource());</span><br><span class="line">            sqlSessionFactory = sqlSessionFactoryBean.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionTemplate <span class="title">masterSqlSessionTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(masterSqlSessionFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-MybatisConfigSlave"><a href="#4-MybatisConfigSlave" class="headerlink" title="4 MybatisConfigSlave"></a>4 MybatisConfigSlave</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.xxx.mapper.slave"</span>, </span><br><span class="line">        sqlSessionTemplateRef = <span class="string">"slaveSqlSessionTemplate"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfigSlave</span> <span class="keyword">extends</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionFactory <span class="title">slaveSqlSessionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">            sqlSessionFactoryBean.setConfiguration(globalConfiguration());</span><br><span class="line">            sqlSessionFactoryBean.setDataSource(slaveDataSource());</span><br><span class="line">            sqlSessionFactory = sqlSessionFactoryBean.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionTemplate <span class="title">slaveSqlSessionTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(slaveSqlSessionFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-使用"><a href="#5-使用" class="headerlink" title="5 使用"></a>5 使用</h3><p>在 @MapperScan 配置的目录下写 mapper 就行了</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cache</title>
      <link href="/2020/07/19/Spring/Data/Spring%20Cache/"/>
      <url>/2020/07/19/Spring/Data/Spring%20Cache/</url>
      
        <content type="html"><![CDATA[<p>Spring 自身并没有实现缓存解决方案， 但是它对缓存功能提供了声明式的支持， 能够与多种流行的缓存实现进行集成。</p><p>Spring 的缓存抽象在很大程度上是围绕切面构建的。 在 Spring 中启用缓存时，会创建一个切面， 它触发一个或更多的 Spring 的缓存注解。</p><h3 id="1-启用对缓存的支持"><a href="#1-启用对缓存的支持" class="headerlink" title="1 启用对缓存的支持"></a>1 启用对缓存的支持</h3><p>配置类上添加<code>@EnableCaching</code>启用 Spring 对注解驱动缓存的支持。</p><p>在方法上添加<code>@Cacheable</code>和<code>@CacheEvict</code>注解使用 Spring 的缓存抽象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentMapCacheManager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-配置缓存管理器"><a href="#1-1-配置缓存管理器" class="headerlink" title="1.1 配置缓存管理器"></a>1.1 配置缓存管理器</h4><p>缓存管理器是 Spring 缓存抽象的核心， 它能够与多个流行的缓存实现进行集成。</p><p>Spring 3.1 内置五个缓存管理器实现</p><ul><li>SimpleCacheManager</li><li>NoOpCacheManager</li><li>ConcurrentMapCacheManager</li><li>CompositeCacheManager</li><li>EhCacheCacheManager</li></ul><p>Spring Data 又提供了两个缓存管理器：</p><ul><li>RedisCacheManager（来自于 Spring Data Redis 项目）</li><li>GemfireCacheManager（来自于 Spring Data GemFire 项目）</li></ul><h5 id="1）使用单个"><a href="#1）使用单个" class="headerlink" title="1）使用单个"></a>1）使用单个</h5><p>Redis 可以用来为 Spring 缓存抽象机制存储缓存条目， Spring Data Redis 提供了 RedisCacheManager， 这是 CacheManager 的一个实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisCacheManager(redisTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JedisConnectionFactory jedisConnectionFactory = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">        jedisConnectionFactory.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> jedisConnectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisCF)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, String&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;String, String&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisCF);</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）使用多个"><a href="#2）使用多个" class="headerlink" title="2）使用多个"></a>2）使用多个</h5><p>CompositeCacheManager 要通过一个或更多的缓存管理器来进行配置， 它会迭代这些缓存管理器， 以查找之前所缓存的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        net.sf.ehcache.CacheManager cm,</span></span></span><br><span class="line"><span class="function"><span class="params">        javax.cache.CacheManager jcm)</span> </span>&#123;</span><br><span class="line">    CompositeCacheManager cacheManager = <span class="keyword">new</span> CompositeCacheManager();</span><br><span class="line">    List&lt;CacheManager&gt; managers = <span class="keyword">new</span> ArrayList&lt;CacheManager&gt;();</span><br><span class="line">    managers.add(<span class="keyword">new</span> JCacheCacheManager(jcm));</span><br><span class="line">    managers.add(<span class="keyword">new</span> EhCacheCacheManager(cm))</span><br><span class="line">    managers.add(<span class="keyword">new</span> RedisCacheManager(redisTemplate()));</span><br><span class="line">    cacheManager.setCacheManagers(managers);</span><br><span class="line">    <span class="keyword">return</span> cacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-为方法添加注解以支持缓存"><a href="#2-为方法添加注解以支持缓存" class="headerlink" title="2 为方法添加注解以支持缓存"></a>2 为方法添加注解以支持缓存</h3><p>所有注解都能运用在方法或类上。 放在类上时， 缓存行为会应用到这个类的所有方法上。</p><table><thead><tr><th>注 解</th><th>描 述</th></tr></thead><tbody><tr><td>@Cacheable</td><td>（读）调用前，先在缓存中查找方法的返回值。如有则返回，否则调用，返回值会放到缓存之中</td></tr><tr><td>@CachePut</td><td>（写）方法始终被调用，返回值放到缓存中</td></tr><tr><td>@CacheEvict</td><td>（删）在缓存中清除一个或多个条目</td></tr><tr><td>@Caching</td><td>这是一个分组的注解， 能够同时应用多个其他的缓存注解</td></tr></tbody></table><h4 id="2-1-填充缓存"><a href="#2-1-填充缓存" class="headerlink" title="2.1 填充缓存"></a>2.1 填充缓存</h4><p>@Cacheable 和 @CachePut 都有一个名 value 属性，缓存名称</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(<span class="string">"spittleCache"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(</span><br><span class="line">            SELECT_SPITTLE_BY_ID,</span><br><span class="line">            <span class="keyword">new</span> SpittleRowMapper(),</span><br><span class="line">            id);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (EmptyResultDataAccessException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1）将值放到缓存之中"><a href="#1）将值放到缓存之中" class="headerlink" title="1）将值放到缓存之中"></a>1）将值放到缓存之中</h5><p>有 @CachePut 注解的方法始终都会被调用， 而且它的返回值也会放到缓存中。</p><p>适合用在保存、修改操作上，即刻缓存。</p><h5 id="2）自定义缓存-key"><a href="#2）自定义缓存-key" class="headerlink" title="2）自定义缓存 key"></a>2）自定义缓存 key</h5><p>@Cacheable 和 @CachePut 都有一个名为 key 属性， 这个属性能够替换默认的 key， 它是通过一个 SpEL 表达式计算得到的。</p><p>在为缓存编写 SpEL 表达式的时候， Spring 暴露了一些很有用的元数据。</p><table><thead><tr><th>表 达 式</th><th>描 述</th></tr></thead><tbody><tr><td>#root.args</td><td>传递给缓存方法的参数， 形式为数组</td></tr><tr><td>#root.caches</td><td>该方法执行时所对应的缓存， 形式为数组</td></tr><tr><td>#root.target</td><td>目标对象#root.targetClass 目标对象的类， 是#root.target.class的简写形式</td></tr><tr><td>#root.method</td><td>缓存方法</td></tr><tr><td>#root.methodName</td><td>缓存方法的名字， 是#root.method.name的简写形式</td></tr><tr><td>#result</td><td>方法调用的返回值（不能用在@Cacheable注解上）</td></tr><tr><td>#Argument</td><td>任意的方法参数名（如#argName） 或参数索引（如#a0或#p0）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CachePut</span>(value=<span class="string">"spittleCache"</span>, key=<span class="string">"#result.id"</span>)</span><br><span class="line"><span class="function">Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="3）条件化缓存"><a href="#3）条件化缓存" class="headerlink" title="3）条件化缓存"></a>3）条件化缓存</h5><p>@Cacheable 和 @CachePut 提供了两个属性用以实现条件化缓存： unless 和 condition。</p><p>unless 为 true 阻止添加到缓存中，condition 为 false 缓存被禁用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value=<span class="string">"spittleCache"</span> unless=<span class="string">"#result.message.contains('NoCache')"</span>)</span><br><span class="line"><span class="function">Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="2-2-移除缓存条目"><a href="#2-2-移除缓存条目" class="headerlink" title="2.2 移除缓存条目"></a>2.2 移除缓存条目</h4><p>带有 @CacheEvict 注解的方法被调用，在缓存中移除。</p><p>适用于删除操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheEvict</span>(<span class="string">"spittleCache"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">long</span> spittleId)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data MongoDB</title>
      <link href="/2020/07/18/Spring/Data/Spring%20Data%20MongoDB/"/>
      <url>/2020/07/18/Spring/Data/Spring%20Data%20MongoDB/</url>
      
        <content type="html"><![CDATA[<p>文档数据库适合处理没什么关联关系的独立实体</p><p>Spring Data MongoDB 提供了三种方式在 Spring 应用中使用 MongoDB：</p><ul><li>通过注解实现对象-文档映射；</li><li>使用 MongoTemplate 实现基于模板的数据库访问；</li><li>自动化的运行时 Repository 生成功能。</li></ul><h3 id="1-启用-MongoDB"><a href="#1-启用-MongoDB" class="headerlink" title="1 启用 MongoDB"></a>1 启用 MongoDB</h3><p>@EnableMongoRepositories 注解启用 MongoDB</p><h4 id="1-1-方法一"><a href="#1-1-方法一" class="headerlink" title="1.1 方法一"></a>1.1 方法一</h4><p>MongoFactoryBean、MongoTemplate</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories</span>(basePackages=<span class="string">"orders.db"</span>)<span class="comment">//Enable MongoDB repositories</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//MongoClient bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MongoFactoryBean <span class="title">mongo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MongoFactoryBean mongo = <span class="keyword">new</span> MongoFactoryBean();</span><br><span class="line">        mongo.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="keyword">return</span> mongo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//MongoTemplate bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MongoOperations <span class="title">mongoTemplate</span><span class="params">(Mongo mongo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MongoTemplate(mongo, <span class="string">"OrdersDB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-方法二"><a href="#1-2-方法二" class="headerlink" title="1.2 方法二"></a>1.2 方法二</h4><p>配置类扩展 AbstractMongoConfiguration 并重载 getDatabaseName() 和 mongo() 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories</span>(<span class="string">"orders.db"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoConfig</span> <span class="keyword">extends</span> <span class="title">AbstractMongoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDatabaseName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OrdersDB"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mongo <span class="title">mongo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//认证</span></span><br><span class="line">        MongoCredential credential =</span><br><span class="line">            MongoCredential.createMongoCRCredential(</span><br><span class="line">                env.getProperty(<span class="string">"mongo.username"</span>),</span><br><span class="line">                <span class="string">"OrdersDB"</span>,</span><br><span class="line">                env.getProperty(<span class="string">"mongo.password"</span>).toCharArray());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MongoClient(</span><br><span class="line">                <span class="keyword">new</span> ServerAddress(<span class="string">"localhost"</span>, <span class="number">37017</span>),</span><br><span class="line">                Arrays.asList(credential));</span><br><span class="line">        <span class="comment">//无需认证</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MongoClient(<span class="string">"mongodbserver"</span>, <span class="number">27017</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-注解-MongoDB-持久化"><a href="#2-注解-MongoDB-持久化" class="headerlink" title="2 注解 MongoDB 持久化"></a>2 注解 MongoDB 持久化</h3><p>Spring Data MongoDB 提供了一些将 Java 类型映射为 MongoDB 文档的注解。</p><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>@Document</td><td>标示映射到 MongoDB 文档上的领域对象</td></tr><tr><td>@Id</td><td>标示某个域为ID域</td></tr><tr><td>@DbRef</td><td>标示某个域要引用其他的文档， 这个文档有可能位于另外一个数据库中</td></tr><tr><td>@Field</td><td>为文档域指定自定义的元数据</td></tr><tr><td>@Version</td><td>标示某个属性用作版本域</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Field</span>(<span class="string">"client"</span>)</span><br><span class="line">    <span class="keyword">private</span> String customer;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Collection&lt;Item&gt; items = <span class="keyword">new</span> LinkedHashSet&lt;Item&gt;();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用-MongoTemplate-访问-MongoDB"><a href="#3-使用-MongoTemplate-访问-MongoDB" class="headerlink" title="3 使用 MongoTemplate 访问 MongoDB"></a>3 使用 MongoTemplate 访问 MongoDB</h3><p>MongoOperations 是 MongoTemplate 所实现的接口， 不使用具体实现是一个好的做法， 尤其是在注入的时候</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MongoOperations mongo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> orderCount = mongo.getCollection(<span class="string">"order"</span>).count();</span><br><span class="line"></span><br><span class="line">Order order = <span class="keyword">new</span> Order();</span><br><span class="line">... <span class="comment">// set properties and add line items</span></span><br><span class="line">mongo.save(order, <span class="string">"order"</span>);</span><br><span class="line"></span><br><span class="line">String orderId = ...;</span><br><span class="line">Order order = mongo.findById(orderId, Order<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Order&gt; chucksOrders = mongo.find(Query.query(</span><br><span class="line">Criteria.where(<span class="string">"client"</span>).is(<span class="string">"Chuck Wagon"</span>)), Order<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Order&gt; chucksWebOrders = mongo.find(Query.query(</span><br><span class="line">Criteria.where(<span class="string">"customer"</span>).is(<span class="string">"Chuck Wagon"</span>)</span><br><span class="line">.and(<span class="string">"type"</span>).is(<span class="string">"WEB"</span>)), Order<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">mongo.remove(order);</span><br></pre></td></tr></table></figure><h3 id="4-编写-MongoDB-Repository"><a href="#4-编写-MongoDB-Repository" class="headerlink" title="4 编写 MongoDB Repository"></a>4 编写 MongoDB Repository</h3><p>扩展 MongoRepository。任何扩展 Repository 的接口将会在运行时自动生成实现。</p><p>MongoRepository 接口有两个参数， 第一个是带有 @Document 注解的对象类型， 也就是该 Repository 要处理的类型。 第二个参数是带有 @Id 注解的属性类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">Order</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data Redis</title>
      <link href="/2020/07/18/Spring/Data/Spring%20Data%20Redis/"/>
      <url>/2020/07/18/Spring/Data/Spring%20Data%20Redis/</url>
      
        <content type="html"><![CDATA[<p>Spring Data Redis 包含了多个模板实现， 用来完成 Redis 数据库的数据存取功能。</p><h3 id="1-连接到Redis"><a href="#1-连接到Redis" class="headerlink" title="1 连接到Redis"></a>1 连接到Redis</h3><p>Spring Data Redis 为四种 Redis 客户端实现提供了连接工厂：</p><ul><li>JedisConnectionFactory</li><li>JredisConnectionFactory</li><li>LettuceConnectionFactory</li><li>SrpConnectionFactory</li></ul><p>配置为 bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisConnectionFactory <span class="title">redisCF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JedisConnectionFactory cf = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">    cf.setHostName(<span class="string">"redis-server"</span>);</span><br><span class="line">    cf.setPort(<span class="number">7379</span>);</span><br><span class="line">    cf.setPassword(<span class="string">"foobared"</span>);</span><br><span class="line">    <span class="keyword">return</span> cf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用-RedisTemplate"><a href="#2-使用-RedisTemplate" class="headerlink" title="2 使用 RedisTemplate"></a>2 使用 RedisTemplate</h3><p>Spring Data Redis 提供了两个模板：</p><ul><li>RedisTemplate</li><li>StringRedisTemplate</li></ul><p>RedisTemplate 简化 Redis 数据访问， 持久化各种类型的 key 和 value。StringRedisTemplate 扩展了 RedisTemplate，只关注 String 类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RedisTemplate&lt;String, Product&gt; redisTemplate(RedisConnectionFactory cf) &#123;</span><br><span class="line">    RedisTemplate&lt;String, Product&gt; redis &#x3D; new RedisTemplate&lt;String, Product&gt;();</span><br><span class="line">    redis.setConnectionFactory(cf);</span><br><span class="line">    return redis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用-key-和-value-的序列化器"><a href="#3-使用-key-和-value-的序列化器" class="headerlink" title="3 使用 key 和 value 的序列化器"></a>3 使用 key 和 value 的序列化器</h3><p>Spring Data Redis 提供了多个这样的序列化器， 包括：</p><ul><li>GenericToStringSerializer： 使用 Spring 转换服务进行序列化；</li><li>JacksonJsonRedisSerializer： 使用 Jackson 1， 将对象序列化为 JSON；</li><li>Jackson2JsonRedisSerializer： 使用 Jackson 2， 将对象序列化为 JSON；</li><li>JdkSerializationRedisSerializer： 使用 Java 序列化；</li><li>OxmSerializer： 使用 Spring O/X 映射的编排器和解排器（marshaler 和 unmarshaler） 实现序列化， 用于 XML 序列化；</li><li>StringRedisSerializer： 序列化 String 类型的 key 和 value。</li></ul><p>RedisTemplate 会使用 JdkSerializationRedisSerializer，StringRedisTemplate 默认会使用 StringRedisSerializer。setKeySerializer() 和 setValueSerializer() 方法可以分别设置序列化器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="comment">// 使用 Jackson2JsonRedisSerialize 替换默认序列化</span></span><br><span class="line">    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">    objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">    jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">    <span class="comment">// 设置 value 的序列化规则和 key 的序列化规则</span></span><br><span class="line">    redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">    redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    redisTemplate.afterPropertiesSet();</span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JdbcTemplate</title>
      <link href="/2020/07/17/Spring/Data/JdbcTemplate/"/>
      <url>/2020/07/17/Spring/Data/JdbcTemplate/</url>
      
        <content type="html"><![CDATA[<p>为了避免业务层模块强依赖于某种类型的数据库，Spring 数据库访问层以接口形式对外提供服务。</p><p>使用 Spring JDBC 的异常体系，描述能力强，且平台无关。</p><h3 id="1-数据访问模板化"><a href="#1-数据访问模板化" class="headerlink" title="1 数据访问模板化"></a>1 数据访问模板化</h3><p>数据访问过程中的固定步骤和变量分为两类：</p><ul><li>模板（templates）：处理数据访问的固定部分——事务控制、 管理资源以及处理异 常。</li><li>回调（callbacks）：处理应用程序相关的数据访问——语句、 绑定参数以及整理结果集</li></ul><p><img src="https://imine141.github.io/images/1545011852055.png" alt=""></p><p>针对不同的持久化平台， Spring提供了多个可选的模板。</p><table><thead><tr><th>ORM 持久化技术</th><th>模板类（org.springframework.*）</th></tr></thead><tbody><tr><td>JDBC</td><td>jdbc.core.JdbcTemplate</td></tr><tr><td>JCA CCI</td><td>jca.cci.core.CciTemplate</td></tr><tr><td>Hibernate</td><td>orm.hibernate5.HibernateTemplate</td></tr><tr><td>iBATIS</td><td>orm.ibatis.SqlMapClientTemplate</td></tr><tr><td>JDO</td><td>orm.jdo.JdoTemplate</td></tr><tr><td>JPA</td><td>orm.jpa.JpaTemplate</td></tr></tbody></table><h3 id="2-配置-DataSource"><a href="#2-配置-DataSource" class="headerlink" title="2 配置 DataSource"></a>2 配置 DataSource</h3><p>使用 JdbcTemplate 需设置 DataSource，提供了多种配置方式：</p><ol><li>JDBC 驱动；</li><li>JNDI 查询；</li><li>数据库连接池；</li></ol><p>生产环境建议使用从连接池获取连接的数据源；如果有可能，倾向于通过应用服务器的 JNDI 来获取数据源。</p><h4 id="2-1-JNDI-数据源"><a href="#2-1-JNDI-数据源" class="headerlink" title="2.1 JNDI 数据源"></a>2.1 JNDI 数据源</h4><p>在 Spring 应用部署的服务器中配置数据源，通过 JNDI 获取。数据源配置在应用外部，允许在访问数据库的时再查找数据源，且支持热切换。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JndiObjectFactoryBean <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JndiObjectFactoryBean jndiObjectFB = <span class="keyword">new</span> JndiObjectFactoryBean();</span><br><span class="line">    jndiObjectFB.setJndiName(<span class="string">"/jdbc/xxxx"</span>);</span><br><span class="line">    jndiObjectFB.setResourceRef(<span class="keyword">true</span>);</span><br><span class="line">    jndiObjectFB.setProxyInterface(javax.sql.DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> jndiObjectFB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-数据库连接池"><a href="#2-2-数据库连接池" class="headerlink" title="2.2 数据库连接池"></a>2.2 数据库连接池</h4><p>有多项开源数据源连接池实现：Apache Commons DBCP、c3p0、BoneCP</p><p>以 <a href="http://commons.apache.org/proper/commons-dbcp/" target="_blank" rel="noopener">DBCP</a> 为例，BasicDataSource 配置连接池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BasicDataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  BasicDataSource ds = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">  ds.setDriverClassName(<span class="string">"org.h2.Driver"</span>);</span><br><span class="line">  ds.setUrl(<span class="string">"jdbc:h2:tcp://localhost/~/xxxx"</span>);</span><br><span class="line">  ds.setUsername(<span class="string">"sa"</span>);</span><br><span class="line">  ds.setPassword(<span class="string">""</span>);</span><br><span class="line">  ds.setInitialSize(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3、JDBC-驱动"><a href="#2-3、JDBC-驱动" class="headerlink" title="2.3、JDBC 驱动"></a>2.3、JDBC 驱动</h4><p>通过 JDBC 驱动定义数据源是最简单的配置方式。 org.springframework.jdbc.datasource 包中提供了三个数据源类：</p><ol><li>DriverManagerDataSource：每次请求连接时都返回新的连接，用过的连接会马上关闭并释放资源；</li><li>SimpleDriverDataSource：与 DriverManagerDataSource 类似，但直接使用JDBC驱动，免去了类在特定环境（如 OSGi 容器）中可能遇到的类加载问题。</li><li>SingleConnectionDataSource：每次都返回同一个连接对象，可以理解为只有 1 个连接的数据源连接池。</li></ol><p>跟之前配置 DBCP 的 BasicDataSource 类似，例如配置 DriverManagerDataSource</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  DriverManagerDataSource ds = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">  ds.setDriverClassName(<span class="string">"org.h2.Driver"</span>);</span><br><span class="line">  ds.setUrl(<span class="string">"jdbc:h2:tcp://localhost/~/xxxx"</span>);</span><br><span class="line">  ds.setUsername(<span class="string">"sa"</span>);</span><br><span class="line">  ds.setPassword(<span class="string">""</span>);</span><br><span class="line">   <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已上三数据源对多线程支持都不好，强烈建议使用数据库连接池。</p><h4 id="2-4-选择数据源"><a href="#2-4-选择数据源" class="headerlink" title="2.4 选择数据源"></a>2.4 选择数据源</h4><p>借助 Spring 的 bean-profiles 特性，在不同的环境中配置不同的数据源。利用 @Profile 注解，在运行时根据激活的 profile 选择指定的数据源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"development"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">embeddedDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"qa"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasicDataSource <span class="title">basicDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BasicDataSource ds = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"production"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JndiObjectFactoryBean jndiObjectFactoryBean = <span class="keyword">new</span> JndiObjectFactoryBean();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> (DataSource)jndiObjectFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用-JdbcTemplate"><a href="#3-使用-JdbcTemplate" class="headerlink" title="3 使用 JdbcTemplate"></a>3 使用 JdbcTemplate</h3><p><a href="https://www.jianshu.com/p/aec25eea5c71" target="_blank" rel="noopener">JDBC </a>直接操作数据库， 处理与数据库访问相关的所有事情， 样板代码繁琐，但很重要。Spring 的 JDBC 框架承担了资源管理和异常处理的样板代码，开发者只需编写读写数据的必需代码。</p><p><strong>JdbcTemplate</strong> 是最主要的 JDBC 模板，支持简单的 JDBC 数据库访问功能以及基于索引参数的查询；还提供了 NameParameterJdbcTemplate 支持命名参数。</p><h4 id="3-1-CRUD"><a href="#3-1-CRUD" class="headerlink" title="3.1 CRUD"></a>3.1 CRUD</h4><p>使用 JdbcTemplate 前需设置 DataSource</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br></pre></td></tr></table></figure><ul><li>增删改<ul><li>update(final String sql)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"insert into user (username, password) values (?, ?)"</span>;</span><br><span class="line">jdbcTemplate.update(sql, username, password);</span><br></pre></td></tr></table></figure><p>当调用 update() 方法时，JdbcTemplate 调用 jdbc 获取一个连接、创建一个 statement，并执行插入语句。内部捕获了可能抛出的 SQLException 异常，然后转为更具体的数据库访问异常，并重新抛出。</p><ul><li>查<ul><li>queryForObject(String sql, RowMapper rowMapper, Object… args)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = jdbcOperations.queryForObject(sql,<span class="keyword">new</span> UserMapper (),param);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> rows)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(resultSet.getString(<span class="number">1</span>));</span><br><span class="line">        user.setPassword(resultSet.getString(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要实现一个 RowMapper 对象，JdbcTemplate 会调用 mapRow() 方法，从结果集中取出对应属性的值，并构造对象。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data JPA</title>
      <link href="/2020/07/17/Spring/Data/Spring%20Data%20JPA/"/>
      <url>/2020/07/17/Spring/Data/Spring%20Data%20JPA/</url>
      
        <content type="html"><![CDATA[<p>Java 持久化 API（Java Persistence API， JPA）基于 POJO 的持久化机制，制定了规范，具体由厂商实现。</p><p>只需按照约定好的【方法命名规则】编写 Repository 接口，不需要实现类，就可实现对数据库的访问和操作。</p><p>hibernate 实现了 JPA 规范，Spring Data JPA 进一步封装了 Hibernate。</p><h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1 配置"></a>1 配置</h3><p>maven</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.jpa.properties.hibernate.hbm2ddl.auto &#x3D; update</span><br><span class="line">spring.jpa.properties.hibernate.dialect &#x3D; org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">spring.jpa.show-sql &#x3D; true</span><br></pre></td></tr></table></figure><p>spring.jpa.properties.hibernate.hbm2ddl.auto 有几种配置：</p><ul><li>create：每次加载生成新表。</li><li>create-drop：每次加载生成新表，但当 SessionFactory 关闭时，所生成的表将自动删除。</li><li>update：第一次加载时创建数据表，以后加载根据实体更新，只增不删。</li><li>validate：每次加载验证数据表结构，只会和已经存在的数据表进行比较，根据model修改表结构，但不会创建新表。</li></ul><p>不配置此项，表示禁用自动建表功能</p><h3 id="2-简单使用"><a href="#2-简单使用" class="headerlink" title="2 简单使用"></a>2 简单使用</h3><h4 id="2-1-建立-entity"><a href="#2-1-建立-entity" class="headerlink" title="2.1 建立 entity"></a>2.1 建立 entity</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>, unique = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-扩展-Repository-接口"><a href="#2-2-扩展-Repository-接口" class="headerlink" title="2.2 扩展 Repository 接口"></a>2.2 扩展 Repository 接口</h4><p>扩展 Repository 接口或其子接口 JpaRepository、 PagingAndSortingRepository 和 CrudRepository</p><p>应用启动后自动生成接口的实现，提供默认通用方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-启用-Spring-Data-JPA"><a href="#2-3-启用-Spring-Data-JPA" class="headerlink" title="2.3 启用 Spring Data JPA"></a>2.3 启用 Spring Data JPA</h4><p>@EnableJpaRepositories 注解，扫描查找扩展自 Spring Data JPA Repository 接口的所有接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span>&#123;basePackages=<span class="string">"com.xxx.xxx"</span>&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaConfiguration</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-定义查询方法"><a href="#3-定义查询方法" class="headerlink" title="3 定义查询方法"></a>3 定义查询方法</h3><p>只需使用属性名和关键字构建 Repository 方法签名， 就能让 Spring Data JPA 生成方法实现</p><p>当创建 Repository 实现的时候， Spring Data 会检查 Repository 接口的所有方法， 解析方法的名称， 并基于被持久化的对象来试图推测方法的目的。</p><h4 id="3-1-方法组成"><a href="#3-1-方法组成" class="headerlink" title="3.1 方法组成"></a>3.1 方法组成</h4><p>Repository 方法是由一个动词、 一个可选的主题、 关键词 By 以及一个断言所组成。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findByUsername</span><span class="params">(String userName)</span></span>;</span><br></pre></td></tr></table></figure><p>findByUsername() 这个样例中， 动词是 find， 断言是 Username， 主题并没有指 定， 暗含的主题是 User。</p><h4 id="3-2-比较操作"><a href="#3-2-比较操作" class="headerlink" title="3.2 比较操作"></a>3.2 比较操作</h4><p>断言中的多个限制条件可以进行比较操作</p><ul><li>IsAfter、 After、 IsGreaterThan、 GreaterThan</li><li>IsGreaterThanEqual、 GreaterThanEqual</li><li>…</li></ul><h3 id="4-声明自定义查询"><a href="#4-声明自定义查询" class="headerlink" title="4 声明自定义查询"></a>4 声明自定义查询</h3><p>如果 Spring Data 的这个小型的 DSL 无法满足需求，还可以通过 @Query 注解来解决问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query(<span class="string">"select * from User where username like '%abc'"</span>)</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByAllAbcUser</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="5-混合自定义的功能"><a href="#5-混合自定义的功能" class="headerlink" title="5 混合自定义的功能"></a>5 混合自定义的功能</h3><p>当 Spring Data JPA 为 Repository 接口生成实现的时候， 它还会查找名字与接口相同， 并且添加了 Impl 后缀的一个类。 如果这个类存在的话， Spring Data JPA 将会把它的方法与 Spring DataJPA 所生成的方法合并在一起。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切面</title>
      <link href="/2020/07/16/Spring/AOP/%E5%88%87%E9%9D%A2/"/>
      <url>/2020/07/16/Spring/AOP/%E5%88%87%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-创建切面"><a href="#1-创建切面" class="headerlink" title="1 创建切面"></a>1 创建切面</h3><p>使用 @Aspect 注解创建切面</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LogAspect &#123;</span><br><span class="line">    @Pointcut(&quot;execution(* cn.xxx..*ServiceImpl.*(..))&quot;)</span><br><span class="line">    public void printLog() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Before(&quot;printLog()&quot;)</span><br><span class="line">    public void before(JoinPoint jp) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @After(&quot;printLog()&quot;)</span><br><span class="line">    public void after(JoinPoint jp) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @AfterReturning(pointcut &#x3D; &quot;execution(* cn.xxx..*ServiceImpl.*(..))&quot;, returning &#x3D; &quot;returnVal&quot;)</span><br><span class="line">    public void afterReturn(JoinPoint jp, String returnVal) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @AfterThrowing(value &#x3D; &quot;printLog()&quot;, throwing &#x3D; &quot;e&quot;)</span><br><span class="line">    public void afterThrow(JoinPoint jp, Throwable e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-通知注解"><a href="#2-通知注解" class="headerlink" title="2 通知注解"></a>2 通知注解</h3><ul><li>@After(最终通知)：通知方法会在目标方法返回或抛出异常后调用</li><li>@AfterReturning(后置通知)：通知方法会在目标方法返回后调用</li><li>@AfterThrowing(异常通知)：通知方法会在目标方法抛出异常后调用</li><li>@Around(环绕通知)：通知方法会将目标方法封装起来</li><li>@Before(前置通知)：通知方法会在目标方法调用之前执行</li></ul><h3 id="3-JoinPoint"><a href="#3-JoinPoint" class="headerlink" title="3 JoinPoint"></a>3 JoinPoint</h3><p>常用的方法</p><ul><li>Object[] getArgs：返回目标方法的参数</li><li>Signature getSignature：返回目标方法的签名</li><li>Object getTarget：返回被织入增强处理的目标对象</li><li>Object getThis：返回AOP框架为目标对象生成的代理对象</li></ul><p>当使用 @Around 处理时，需要将第一个参数定义为 ProceedingJoinPoint 类型，该类是 JoinPoint 的子类。</p><h3 id="4-切面执行顺序"><a href="#4-切面执行顺序" class="headerlink" title="4 切面执行顺序"></a>4 切面执行顺序</h3><h4 id="4-1-被一个-Aspect-类拦截"><a href="#4-1-被一个-Aspect-类拦截" class="headerlink" title="4.1 被一个 Aspect 类拦截"></a>4.1 被一个 Aspect 类拦截</h4><p>正常： <img src="https://imine141.github.io/images/1545011851419.jpg" alt="img"></p><p>异常： <img src="https://imine141.github.io/images/1545011851515.jpg" alt="img"></p><h4 id="4-2-被多个-Aspect-类拦截"><a href="#4-2-被多个-Aspect-类拦截" class="headerlink" title="4.2 被多个 Aspect 类拦截"></a>4.2 被多个 Aspect 类拦截</h4><h5 id="1）执行顺序"><a href="#1）执行顺序" class="headerlink" title="1）执行顺序"></a>1）执行顺序</h5><p>优先级高的切面先执行，同一切面增强类型优先的先执行，增强类型相同的随机执行</p><h5 id="2）指定优先级"><a href="#2）指定优先级" class="headerlink" title="2）指定优先级"></a>2）指定优先级</h5><ol><li>让切面类实现 org.springframework.core.Ordered 接口：实现该接口的 int getOrder() 方法，该方法返回值越小，优先级越高</li><li>直接使用 @Order 注解来修饰一个切面类：使用这个注解时可以配置一个 int 类型的 value 属性，该属性值越小，优先级越高</li></ol>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP简介</title>
      <link href="/2020/07/15/Spring/AOP/AOP%20%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/07/15/Spring/AOP/AOP%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>AOP 即 Aspect Oriented Programming，面向切面编程。</p><p>AOP 允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。</p><h3 id="1-AOP-术语"><a href="#1-AOP-术语" class="headerlink" title="1 AOP 术语"></a>1 AOP 术语</h3><p><img src="https://imine141.github.io/images/aopjianjie1.png" alt="img"></p><ul><li>通知（Advice）<ul><li><code>通知</code>表示在方法执行前后需要执行的动作，是<code>切面</code>真正要做的工作。通知负责定义<code>切面</code>的 <code>what</code> 和 <code>when</code>。</li></ul></li><li>连接点（JointPoint）<ul><li><code>连接点</code>表示在应用中可以插入<code>切面</code>，执行<code>通知</code>的地点。</li></ul></li><li>切点（Pointcut）<ul><li><code>切点</code>定义了 <code>where</code>。<code>切点</code>指定一个或者多个<code>连接点</code>，而<code>通知</code>通过切点接入。</li></ul></li><li>切面（Aspect）<ul><li><code>切面</code> = <code>通知</code> + <code>切点</code>。定义 <code>what</code>、<code>when</code> 和 <code>where</code>。是 AOP 的核心，将多个类的通用行为封装为可重用的模块。</li></ul></li><li>引入（Introduction）<ul><li><code>引入</code>允许向现有类添加新方法或属性。类似于设计模式中的装饰者模式——在不改变现有类的基础上为之增加属性和方法。</li></ul></li><li>织入（Weaving）<ul><li><code>织入</code>是把<code>切面</code>应用到目标对象并创建新的代理对象的过程。</li><li><code>切面</code>在指定的<code>连接点</code>被织入到目标对象中。</li><li>在目标对象的生命周期里有多个点可以进行织入：编译期（AspectJ）、类加载期（LTW）、运行期（Spring AOP）</li></ul></li><li>目标对象<ul><li>被一个或者多个<code>切面</code>所<code>通知</code>的对象。它通常是一个代理对象。也被称做被通知（advised）对象。</li></ul></li><li>代理<ul><li><code>代理</code>是将<code>通知</code>应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。</li></ul></li><li>自动代理<ul><li>BeanNameAutoProxyCreator：bean名称自动代理创建器</li><li>DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器</li><li>Metadata autoproxying：元数据自动代理</li></ul></li><li>Concern（核心逻辑）<ul><li>表示在应用程序中一个模块的行为。Concern 可以定义为我们想要实现的功能。</li></ul></li><li>Cross-cutting concern（横向的通用逻辑）<ul><li>指的是整个应用程序都会用到的功能，它影响整个应用程序。例如，日志管理（Logging）、安全管理（Security）以及数据交互</li></ul></li></ul><h3 id="2-Spring-的-AOP-支持"><a href="#2-Spring-的-AOP-支持" class="headerlink" title="2 Spring 的 AOP 支持"></a>2 Spring 的 AOP 支持</h3><p>Spring 对 AOP 有以下四种支持：</p><ul><li>基于代理的 Spring AOP</li><li>Pure-POJO aspects</li><li>基于 @AspectJ 注解的 aspects</li><li>注入 AspectJ aspects（所有版本的 Spring 都支持）</li></ul><p>前三种属于 Spring AOP 框架，基于动态代理机制构建，<strong>仅支持函数级别的拦截</strong>。如果需要实现更复杂的 AOP 功能，则应使用 <strong><em>AspectJ 框架</em></strong>。</p><p>在 Spring AOP 框架中，通过在 beans 的外围包含一个代理类来将切面织入到这些 beans。调用者跟代理类直接联系，代理类拦截函数调用，然后执行切面逻辑之后再调用真正的目标对象的方法。</p><p><img src="https://imine141.github.io/images/1545011850875.png" alt="img"></p><p>虽然 Spring AOP 能够满足许多应用的切面需求， 但是与 AspectJ 相比， Spring AOP 是一个功能比较弱的 AOP 解决方案。 AspectJ 提供了 Spring AOP 所不能支持的许多类型的切点。</p><p>AOP 的源码中用到了两种动态代理来实现拦截切入功能：</p><ul><li>jdk 动态代理<ul><li>jdk 动态代理是由 java 内部的反射机制来实现的，反射机制在生成类的过程中比较高效</li><li>如果加入容器的目标对象有实现接口,用 JDK 代理；</li></ul></li><li>Cglib 动态代理<ul><li>cglib 动态代理底层则是借助 asm 来实现的，asm 在生成类之后的相关执行过程中比较高效</li><li>如果目标对象没有实现接口，用 Cglib 代理</li></ul></li></ul><h3 id="3-AspectJ"><a href="#3-AspectJ" class="headerlink" title="3 AspectJ"></a>3 AspectJ</h3><p><strong>AspectJ 注解生效</strong></p><p>通过类级别的 @EnableAspectJAutoProxy 注解开启自动代理机制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">//开启AspectJ的自动代理机制</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切点</title>
      <link href="/2020/07/15/Spring/AOP/%E5%88%87%E7%82%B9/"/>
      <url>/2020/07/15/Spring/AOP/%E5%88%87%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="1-编写切点"><a href="#1-编写切点" class="headerlink" title="1 编写切点"></a>1 编写切点</h3><p>@Pointcut 定义可重复使用的切点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.xxx.mapper.*.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-表示式"><a href="#1-1-表示式" class="headerlink" title="1.1 表示式"></a>1.1 表示式</h4><p>由下列方式来定义或者通过 &amp;&amp;、 ||、 !、 的方式进行组合：</p><h5 id="1）方法"><a href="#1）方法" class="headerlink" title="1）方法"></a>1）方法</h5><ul><li>execution：匹配方法</li><li>within：限制匹配范围</li><li>this：匹配 AOP 代理类的执行方法</li><li>target：匹配目标类的执行方法</li><li>args：将匹配方法的参数传入通知，名称必须相同</li></ul><h5 id="2）注解"><a href="#2）注解" class="headerlink" title="2）注解"></a>2）注解</h5><ul><li>@within：匹配类注解</li><li>@target：匹配类注解</li><li>@args：匹配参数注解</li><li>@annotation：匹配方法注解</li></ul><h5 id="3）bean"><a href="#3）bean" class="headerlink" title="3）bean"></a>3）bean</h5><ul><li>bean()：匹配制定 bean</li></ul><h4 id="1-2-格式"><a href="#1-2-格式" class="headerlink" title="1.2 格式"></a>1.2 格式</h4><p>“?”代表可选项</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execution(修饰符? 返回值 类路径? 方法名(参数)异常类型?)</span><br></pre></td></tr></table></figure><ul><li>返回值<br><code>*</code>匹配任意</li><li>方法名<br><code>*</code>匹配任意</li><li>参数<br>指定参数类型，<code>,</code>隔开<br><code>*</code>任意类型<br><code>..</code>任意个数</li></ul><h4 id="1-3-例子"><a href="#1-3-例子" class="headerlink" title="1.3 例子"></a>1.3 例子</h4><ul><li>任意公共方法：<code>execution(public * *(..))</code></li><li>任何“set”开头方法：<code>execution(* set*(..))</code></li><li>某类任意方法：<code>execution(* com.xyz.service.AccountService.*(..))</code></li><li>某包里任意方法： <code>execution(* com.xyz.service.*.*(..))</code></li><li>某包及子包任意方法：<code>execution(* com.xyz.service..*.*(..))</code></li><li>某包任意类： <code>within(com.test.spring.aop.pointcutexp.*)</code></li><li>实现了 Intf 接口的所有类：<code>this(com.abc.Intf)</code></li><li>带有 @xxx 注解的所有类的任意方法：<ul><li><code>@within(org.abc.xxx)</code></li><li><code>@target(org.abc.xxx))</code></li></ul></li><li>带有 @xxx 注解的任意方法：<code>@annotation(org.abc.xxx))</code></li><li>参数带有有 @xxx 注解的方法：<code>@args(org.abc.xxx)</code></li><li>参数类型： <code>args(String)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态注册 Bean</title>
      <link href="/2020/07/14/Spring/IoC/%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%20Bean/"/>
      <url>/2020/07/14/Spring/IoC/%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%20Bean/</url>
      
        <content type="html"><![CDATA[<h3 id="1-注册接口"><a href="#1-注册接口" class="headerlink" title="1 注册接口"></a>1 注册接口</h3><p>有两种接口可动态注册 bean</p><ol><li>BeanDefinitionRegistry<br>注册 Bean 定义，使用<code>BeanDefinitionRegistry</code> 接口 <code>registerBeanDefinition()</code> 方法，根据<code>BeanDefinition</code>实例化 bean 实例</li><li>SingletonBeanRegistry<br>注册 bean 实例，使用<code>SingletonBeanRegistry</code> 接口<code>registerSingleton()</code> 方法，注册单例 bean。</li></ol><p><strong>DefaultListableBeanFactory</strong> 接口同时实现了这两个接口</p><h3 id="2-普通注册"><a href="#2-普通注册" class="headerlink" title="2 普通注册"></a>2 普通注册</h3><p>如果是在普通 Bean 中注册，那么该 bean 则无法被<strong>BeanPostProcessor</strong>处理，没有 AOP 的支持。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonManagerRegisterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    GenericApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ConfigurableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerPersonManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PersonDao personDao = applicationContext.getBean(PersonDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        PersonManager personManager = <span class="keyword">new</span> PersonManager();</span><br><span class="line">        personManager.setPersonDao(personDao);</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"personManager"</span>, personManager);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-BeanFactoryPostProcessor-注册"><a href="#3-BeanFactoryPostProcessor-注册" class="headerlink" title="3 BeanFactoryPostProcessor 注册"></a>3 BeanFactoryPostProcessor 注册</h3><p>在 Spring 容器的启动过程中，BeanFactory 载入 bean 的定义后会立刻执行 BeanFactoryPostProcessor，此时动态注册 bean，则可以保证动态注册的 bean 被 BeanPostProcessor 处理，并且可以保证其的实例化和初始化总是先于依赖它的 bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory defaultListableBeanFactory</span><br><span class="line">                = (DefaultListableBeanFactory) beanFactory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册 Bean 定义</span></span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder =</span><br><span class="line">                BeanDefinitionBuilder.genericBeanDefinition(PersonManager<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        beanDefinitionBuilder.addPropertyReference(<span class="string">"personDao"</span>, <span class="string">"personDao"</span>);</span><br><span class="line">        BeanDefinition personManagerBeanDefinition = beanDefinitionBuilder.getRawBeanDefinition();</span><br><span class="line">        defaultListableBeanFactory.registerBeanDefinition(<span class="string">"personManager1"</span>, personManagerBeanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册 bean 实例</span></span><br><span class="line">        PersonDao personDao = beanFactory.getBean(PersonDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        PersonManager personManager = <span class="keyword">new</span> PersonManager();</span><br><span class="line">        personManager.setPersonDao(personDao);</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"personManager2"</span>, personManager);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Spring-官方实现"><a href="#4-Spring-官方实现" class="headerlink" title="4 Spring 官方实现"></a>4 Spring 官方实现</h3><h4 id="4-1-ImportBeanDefinitionRegistrar"><a href="#4-1-ImportBeanDefinitionRegistrar" class="headerlink" title="4.1 ImportBeanDefinitionRegistrar"></a>4.1 ImportBeanDefinitionRegistrar</h4><p>Spring 官方在动态注册 bean 时，大多使用 ImportBeanDefinitionRegistrar 接口。</p><p>所有实现了该接口的类的都会被 ConfigurationClassPostProcessor 处理，ConfigurationClassPostProcessor 实现了 BeanFactoryPostProcessor 接口，所以 ImportBeanDefinitionRegistrar 中动态注册的 bean 是优先与依赖其的 bean 初始化的，也能被 aop、validator 等机制处理。</p><h4 id="4-2-BeanDefinitionRegistryPostProcessor"><a href="#4-2-BeanDefinitionRegistryPostProcessor" class="headerlink" title="4.2 BeanDefinitionRegistryPostProcessor"></a>4.2 BeanDefinitionRegistryPostProcessor</h4><p>Spring 官方另一个大量使用的动态注册接口是 BeanDefinitionRegistryPostProcessor，这个接口扩展自 BeanFactoryPostProcessor，专门用于动态注册 Bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBeanDefinitionRegistryPostProcessor</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 Bean 定义</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// 构造 bean 定义</span></span><br><span class="line">BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(PersonManager<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//设置依赖</span></span><br><span class="line">beanDefinitionBuilder.addPropertyReference(<span class="string">"personDao"</span>, <span class="string">"personDao"</span>);</span><br><span class="line">BeanDefinition personManagerBeanDefinition = beanDefinitionBuilder</span><br><span class="line">.getRawBeanDefinition();</span><br><span class="line"><span class="comment">//注册bean定义</span></span><br><span class="line">registry.registerBeanDefinition(<span class="string">"personManager1"</span>, personManagerBeanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 Bean 实例</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(PersonManager<span class="class">.<span class="keyword">class</span>, () -&gt; </span>&#123;</span><br><span class="line">PersonDao personDao = beanFactory.getBean(PersonDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">PersonManager personManager = <span class="keyword">new</span> PersonManager();</span><br><span class="line">personManager.setPersonDao(personDao);</span><br><span class="line"><span class="keyword">return</span> personManager;</span><br><span class="line">&#125;);</span><br><span class="line">BeanDefinition personManagerBeanDefinition = beanDefinitionBuilder</span><br><span class="line">.getRawBeanDefinition();</span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.registerBeanDefinition(<span class="string">"personManager2"</span>, personManagerBeanDefinition);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> IoC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>依赖注入</title>
      <link href="/2020/07/13/Spring/IoC/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/07/13/Spring/IoC/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>IoC</strong>（Inversion of Control，控制反转 ）：控制权由应用代码中转到了外部容器，控制权的转移，所谓控制反转。</p><p><strong>依赖注入</strong>：依赖注入是控制反转(IOC)的一个层面，用创建对象而只需要描述如何创建它们。</p><p>IoC 负责装配 Bean，即创建应用对象之间协作关系，是<strong>依赖注入</strong>（DI，Dependency injection）的本质。</p><p>装配方式优先级：自动装配 &gt; Java 配置文件 &gt; XML 配置文件</p><h3 id="1-自动装配"><a href="#1-自动装配" class="headerlink" title="1 自动装配"></a>1 自动装配</h3><p>Spring 容器可以自动配置相互协作 beans 之间的关联关系。这意味着 Spring 可以自动配置一个 bean 和其他协作 bean 之间的关系。</p><p>Spring 从两个角度来实现自动装配</p><h4 id="1-1-组件扫描"><a href="#1-1-组件扫描" class="headerlink" title="1.1 组件扫描"></a>1.1 组件扫描</h4><p>Spring 自动发现 ApplicationContext 中所创建的 bean</p><h5 id="1）-Component"><a href="#1）-Component" class="headerlink" title="1）@Component"></a>1）@Component</h5><p>让 Spring 为类自动创建 bean，默认 ID 是类名称的首字母小写。也可给注解传入指定的参数指定名字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"lonelyHeartsClub"</span>)</span><br></pre></td></tr></table></figure><p>还有 @Repository、@Service、@Controller 等</p><h5 id="2）-ComponentScan"><a href="#2）-ComponentScan" class="headerlink" title="2）@ComponentScan"></a>2）@ComponentScan</h5><p>开启 Component 扫描，默认设置该目录以及子目录下所有被 @Component 注解修饰的类。也可指定扫描的包。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"soundsystem"</span>)<span class="comment">//扫描指定包  </span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"soundsystem"</span>)</span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"soundsystem"</span>, <span class="string">"video"</span>&#125;)</span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackageClasses = &#123;CDPlayer<span class="class">.<span class="keyword">class</span>, <span class="title">DVDPlayer</span>.<span class="title">class</span>&#125;)//扫描指定类所属的包</span></span><br></pre></td></tr></table></figure><h4 id="1-2-自动装配"><a href="#1-2-自动装配" class="headerlink" title="1.2 自动装配"></a>1.2 自动装配</h4><p>Spring 自动满足 bean 之间的依赖</p><p><strong>@Autowired</strong>：声明自动装配，可用在构造器、方法、成员变量上。</p><p>只要对应类型的 bean 有且只有一个，则会自动装配。推荐通过构造器注入以避免 NullPointerException 问题。</p><h5 id="1）注入到-Java-集合类"><a href="#1）注入到-Java-集合类" class="headerlink" title="1）注入到 Java 集合类"></a>1）注入到 Java 集合类</h5><p>@Autowired 可直接将接口的实现 Bean 注入到如下几种类型的集合中</p><ul><li>list：用来注入一系列的值，允许有相同的值。</li><li>set：用来注入一些列的值，不允许有相同的值。</li><li>map：用来注入一组”键-值”对，key 必须为 String。</li><li>props：也可以用来注入一组”键-值”对，这里的键、值都字符串类型。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> List&lt;BeanInterface&gt; list;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,Interface&gt; map;</span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">table-info.list[0]=list_value1</span><br><span class="line">table-info.list[1]=list_value2</span><br><span class="line">table-info.map.map_key1=map_value1</span><br><span class="line">table-info.map.map_key2=map_value2</span><br><span class="line">table-info.maplist.map_key1[0]=maplist_value1</span><br><span class="line">table-info.maplist.map_key1[1]=maplist_value2</span><br><span class="line">table-info.maplist.map_key2[0]=maplist_value3</span><br></pre></td></tr></table></figure><p>TableConfig</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"table-info"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; maplist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）允许-null-值"><a href="#2）允许-null-值" class="headerlink" title="2）允许 null 值"></a>2）允许 null 值</h5><p>默认要求依赖对象必须存在，如允许 null 值，可设置 @Autowired(required=false)</p><p>还有 @Resource 等</p><h5 id="3）推荐对构造函数进行注释"><a href="#3）推荐对构造函数进行注释" class="headerlink" title="3）推荐对构造函数进行注释"></a>3）推荐对构造函数进行注释</h5><p>由</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EnterpriseDbService service;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EnterpriseDbService service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnterpriseDbController</span><span class="params">(EnterpriseDbService service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.service = service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以明确成员变量的加载顺序</p><h3 id="2-Java-配置文件"><a href="#2-Java-配置文件" class="headerlink" title="2 Java 配置文件"></a>2 Java 配置文件</h3><p>想要装配第三方库中的组件时，因为没办法在它的类上添加 @Component 和 @Autowired 注解，不能自动化配置，必须要采用显式装配。</p><h4 id="2-1-创建配置类"><a href="#2-1-创建配置类" class="headerlink" title="2.1 创建配置类"></a>2.1 创建配置类</h4><p>@Configuration：表明是配置类</p><h4 id="2-2-声明-bean"><a href="#2-2-声明-bean" class="headerlink" title="2.2 声明 bean"></a>2.2 声明 bean</h4><p><strong>@Bean</strong>：声明 bean，需编写方法创建所需类型实例， 注解 @Bean。默认 ID 是方法名，也可通过 name 属性指定名字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"lonelyHeartsClub"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-装配-bean"><a href="#2-3-装配-bean" class="headerlink" title="2.3 装配 bean"></a>2.3 装配 bean</h4><p>在 JavaConfig 中装配 bean 的最简单方式就是引用创建 bean 的方法。</p><p>默认情况下，Spring 中所有的 bean 都是<strong>单例模式</strong>，Spring 会拦截 @Bean 注解的函数调用，并返回之前创建好的 bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CDPlayer <span class="title">cdPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(sgtPeppers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-XML-配置文件"><a href="#3-XML-配置文件" class="headerlink" title="3 XML 配置文件"></a>3 XML 配置文件</h3><p>维护已有的 XML 配置， 在完成新的 Spring 工作时， 使用自动化配置和 JavaConfig。</p><p>创建一个 XML 文件， 并且以 元素为根。使用 元素声明 bean 并指定 class 属性。 元素注入构造器</p><p>可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用 setter 方法实现可选的依赖关系。</p><h4 id="3-1-set-注入"><a href="#3-1-set-注入" class="headerlink" title="3.1 set 注入"></a>3.1 set 注入</h4><p>首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用 bean 中的setter 方法完成 Setter 方法依赖注入。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> OrderServiceImp orderService;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderService</span><span class="params">(OrderServiceImp orderService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 配置 XML 文件：其中配置声明 OrderAction 类存在属性 orderService。程式运行时候，会将已经实例化的 orderService 对象调用 setOrderService 方式注入。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderAction"</span> <span class="attr">class</span>=<span class="string">"com.pec.action.OrderAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"orderService"</span> <span class="attr">ref</span>=<span class="string">"orderService"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"com.pec.service.imp.OrderServiceImp"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-构造器注入"><a href="#3-2-构造器注入" class="headerlink" title="3.2 构造器注入"></a>3.2 构造器注入</h4><p>构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> OrderServiceImp orderService;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderAction</span><span class="params">(OrderServiceImp orderService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 配置 XML 文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderAction"</span> <span class="attr">class</span>=<span class="string">"com.pec.action.OrderAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"orderService"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"com.pec.service.imp.OrderServiceImp"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-多种配置方法混用"><a href="#4-多种配置方法混用" class="headerlink" title="4 多种配置方法混用"></a>4 多种配置方法混用</h3><p>通常的做法是：无论使用 JavaConfig 或者 XML 装配，都要创建一个 root configuration；并且在这个配置文件中开启自动扫描机制</p><h4 id="4-1-JavaConfig-中引用"><a href="#4-1-JavaConfig-中引用" class="headerlink" title="4.1 JavaConfig 中引用"></a>4.1 JavaConfig 中引用</h4><ul><li>@Import：导入其他的 JavaConfig</li><li>@ImportResource：导入 XML 配置文件</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;CDPlayerConfig<span class="class">.<span class="keyword">class</span>, <span class="title">CDConfig</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line">@ImportResource("classpath: cd-config.xml")</span><br></pre></td></tr></table></figure><h4 id="4-2-XML-配置中引用"><a href="#4-2-XML-配置中引用" class="headerlink" title="4.2 XML 配置中引用"></a>4.2 XML 配置中引用</h4><p>标签引入其他的 XML 配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:/spring/calculate-web.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>标签导入 Java 配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"soundsystem.CDConfig"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-BeanFactory-和-FactoryBean的区别"><a href="#5-BeanFactory-和-FactoryBean的区别" class="headerlink" title="5 BeanFactory 和 FactoryBean的区别"></a>5 BeanFactory 和 FactoryBean的区别</h3><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a><strong>BeanFactory</strong></h4><p>BeanFactory，以Factory结尾，表示它是一个工厂类(接口)， 它负责生产和管理bean的一个工厂。在Spring中，BeanFactory是IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a><strong>FactoryBean</strong></h4><p>一般情况下，Spring通过反射机制利用<bean>的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在<bean>中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean<T>的形式</p><p>以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了FactoryBean<T>接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个&amp;符号来获取。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> IoC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级装配</title>
      <link href="/2020/07/13/Spring/IoC/%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D/"/>
      <url>/2020/07/13/Spring/IoC/%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="1-环境与-profile"><a href="#1-环境与-profile" class="headerlink" title="1 环境与 profile"></a>1 环境与 profile</h3><h4 id="1-1-配置-profile"><a href="#1-1-配置-profile" class="headerlink" title="1.1 配置 profile"></a>1.1 配置 profile</h4><h5 id="Profile-注解"><a href="#Profile-注解" class="headerlink" title="@Profile 注解"></a>@Profile 注解</h5><p>指定某个 bean 属于哪一个 profile，运行时做出环境决策。</p><p>没有指定 profile 的 bean 始终都会被创建， 与激活哪个 profile 没有关系。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"prod"</span>)</span><br></pre></td></tr></table></figure><h4 id="1-2-激活-profiles"><a href="#1-2-激活-profiles" class="headerlink" title="1.2 激活 profiles"></a>1.2 激活 profiles</h4><p>Spring 提供了两个配置项定义激活哪个 profile：</p><ul><li>spring.profiles.active：优先</li><li>spring.profiles.default：没有 active 则找 default</li></ul><p>如都没有设置，则只会创建没有被 profile 修饰的 bean。</p><h3 id="2-条件化的-bean"><a href="#2-条件化的-bean" class="headerlink" title="2 条件化的 bean"></a>2 条件化的 bean</h3><h4 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h4><p>作用于 @Bean 注解修饰的方法上，通过判断指定的条件是否满足来决定是否创建该 bean。</p><p>传入注解的类一定要实现 Condition 接口，提供 matchs() 方法——如果 matches() 方法返回 true，则被 @Conditional 注解修饰的 bean 就会创建，否则对应的 bean 不会创建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Conditional</span>(MagicExistsCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">MagicBean</span> <span class="title">magicBean</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MagicBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-处理自动装配的歧义"><a href="#3-处理自动装配的歧义" class="headerlink" title="3 处理自动装配的歧义"></a>3 处理自动装配的歧义</h3><h4 id="3-1-Primary"><a href="#3-1-Primary" class="headerlink" title="3.1 @Primary"></a>3.1 @Primary</h4><p>指定优先 bean</p><h4 id="3-2-Qualifier"><a href="#3-2-Qualifier" class="headerlink" title="3.2 @Qualifier"></a>3.2 @Qualifier</h4><p>指定 bean 的 ID</p><p>也可在 bean 和注入的地方注解相同 @Qualifier，或定义自定义 QUALIFIER</p><h3 id="4-bean-的作用域"><a href="#4-bean-的作用域" class="headerlink" title="4 bean 的作用域"></a>4 bean 的作用域</h3><h4 id="4-1-Scope"><a href="#4-1-Scope" class="headerlink" title="4.1 @Scope"></a>4.1 @Scope</h4><p>Spring 中的 bean 默认都是单例，这对可变类型是非线程安全的。如果选择其他的作用域， 要使用 @Scope 注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br></pre></td></tr></table></figure><h4 id="4-2-scoped-代理"><a href="#4-2-scoped-代理" class="headerlink" title="4.2 scoped 代理"></a>4.2 scoped 代理</h4><p>单例 bean 在加载时就会被创建，会话/请求 bean 要创建 request/session 时才会被创建。</p><p>把会话 bean 装配到单例 bean 时，应给单例 bean 装配一个会话 bean 的代理。</p><p>代理类对外暴露的接口和会话 bean 中的一样，当单例 bean 调用对应的接口时，代理采取懒解析策略，并把调用委派给实际的 session-scoped bean。设置 proxyMode 属性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(value=WebApplicationContext.SCOPE_SESSION,</span><br><span class="line">proxyMode=ScopedProxyMode.INTERFACES)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ShoppingCart <span class="title">cart</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="5-运行时值注入"><a href="#5-运行时值注入" class="headerlink" title="5 运行时值注入"></a>5 运行时值注入</h3><p>Spring 提供以下两种方式实现运行时注入：</p><ul><li>属性占位符（ Property placeholder） 。</li><li>Spring 表达式语言（ SpEL） 。</li></ul><h4 id="5-1-Environment"><a href="#5-1-Environment" class="headerlink" title="5.1 Environment"></a>5.1 Environment</h4><p>在 Spring 中解析外部值的最好方法是定义一个配置文件，然后通过 Spring 的 Environment 实例获取配置文件中的配置项的值。属性文件被加载到 Spring 的 Environment 实例中，然后通过 getProperty() 方法解析对应配置项的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/app.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressiveConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">disc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(env.getProperty(<span class="string">"disc.title"</span>),env.getProperty(<span class="string">"disc.artist"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-属性占位符"><a href="#5-2-属性占位符" class="headerlink" title="5.2 属性占位符"></a>5.2 属性占位符</h4><p>将属性定义到外部的属性的文件中， 并使用占位符“${ … }”将其插入到 Spring bean 中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlankDisc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Value(<span class="string">"$&#123;disc.title&#125;"</span>)</span> String title,</span></span><br><span class="line"><span class="function">        @<span class="title">Value</span><span class="params">(<span class="string">"$&#123;disc.artist&#125;"</span>)</span> String artist) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">    <span class="keyword">this</span>.artist = artist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使用占位符的值，需要配置 PropertySourcesPlaceholderConfigurer</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertySourcesPlaceholderConfigurer <span class="title">placeholderConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-SpEL-表达式"><a href="#5-3-SpEL-表达式" class="headerlink" title="5.3 SpEL 表达式"></a>5.3 SpEL 表达式</h4><p>运行时给 bean 的属性或者构造函数参数注入值</p><p>SpEL 表达式被 #{ … } 包围：</p><ul><li>可以通过 bean 的 ID 引用 bean；</li><li>可以调用某个对象的方法或者访问它的属性；</li><li>支持数学、关系和逻辑操作；</li><li>正则表达式匹配；</li><li>支持集合操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> IoC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC容器和Bean</title>
      <link href="/2020/07/11/Spring/Core/IOC%E5%AE%B9%E5%99%A8/"/>
      <url>/2020/07/11/Spring/Core/IOC%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-IOC-容器"><a href="#1-IOC-容器" class="headerlink" title="1 IOC 容器"></a>1 IOC 容器</h3><p>概念 ： IOC 容器（container）是 Spring 框架的核心，它管理着 Spring 应用中 bean 的创建、 配置和管理，负责对象的整个生命周期。</p><h4 id="1-1-容器实现"><a href="#1-1-容器实现" class="headerlink" title="1.1 容器实现"></a>1.1 容器实现</h4><h5 id="1）BeanFactory"><a href="#1）BeanFactory" class="headerlink" title="1）BeanFactory"></a>1）BeanFactory</h5><p>最简单的容器，提供基本的 DI 支持。使用控制反转将应用的配置和依赖与实际的应用代码分离开来。</p><p>第一次访问某一 Bean 时才实例化它。</p><h5 id="2）ApplicationContext"><a href="#2）ApplicationContext" class="headerlink" title="2）ApplicationContext"></a>2）ApplicationContext</h5><p>基于 BeanFactory 构建， 并提供应用框架级别的服务。</p><p>初始化容器时就实例化所有单例的 Bean。</p><p>有多种 ApplicationContext 的实现， 每一种都提供了配置 Spring 的不同方式。</p><h5 id="3）Bean-Factory-和-ApplicationContext-的区别"><a href="#3）Bean-Factory-和-ApplicationContext-的区别" class="headerlink" title="3）Bean Factory 和 ApplicationContext 的区别"></a>3）Bean Factory 和 ApplicationContext 的区别</h5><p>ApplicationContext 提供了一种解决文档信息的方法，一种加载文件资源的方式(如图片)，他们可以向监听他们的beans发送消息。</p><p>另外，容器或者容器中 beans 的操作，这些必须以 Bean Factory 的编程方式处理的操作可以在 ApplicationContext 中以声明的方式处理。</p><p><strong>这两者的继承关系如下：</strong></p><p><img src="https://imine141.github.io/images/ioc%E7%BB%A7%E6%89%BF%E5%9B%BE2.png" alt=""></p><h4 id="1-2-getBean"><a href="#1-2-getBean" class="headerlink" title="1.2 getBean()"></a>1.2 getBean()</h4><p>通过容器 getBean() 方法从容器获取指定 bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">xxx xxxobj = applicationContext.getBean(xxx<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="2-Spring-Bean"><a href="#2-Spring-Bean" class="headerlink" title="2 Spring Bean"></a>2 Spring Bean</h3><h3 id="2-1-Spring-Bean-定义"><a href="#2-1-Spring-Bean-定义" class="headerlink" title="2.1 Spring Bean 定义"></a>2.1 Spring Bean 定义</h3><p><strong>什么是Bean？</strong></p><p>由于Java语言欠缺属性、事件、多重继承功能，如果在Java程序中实现一些面向对象编程的常见需求，只能手写大量胶水代码。Bean正是编写这套胶水代码的惯用模式或约定。这些约定包括getXxx、setXxx、isXxx、addXxxListener、XxxEvent等。简而言之，Bean就是一个具有规范的Java类</p><p>在spring中。这些bean对象由 Spring IOC 容器实例化、组装、管理。</p><p>Spring Bean 中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。</p><h4 id="2-2-定义-bean-的作用域"><a href="#2-2-定义-bean-的作用域" class="headerlink" title="2.2 定义 bean 的作用域"></a>2.2 定义 bean 的作用域</h4><p>在 Spring 中创建一个 bean 的时候，我们可以通过“scope”属性声明它的作用域。</p><p>Spring 中的 bean 默认都是单例（singleton）的，这对可变类型是非线程安全的。</p><p>Spring 定义了几种 bean 的作用域：</p><ul><li>Singleton：单例。在 Spring IOC 容器中仅存在一个 Bean 实例，Bean 以单实例的方式存在。</li><li>Prototype：原型。每次被装配时，都会创建一个新的实例。</li><li>Request：在 WebApplicationContext 中，在每次 http 请求中创建一个 bean 的实例。</li><li>Session：在 WebApplicationContext 中，在每次 HTTP Session 过程中只创建一个 bean 的实例；</li><li>GlobalSession：在 WebApplicationContext 中，在同一个全局 HTTP Session 只创建一个 Bean 的实例</li></ul><h3 id="3-Bean-的生命周期"><a href="#3-Bean-的生命周期" class="headerlink" title="3 Bean 的生命周期"></a>3 Bean 的生命周期</h3><p>对于普通的 Java 对象，当 new 的时候创建对象，当它没有任何引用的时候被垃圾回收机制回收。而由 Spring IoC 容器托管的对象，它们的生命周期完全由容器控制。</p><p>Spring 只管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p><p><img src="https://imine141.github.io/images/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" alt="bean的生命周期"></p><p>BeanFactory 负责 bean 创建的最初四步，然后移交给 ApplicationContext 做后续创建过程</p><h4 id="3-1-实例化"><a href="#3-1-实例化" class="headerlink" title="3.1 实例化"></a>3.1 实例化</h4><p>Spring 容器（从 XML 文件、注解、Java 配置文件）读取 bean 的定义并实例化 bean。</p><ul><li>对于 BeanFactory 容器：当客户向容器请求一个尚未初始化的 bean 时，或初始化 bean 的时候需要注入另一个尚未初始化的依赖时，容器就会调用 createBean 进行实例化。</li><li>对于 ApplicationContext 容器：当容器启动结束后，便实例化所有的 bean。</li></ul><p>容器通过获取 BeanDefinition 对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。</p><p>实例化对象被包装在 BeanWrapper 对象中，BeanWrapper 提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</p><h4 id="3-2-属性填充（依赖注入）"><a href="#3-2-属性填充（依赖注入）" class="headerlink" title="3.2 属性填充（依赖注入）"></a>3.2 属性填充（依赖注入）</h4><p>实例化后的对象被封装在 BeanWrapper 对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。</p><p>紧接着，Spring 根据 BeanDefinition 中的信息进行依赖注入。</p><p>并且通过 BeanWrapper 提供的设置属性的接口完成依赖注入。</p><h4 id="3-3-注入-Aware-接口"><a href="#3-3-注入-Aware-接口" class="headerlink" title="3.3 注入 Aware 接口"></a>3.3 注入 Aware 接口</h4><p>紧接着，Spring 会检测该对象是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 bean。</p><ul><li>如果该 Bean 实现了 BeanNameAware 接口，Spring 将 bean 的 id 传递给 setBeanName() 方法。</li><li>如果该 Bean 实现了 BeanFactoryAware 接口，Spring 将 BeanFactory 传递给 setBeanFactory() 方法。</li><li>如果该 Bean 实现了 ApplicationContextAware 接口，Spring 将 ApplicationContext 传递给 setApplicationContext() 方法。</li></ul><p>xxxAware 接口可以用于在初始化 bean 时获得 Spring 中的一些对象，如获取 Spring 上下文等。</p><h4 id="3-4-BeanPostProcessor"><a href="#3-4-BeanPostProcessor" class="headerlink" title="3.4 BeanPostProcessor"></a>3.4 BeanPostProcessor</h4><p>当经过上述几个步骤后，bean 对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过 BeanPostProcessor 接口实现。</p><p>该接口提供了两个函数：</p><ul><li>postProcessBeforeInitialzation( Object bean, String beanName )<ul><li>当前正在初始化的 bean 对象会被传递进来，我们就可以对这个 bean 作任何处理。</li><li>这个函数会先于 InitialzationBean 执行，因此称为“前置处理”。</li><li>所有 Aware 接口的注入就是在这一步完成的。</li></ul></li><li>postProcessAfterInitialzation( Object bean, String beanName )<ul><li>当前正在初始化的 bean 对象会被传递进来，我们就可以对这个 bean 作任何处理。</li><li>这个函数会在 InitialzationBean 完成后执行，因此称为“后置处理”。</li></ul></li></ul><h4 id="3-5-自定义初始化"><a href="#3-5-自定义初始化" class="headerlink" title="3.5 自定义初始化"></a>3.5 自定义初始化</h4><p>当 BeanPostProcessor 的“前置处理”完成后就会进入本阶段。</p><h5 id="1）InitializingBean-接口"><a href="#1）InitializingBean-接口" class="headerlink" title="1）InitializingBean 接口"></a>1）InitializingBean 接口</h5><p>InitializingBean 接口只有一个函数：afterPropertiesSet()</p><p>这一阶段也可以在 bean 正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前 bean 对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。</p><p>若要使用它，我们需要让 bean 实现该接口，并把要增加的逻辑写在该函数中。</p><p>Spring 会在前置处理完成后检测当前 bean 是否实现了 InitializingBean 接口，并执行 afterPropertiesSet 函数。</p><h5 id="2）init-method-属性"><a href="#2）init-method-属性" class="headerlink" title="2）init-method 属性"></a>2）init-method 属性</h5><p>Spring 为了降低对客户代码的侵入性，给 bean 的配置提供了 init-method 属性，该属性指定了在这一阶段需要执行的函数名。</p><p>Spring 便会在初始化阶段执行我们设置的函数。init-method 本质上仍然使用了 InitializingBean 接口。</p><h5 id="3）-PostConstruct-注解"><a href="#3）-PostConstruct-注解" class="headerlink" title="3）@PostConstruct 注解"></a>3）@PostConstruct 注解</h5><p>对象构建之后调用</p><h4 id="3-6-自定义销毁"><a href="#3-6-自定义销毁" class="headerlink" title="3.6 自定义销毁"></a>3.6 自定义销毁</h4><p>当 BeanPostProcessor 的“后置处理”完成后就会进入本阶段。</p><h5 id="1）DisposableBean-接口"><a href="#1）DisposableBean-接口" class="headerlink" title="1）DisposableBean 接口"></a>1）DisposableBean 接口</h5><p>如果该 bean 实现了 DisposableBean，调用 destroy() 方法。</p><h5 id="2）destroy-method-属性"><a href="#2）destroy-method-属性" class="headerlink" title="2）destroy-method 属性"></a>2）destroy-method 属性</h5><p>和 init-method 一样，通过给 destroy-method 指定函数，就可以在 bean 销毁前执行指定的逻辑。</p><h5 id="3）-PreDestroy-注解"><a href="#3）-PreDestroy-注解" class="headerlink" title="3）@PreDestroy 注解"></a>3）@PreDestroy 注解</h5><p>对象移除之前调用</p><p><strong>如果想从源码的角度再深入了解IOC这块，推荐看这篇文章</strong></p><p> <a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">https://javadoop.com/post/spring-ioc</a> </p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring基础</title>
      <link href="/2020/07/10/Spring/Core/spring%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/07/10/Spring/Core/spring%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Spring 是一个开源的 Java EE 开发框架。Spring 框架的核心功能可以应用在任何 Java 应用程序中，但对 Java EE 平台上的 Web 应用程序有更好的扩展性。Spring 框架的目标是使得 Java EE 应用程序的开发更加简捷，通过使用 POJO 为基础的编程模型促进良好的编程风格。</p><h3 id="1-Spring-基本理念"><a href="#1-Spring-基本理念" class="headerlink" title="1 Spring 基本理念"></a>1 Spring 基本理念</h3><p>简化 Java 开发</p><ul><li>轻量级：基础版本的 Spring 框架大约只有 2 MB。</li><li>容器：Spring 包含并管理应用程序对象的配置及生命周期。</li><li>控制反转(IOC)：松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。</li><li>面向切面编程(AOP)： 把应用的业务逻辑与系统的服务分离开来。消除样板式代码.</li></ul><h3 id="2-Spring-基本原理"><a href="#2-Spring-基本原理" class="headerlink" title="2 Spring 基本原理"></a>2 Spring 基本原理</h3><ol><li>启动项目后，按照配置找到要 scan 的包（自动装配）</li><li>解析包里面的所有类，找到所有含有 @bean，@service 等注解的类，利用反射解析，封装成各种信息类放到容器（map 实现）里。</li><li>需要 bean 时，从容器里找。找到则通过构造器 new 出来（控制反转），没找到则抛出异常</li><li>如果类中有需要注入的，仍从 container 寻找、解析类，new 出对象，用 setter 注入（依赖注入）。</li><li>嵌套 bean 用了递归，container 会放到 servletcontext 里，每次 request 从 servletcontext 找 container。</li><li>如果 bean 的 scope 是 singleton，会重用，将这个 bean 放到一个 map 里，每次用都先从这个 map 里面找。</li><li>如果 scope 是 session，则该 bean 会放到 session 里面。</li></ol><h3 id="3-Spring-模块"><a href="#3-Spring-模块" class="headerlink" title="3 Spring 模块"></a>3 Spring 模块</h3><p>Spring 4.0 有 20 个模块，这些模块依据其所属的功能可以划分为 6 类不同的功能</p><p><img src="https://imine141.github.io/images/1545011849499.png" alt=""></p><h4 id="3-1-Spring-核心容器"><a href="#3-1-Spring-核心容器" class="headerlink" title="3.1 Spring 核心容器"></a>3.1 Spring 核心容器</h4><p>最核心的部分。除了 BeanFactory 和 ApplicationContext，还提供 E-mail、 JNDI 访问、 EJB 集成和调度等服务。所有的 Spring 模块都构建于核心容器之上</p><h4 id="3-2-面向切面编程"><a href="#3-2-面向切面编程" class="headerlink" title="3.2 面向切面编程"></a>3.2 面向切面编程</h4><p>开发切面的基础。借助于 AOP，可以将遍布系统的关注点（例如事务和安全）从它们所应用的对象中解耦出来。</p><h4 id="3-3-数据访问与集成"><a href="#3-3-数据访问与集成" class="headerlink" title="3.3 数据访问与集成"></a>3.3 数据访问与集成</h4><p>JDBC 和 data-access object 模块封装了样板式代码和异常。</p><p>集成了许多流行的 ORM。支持事务管理。</p><h5 id="1）JDBC-和-DAO"><a href="#1）JDBC-和-DAO" class="headerlink" title="1）JDBC 和 DAO"></a>1）JDBC 和 DAO</h5><p>JDBC 和 DAO（data-access object）模块封装了样板式代码和异常，保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。</p><p>它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用 Spring 的 AOP 模块为 Spring 应用程序中的对象提供事务管理服务。</p><h5 id="2）ORM"><a href="#2）ORM" class="headerlink" title="2）ORM"></a>2）ORM</h5><p>Spring 通过提供对象/关系映射集成（ORM）模块在 JDBC 的基础上支持对象关系映射工具。</p><p>这样的支持使得 Spring 可以集成主流的 ORM 框架，包括 Hibernate, JDO, 及 iBATIS SQL Maps。Spring 的事务管理可以同时支持以上某种框架和 JDBC。</p><h4 id="3-4-Web-与远程调用"><a href="#3-4-Web-与远程调用" class="headerlink" title="3.4 Web 与远程调用"></a>3.4 Web 与远程调用</h4><p>Spring 的 web 模块建立在应用上下文(application context)模块之上，提供了一个适合基于 web 应用程序的上下文环境。该模块还支持了几个面向 web 的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。</p><h5 id="1）Spring-MVC"><a href="#1）Spring-MVC" class="headerlink" title="1）Spring MVC"></a>1）Spring MVC</h5><p>Spring 可以很轻松的同其他 MVC 框架结合，但 Spring 的 MVC 是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。通过 DispatcherServlet, ModelAndView 和 View Resolver，开发 web 应用变得很容易。</p><h5 id="2）HTTP-invoker"><a href="#2）HTTP-invoker" class="headerlink" title="2）HTTP invoker"></a>2）HTTP invoker</h5><p>自带远程调用框架。提供了暴露和使用 REST API 的良好支持。还能集成多种流行远程调用框架。</p><h4 id="3-5-Instrumentation"><a href="#3-5-Instrumentation" class="headerlink" title="3.5 Instrumentation"></a>3.5 Instrumentation</h4><p>提供为 JVM 添加代理的功能。为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文件，就像这些文件是被类加载器加载的一样。</p><h4 id="3-6-测试"><a href="#3-6-测试" class="headerlink" title="3.6 测试"></a>3.6 测试</h4><p>可以与常用的 JUNIT、Mockito、Spock 等测试框架整合使用。</p><p>为使用 JNDI、 Servlet 和 Portlet 编写单元测试提供了一系列的 mock 对象实现。加载 Spring 应用上下文中的 bean 集合以及与 Spring 上下文中的 bean 进行交互提供了支持。</p><h3 id="4-Spring-社区经典项目"><a href="#4-Spring-社区经典项目" class="headerlink" title="4 Spring 社区经典项目"></a>4 Spring 社区经典项目</h3><h4 id="4-1-Spring-Security"><a href="#4-1-Spring-Security" class="headerlink" title="4.1 Spring Security"></a>4.1 Spring Security</h4><p>安全对于许多应用都是一个非常关键的切面。 利用 Spring AOP， 为 Spring 应用提供了声明式的安全机制。</p><h4 id="4-2-Spring-Data"><a href="#4-2-Spring-Data" class="headerlink" title="4.2 Spring Data"></a>4.2 Spring Data</h4><p>使得在 Spring 中使用任何数据库都变得非常容易。 不管使用文档数据库， 还是关系型数据库，Spring Data 都为持久化提供了一种简单的编程模型。包括为多种数据库类型提供了一种自动化的 Repository 机制。</p><h4 id="4-3-Spring-Boot"><a href="#4-3-Spring-Boot" class="headerlink" title="4.3 Spring Boot"></a>4.3 Spring Boot</h4><p>Spring Boot 主要是为了解决使用 Spring 框架需要进行大量的配置太麻烦的问题，所以它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p><p>Spring Boot 大量依赖于自动配置（auto-configuration）技术，它能够消除大部分 Spring 配置。它还提供了多个 Starter 项目，降低了项目搭建的复杂度。同时它集成了大量常用的第三方库配置（例如Jackson, JDBC, Mongo, Redis, Mail等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
